	1-1

-자료구조에 따라서 알고리즘은 달라진다.

-알고리즘은 자료구조에 의존적이다.

	1-2. 알고리즘의 성능분석 방법

-알고리즘을 평가하는 요소:
 -어떤 알고리즘이 어떠한 상황에서 더 빠르고 또 느린가(속도) > 시간 복잡도(time complexity)
 -어떤 알고리즘이 어떠한 상황에서 메모리를 적게 쓰고 또 많이 쓰는가(메모리 사용량) > 공간 복잡도(space complexity)

-메모리를 적게 쓰고 속도도 빨라야 최적의 알고리즘이다.

-알고리즘의 수행속도를 평가할 때는 연산의 횟수를 세고, 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 구성하여 비교한다.

-안정적인 성능을 보장하는 알고리즘은 구현의 난이도가 높기에 성능에 덜 민감한 경우라면 구현의 편의를 이유로 성능이 열등한 알고리즘을 택하기도 한다. 즉, 상황에
 맞게 어떤 알고리즘을 선택할지 답을 내려야 한다.

-종합적으로 사고하고 판단하는 능력이 중요하다.

-알고리즘의 시간 복잡도를 계산하기 위해서는 핵심이 되는 연산이 무엇인지 잘 판단해야 한다. 그리고 그 연산을 중심으로 시간 복잡도를 계산해야 한다.

-모든 알고리즘에는 가장 행복한 경우와 가장 우울한 경우가 각각 존재하며, 이를 '최선의 경우(best case)', '최악의 경우(worst cast)'라 한다.

-최선의 경우는 대부분 만족한만 결과이기 때문에 알고리즘의 성능을 판단하는데 있어서 중요한 것은 '최악의 경우'이다.

-'평균적인 경우(average case)'는 시작 복잡도를 평가하는 정보로 의미를 지니나, 무엇이 평균인가에 대한 난점 때문에 '최악의 경우(worst case)'가 선택된다.

-빅-오라는 것은 함수 T(n)에서 가장 영향력이 큰 부분이 어딘가를 따지는 것이다.

-T(n)이 다항식으로 표현이 된 경우, 최고차항의 차수가 빅-오가 된다.

-빅-오는 '데이터 수의 증가에 따른 연산횟수의 증가 형태(패턴)'을 나타내는 표기법이다.

-따라서 다음이 의미하는 바는
 O(log n)
 다음과 같이 이해해야 옳다.
 "데이터 수의 증가에 따른 연산횟수의 증가 형태를 좌표평면상에 그려놓으면, 증가하는 추세가 둔화되는 형태를 띤다. 다시 말해서 로그 그래프와 유사한 형태를 띤다." 

-대표적인 빅-오
 O(1): 상수형 빅-오. 데이터 수에 상관없이 연산횟수가 고정인 유형의 알고리즘을 뜻한다. 3회 진행되는 알고리즘일지라도 O(1)로 표기한다.
 O(logn): 로그형 빅-오. 이는 '데이터 수의 증가율'에 비해서 '연산횟수의 증가율'이 훨씬 낮은 알고리즘을 의미한다. 바람직한 유형. 로그의 밑에 따라 차이가 나긴 하지만,
            알고리즘의 성능관점에서 미미하기 때문에 대부분 무시된다.
 O(n): 선형 빅-오. 데이터 수와 연산횟수가 비례하는 알고리즘.
 O(nlogn): 선형로그형 빅-오라 한다. 이는 데이터 수가 두 배로 늘 때, 연산횟수는 두 배를 조금 넘게 증가하는 알고리즘을 의미한다.
 O(n^2): 데이터 수의 제곱에 해당하는 연산횟수를 요구하는 알고리즘. 데이터의 양이 많은 경우에는 부적절하다. 이중으로 중첩된 반복문 내에서 알고리즘에 관련된
           연산이 진행되는 경우에 발생한다. 즉, 중첩된 반복문의 사용은 알고리즘 디자인에서 그리 바람직하지 못하다고 할 수 있다.
 O(n^3): 데이터 수의 세 제곱에 해당하는 연산횟수를 요구하는 알고리즘을 의미한다. 삼중 중첩 반복문 내에서 알고리즘에 관련된 연산이 진행되는 경우 발생한다.
           사용하기에는 무리가 있다.
 O(2^n): 지수형 빅-오라 한다. 무서운 연산횟수의 증가를 보이기에 사용하기에는 비현실적이다.

-빅-오 표기들의 성능의 대소 정리:
 O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

-O(n)의 알고리즘을 O(log2)의 알고리즘으로 개선시키는 것은 혁신적인 성능의 개선으로 간주된다.

-빅-오의 수학적 판별법:
 "n>=0, f(n)>=0, g(n)>=0일 때, 두 개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n>=K에 대하여 f(n)<=Cg(n)을 만족하는 두 개의 상수 C와 K가 존재하면, f(n)의 빅-오는 
 O(g(n))이다."
 > 결국 빅오는 "데이터 수의 증가에 따른 연산횟수 증가율의 상한선을 표현한 것"이다.

	2. 재귀(Recursion)

-함수를 실행하는 중간에 다시 그 함수가 호출되면, 해당 함수의 복사본을 하나 더 만들어서 복사본을 실행하게 된다.

-어떠한 재귀를 수식적으로 표현하고 이를 코드로 옮기는 과정에서 이해되지 않는 부분이 없었다면 코드를 이해했다고 봐도 좋다.

	3. 연결 리스트(Linked List) 1

	3.1 추상 자료형: Abstracted Data Type

-'구체적인 기능의 완성과정을 언급하지 않고 순수하게 기능이 무엇인지를 나열한 것'을 가리켜 '추상 자료형' 또는 간단히 ADT라 한다.

-C언어에서는 구조체에서 필요로 하는 연산을 함수를 이용해 정의한다.

-'자료형'의 정의에 '기능' 혹은 '연산'과 관련된 내용을 명시할 수 있다. 추상 자료형이라 하여 그것의 기능 혹은 연산과 관련된 내용을 명시할 수 없다는 생각은 버려야
 한다.

-ADT에 자료구조 자체의 정의는 불필요하다.

-모든 자료구조는 그 내부 구현을 알지 못해도 활용할 수 있도록 구현한다. 그렇게 하기 위해서는 ADT의 정의가 필수적이다.

	3.2 배열을 이용한 리스트의 구현

-리스트라는 자료구조는 구현방법에 따라서 크게 두 가지로 나뉜다:
 순차 리스트: 배열을 기반으로 구현된 리스트
 연결 리스트: 메모리의 동적 할당을 기반으로 구현된 리스트

-리스트 자료구조는 데이터를 나란히 저장한다. 그리고 중복된 데이터의 저장을 막지 않는다.

-리스트를 예로 들면, 데이터를 어떻게 나란히 저장할지를 고민하는 것이 아니라, 나란히 저장된다는 특성을 기반으로 제공해야 할 기능들을 정의하는 것이 옳은 
 접근법이다.

-모든 자료구조는 내부적으로 다양한 정보를 담게 된다. 그저 데이터만 담는 게 아니라 그 데이터를 효율적으로 저장 및 참조하기 위한 정보들도 담기기 마련이다.
 따라서 이와 관련된 변수들의 초기화가 선행되어야 하며 이를 담당하는 함수로 Init함수를 만든다. ex)ListInit

-어떠한 자료구조이건 간에 '자료구조의 구현'과 '구현된 자료구조의 활용'은 완전히 구분되도록 ADT를 정의해야 한다.

-data의 타입 이름을 typedef 해놓으면 다양한 종류의 데이터를 저장하기에 용이해지고, struct의 이름을 typedef 해놓으면 다른 이름을 부여하는 것만으로도 
 리스트의 종류를 바꿀 수 있다.

-List의 데이터 제거 후, 비는 공간을 메우려 데이터를 한 칸씩 이동 시키면서 curPosition은 아직 참조가 이뤄지지 않은, 뒤에서 한 칸 앞으로 이동한 데이터를 가리키게 
 된다. curPosition은 최근에 참조가 이뤄진 데이터의 인덱스 정보를 담고 있어야 하기에 삭제 후 (plist->curPosition)--의 과정이 있어야 한다.

-제대로 만들었다면, 자료 구조의 자료 타입을 변경하고자 할 때 소스 파일의 변경이 발생하면 안 된다.

-리스트의 remove 함수가 삭제된 값을 반환하는 이유는 데이터가 동적 할당된 값일 경우, 메모리의 해제 책임을 떠넘기기 위해서이다.

	4.1 연결리스트의 개념적인 이해

-배열은 메모리의 특성이 정적이어서(길이의 변경이 불가능해서) 메모리의 길이를 변경하는 것이 불가능하다.

-필요할 때마다 컨테이너의 역할을 하는 구조체 변수를 하나씩 동적할당해서 이들을 연결하는 것이 '연결 리스트'의 기본 원리이다.

-자료구조는 코드를 통해서 공부하는 과목이 아니다. 코드를 통한 학습 이전에, 그림으로 설명하고 그림으로 이해해야 한다.

-삭제될 노드가 가리키는 다음 노드의 주소 값을 별도로 저장해 두지 않으면 그 다음 노드에 접근이 불가능해진다.

-자료구조를 제대로 공부하려면 가급적 다음 세 가지 순서를 지키는 것이 좋다:
 1.자료구조의 ADT정의
 2.정의한 ADT의 구현
 3.구현이 완료된 자료구조의 활용

	4.2 단순 연결 리스트의 ADT와 구현.

-노드를 머리에 추가할 경우 포인터 변수 tail이 불필요하나, 저장된 순서를 유지하지 않는다. 꼬리에 추가할 경우 저장된 순서는 유지하나, 포인터 변수 tail이 필요하다.

-리스트 자료구조는 저장된 순서를 유지해야 하는 자료구조가 아니다.

-리스트의 맨 앞에 더미 노드(Dummy node)를 넣어 두면, 처음 추가되는 노드가 구조상 두 번째 노드가 되므로 노드의 추가, 삭제 및 조회의 과정을 일관된 형태로
 구성할 수 있다.

-다수의 리스트 자료를 효율적으로 사용할 수 있는 상황을 위해 head와 cur과 같은 포인터 변수를 묶어서 연결 리스트를 의미하는 구조체를 별도로 정의해야 한다.

	4.3 연결 리스트의 정렬 삽입의 구현

-연결 리스트에서의 정렬기준 설정과 관련된 부분은 묶어서 이해해야 한다:
 정렬기준이 되는 함수를 등록하는 SetSortRule과 같은 함수
 전달된 정렬함수 정보를 저장하기 위한 함수 포인터 멤버
 정렬기준을 근거로 데이터를 저장하는 함수

	5-1. 원형 연결 리스트(Circular Linked List)

-마지막 노드가 첫 번째 노드를 가리켜서, 연결의 형태가 원을 이루는 구조의 연결 리스트를 가리켜서 원형 연결 리스트라 한다.

-원형 연결 리스트의 장점 중 하나는 단순 연결 리스트처럼 머리와 꼬리를 가리키는 포인터 변수를 각각 두지 않아도, 하나의 포인터 변수만 있어도 머리 또는 꼬리에
 노드를 간단히 추가할 수 있다는 것이다.

-tail이나 head 변수를 추가하면 위의 장점이 반감되어 버린다.

-변형된 원형 연결 리스트:
 하나의 포인터 변수가 머리가 아닌 꼬리를 가리키게 하면 노드를 끝에 추가하기 쉽고, tail->next가 첫 번째 노드이니 머리에도 쉽게 노드를 추가할 수 있다.
 첫 번째 노드는 그 자체로 머리이자 꼬리이다.

-노드를 꼬리에 추가했을 때와 머리에 추가했을 때의 유일한 차이점은 tail이 가리키는 노드가 다르다는 점이다.

-삭제:
 삭제할 노드의 이전 노드가 삭제할 노드의 다음 노드를 가리키게 한다.
 포인터 변수를 한칸 뒤로 이동시킨다.
 예외사항-
 삭제할 노드를 tail이 가리키는 경우, 삭제할 노드가 홀로 남은 경우

-원형 연결 리스트에 더미 노드를 붙여주면 함수 구현이 조금 간단해지나, 관련 처리 코드를 추가로 삽입해야 한다.

	5.2 양방향 연결 리스트

-'양방향 연결 리스트(doubly linked list)' 또는 '이중 연결 리스트'라고도 불리는 이 자료구조는 그 이름이 의미하듯이 노드가 양쪽 방향으로 연결된 구조의 리스트이다.

-양방향 연결 리스트도 더미 노드를 추가한 것과 원형 연결 리스트의 구조를 가질 수 있다. tail을 놓을 수도 있고, 뒤에도 더미 노드를 배치할 수 있다.

-양방향 연결 리스트는 양방향 조회가 가능하기에 before 변수가 불필요하다.

	6.1 스택의 이해와 ADT 정의

-스택은 나중에 들어간 것이 먼저 나오는 구조이다 보니 '후입선출 방식의 자료구조'라고도 불리고, 영어로 'LIFO 구조의 자료구조' 라고도 불린다.

-스택을 대표하는 넣고, 꺼내고, 들여다 보는 연산을 가리켜 각각 push, pop, peek이라 한다. 이것이 스택의 보편적인 ADT이다.

-하나의 자료구조를 다른 자료구조 구현에 용이하게 사용할 수 있다. ex) 리스트, 배열 -> 스택

	6.3 스택의 연결 리스트 기반 구현

-기능적인 부분만 고려를 한다면 배열은 대부분 연결 리스트로 교체가 가능하다. 배열도 연결 리스트도 기본적인 선형 자료구조이기 때문이다.

	6.4 계산기 프로그램 구현

-중위 표기법(infix notation) 5 + 2 / 7
 전위 표기법(prefix notation) + 5 / 27
 후위 표기법(postfix notation) 527 / +

-전위/후위 표기법에는 연산순서의 정보가 담겨 있다.

-전위 표기법의 수식이나 후위 표기법의 수식은 연산자의 배치순서에 따라서 연산순서가 결정되기 때문에, 이 두 표기법의 수식을 계산하기 위해서 연산자의
 우선순위를 알 필요가 없고, 소괄호도 삽입되지 않으니 소괄호에 대한 처리도 불필요하다.

-프로그램상에서 작성하는 연산문도 컴파일러에 의해서 후위 표기법으로 바뀌어 처리가 된다.

-중위 표기법 -> 후위 표기법
 피연산자는 그냥 옮긴다
 연산자는 쟁반으로 옮긴다
 연산자가 쟁반에 있다면 우선순위를 비교하여 처리방법을 결정한다
 마지막까지 쟁반에 남아있는 연산자들은 하나씩 꺼내서 옮긴다.
 -우선순위가 높은 연산자는 낮은 연산자 위에 올라서서 우선순위가 낮은 연산자가 먼저 자리를 잡지 못하게 한다.
 -사칙연산의 경우 연산자의 우선순위가 동일하면, 먼저 등장한 연산자를 먼저 진행한다.
 -처리해야 하는 연산자가 쟁반에 있는 연산자들의 중간순서일 때, 쟁반에 있는 연산자들을 모두 옮기고 나서 처리 연산자를 쟁반으로 옮겨야 한다.
 -후위 표기법의 수식에서는 먼저 연산이 이뤄져야 하는 연산자가 뒤에 연산이 이뤄지는 연산자보다 앞에 위치해야 한다.
 -/ 연산자를 쟁반 위에 올릴 때, 쟁반 위에 + 연산자와 * 연산자가 존재한다면, 이들을 모두 빼서 변환된 수식의 자리에 가져다 놓는다.
 -소괄호가 있는 식이면 소괄호도 쟁반에 쌓아 올린다.
 -( 연산자는 ) 연산자가 등장할 때까지 쟁반 위에 남아있어야 하기 때문에 사칙 연산자들보다 연산의 우선순위가 낮다고 간주한다.
 -소괄호의 끝을 의미하는) 연산자는 ( 이후에 쌓인 연산자들을 변환된 수식의 자리로 옮기라는 것이다. 때문에 ) 연산자는 변환된 수식의 자리로 옮기지 않아도 된다.
 -후위 표기법의 수식에서는 연산자의 앞에 등장하는 두 개의 숫자가 피연산자이다.

	7-1 큐의 이해와 ADT 정의

-큐는 선입선출의 자료구조이다.

-Rear가 배열의 끝에 도달하면, 다시 맨 앞으로 이동시켜서 회전하게 만드는 방식의 배열 기반 큐를 가리켜 '원형 큐(Circular queue)'라 한다. R을 쫓아가는 Front도 
 끝에 도달하면 회전해야 한다.

-원형 큐는 계속 회전하기에 F와 R의 상대적 위치를 통해 텅 빈 경우와 꽉 찬 경우를 구분해야 한다. 하지만 그냥 구현하면 큐가 꽉 찬 경우나 텅 빈 경우나 F가
 R보다 한 칸 앞 선 위치를 가리키기에 배열을 꽉 채우지 않고, 배열의 길이가 N이라면 데이터가 N-1개 채워졌을 때, 꽉 찬 것으로 간주하면 된다.
 저장 공간의 낭비보다 얻는 것이 더 많다.
 -enqueue 연산 시, R이 가리키는 위치를 한 칸 이동시킨 다음에, R이 가리키는 위치에 데이터를 저장한다.
 -dequeue 연산 시, F가 가리키는 위치를 한 칸 이동시킨 다음에, F가 가리키는 위치에 저장된 데이터를 반환 및 소멸한다.
  원형 큐가 꽉 찬 상태: R이 가리키는 위치의 앞을 F가 가리킨다.
  원형 큐가 텅 빈 상태: F와 R이 동일한 위치를 가리킨다.

-배열 기반의 큐라 하면 대부분의 경우 원형 큐를 의미한다.

	7-5 덱(Deque)의 이해와 구현

-deque은 double-ended queue를 줄여서 표현한 것으로, 양방향으로 넣고 뺄 수 있다는 사실에 초점이 맞춰져서 지어진 이름이다.

-덱의 구현에는 양방향 연결 리스트가 가장 어울린다.

	8-1 트리의 개요

-트리는 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조이다.

-자료구조는 근본적으로 무엇인가를 표현하는 도구이다. 표현을 위해서 저장과 삭제라는 기능이 제공되는 것으로 이해하는 것이 옳다.

-가지를 늘려가며 뻗어나가는 구조 때문에 트리라 불린다.

-트리를 올바르게 이해하려면 무엇인가를 표현하는 도구라고 생각해야 한다.

용어:
node: 트리의 구성요소
edge: 노드와 노드를 연결하는 연결선
root node: 트리 구조에서 최상위에 존재하는 노드
terminal node(leaf node): 아래로 또 다른 노드가 연결되어 있지 않은 노드
internal node(nonterminal node): terminal node를 제외한 모든 노드

parent node, child node, sibling node

Ancestor, Descendant

-큰 트리에 속하는 작은 트리를 가리켜 '서브 트리(sub tree)'라 한다.

-이진 트리는 다음 두 조건을 만족해야 한다:
 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다.
 나뉘어진 두 서브 트리도 모두 이진 트리이어야 한다.
-노드가 위치할 수 있는 곳에 노드가 존재하지 않는다면, 공집합(empty set)노드가 존재하는 것으로 간주한다. 공집합 노드도 이진 트리의 판단에 있어서 노드로 인정한다.

-트리에서는 각 층별로 숫자를 매겨서 이를 트리의 '레벨'이라 하고, 트리의 최고 레벨을 가리켜 '높이'라 한다.
-레벨은 0부터 시작한다.

-모든 레벨이 꽉 찬 이진 트리를 '포화 이진 트리(full binary tree)'라 한다.

-포화 이진 트리처럼 모든 레벨이 꽉 찬 상태는 아니지만, 차곡차곡 빈 틈 없이 노드가 채워진 이진 트리를 완전 이진 트리(complete binary tree)라 한다. 빈틈없이 노드가 채워진
 상태라는 것은 노드가 위에서 아래로, 그리고 왼쪽에서 오른쪽의 순서대로 채워졌다의 의미이다.

	8-2 이진 트리의 구현

-이진 트리는 재귀적인 특성을 지니고 있다. 이 때문에 이진 트리와 관련된 일부 연산은 재귀호출의 형태를 띤다.

-이진 트리 역시 배열과 연결 리스트 기반으로 구현이 가능하다. 그러나 트리를 표현하기에는 연결 리스트가 더 유연하기에 대부분은 연결 리스트를 기반으로 구현된다.

-트리가 완성 된 이후부터 그 트리를 대상으로 매우 빈번한 탐색이 이루어 진다면 배열 기반의 트리도 고려해 볼만 하다. 배열은 연결 리스트에 비해서 탐색이 매우 용이하고 또
 빠르기 때문이다.

-배열 기반 트리의 경우 인덱스 0은 구현의 편의와 실수 확률의 감소를 위해 일반적으로 사용되지 않는다.

-자식 노드가 하나도 없는 노드도 그 자체로 이진 트리이다. 두 개의 공집합 노드를 자식 노드로 두고 있기 때문이다. 하나의 노드는 노드의 표현결과일 뿐만 아니라 이진 트리의
 표현결과도 된다는 것이다.

-둘 이상의 노드로 이뤄져 있는 서브 트리를 완전히 삭제하려면 서브 트리를 구성하는 모든 노드를 대상으로 free 함수를 호출해야 한다. 즉 모든 노드를 방문해야 하는 것이다.
 이렇듯 모든 노드를 방문하는 것을 가리켜 '순회'라 하는데, 이진 트리의 순회는 연결 리스트의 순회와 달리 별도의 방법이 필요하다.

	8-3 이진 트리의 순회(Traversal)

-순회의 방법 또한 재귀적이다.

-순회의 세 가지 방법:
 전위 순회(Preorder Traversal): 루트 노드를 먼저
 중위 순회(Inorder Traversal): 루트 노드를 중간에
 후위 순회(Postorder Traversal): 루트 노드를 마지막에

-노드를 방문햇을 때 할 일을 결정할 수 있도록 트리의 순회 함수에 함수 포인터를 인자값으로 받는다.

	8-4 수식 트리(expression tree)의 구현

-이진 트리를 이용해서 수식을 표현해 놓은 것을 가리켜 '수식 트리'라 한다.

-수식을 수식 트리로 표현하면 컴파일러의 수식해석이 좋아진다.

-수식 트리는, 그리고 수식 트리를 구성하는 모든 서브 트리는 기본적으로 다음의 방식으로 연산이 진행된다:
 루트 노드에 저장된 연산자의 연산을 하되, 두 개의 자식 노드에 저장된 두 피연산자를 대상으로 연산을 한다.

-수식 트리를 후위 순회하면서 노드에 저장된 데이터를 출력하면 그 결과가 바로 후위 표기법의 수식이 된다.

-후위 표기법의 수식에서 앞쪽에 등장하는 피연산자와 연산자를 이용해서 트리의 하단을 만들고, 이를 바탕으로 점진적으로 트리의 윗부분을 구성해 나간다:
 -문자가 피연산자라면 스택으로 옮긴다.
 -연산자가 등장하면, 스택에 쌓여 있는 두 개의 피연산자를 꺼내어 연산자의 자식 노드로 연결해야 한다. 먼저 꺼내진 피연산자가 오른쪽 자식 노드가 된다. 그 후 만들어진
  수식 트리를 다시 스택으로 옮긴다.

	9-1. 우선순위 큐의 이해

-우선순의 큐의 연산결과는 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다.

-우선순위 큐를 구현하는 방법은 세 가지로 구분된다:
 배열기반
 연결 리스트 기반
 힙(heap)기반

-배열 기반은 삽입 및 삭제 과정에서 데이터 이동 연산이 수반된다. 또 삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위의 비교를 진행해야 할 수도 있다.

-연결 리스트의 경우는 삽입의 위치를 찾기 위해서 첫 번째 노드에서부터 시작해서 마지막 노드에 저장된 데이터와 우선순위의 비교를 진행해야 할 수도 있다.

-힙은 이진 트리이되, 완전 이진 트리이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.

-루트 노드로 올라갈수록 값이 커지는 완전 이진 트리를 가리켜 최대 힙(max heap)이라 한다. 반면 루트 노드로 올라갈수록 저장된 값이 작아지는 완전 이진 트리를 가리켜
 최소 힙(min heap)이라 한다.

	9-2. 힙의 구현과 우선순위 큐의 완성.

-저장:
 새로운 데이터는 우선 순위가 제일 낮다는 가정하에서 '마지막 위치'에 저장한다. 그리고는 부모 노드와 우선순위를 비교해서 위치가 바귀어야 한다면 바꿔준다. 바뀐 후에도
 제대로된 위치를 찾을 때까지 계속해서 부모 노드와 비교한다. 
 '마지막 위치'는 노드를 추가한 이후에도 완전 이진 트리가 유지되는, 마지막 레벨의가장 오른쪽 위치를 뜻한다.
-루트 노드 삭제:
 루트 노드 삭제 후, 마지막 노드를 루트 노드의 자리로 옮긴 다음에, 자식 노드와의 비교를 통해서 제자리를 찾아가게 한다.

-힙의 구현은 배열을 기반으로 구현하는 것이 원칙으로 여겨지고 있는데, 그 이유는 연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 
 것이 쉽지 않기 때문이다.

-배열을 기반으로 트리를 구성하는 방법:
 노드에 고유의 번호를 부여한다. 그리고 그 번호가 각 노드의 데이터가 저장될 배열의 인덱스 값이 된다.
 왼쪽 자식 노드의 인덱스 값: 부모 노드의 인덱스 값 * 2
 오른쪽 자식 노드의 인덱스 값: 부모 노드의 인덱스 값 * 2 + 1
 부모 노드의 인덱스 값: 자식 노드의 인덱스 값 / 2

-힙의 구현은 배열을 기반으로 하며 인덱스가 0인 요소는 비워둔다.

-힙은 완전 이진 트리이므로 오른쪽 자식 노드만 존재하는 상황은 발생하지 않는다. 따라서 왼쪽 자식 노드가 없다면 자식 노드가 존재하지 않는 것으로 판단할 수 있다.

-힙의 하나뿐인 자식 노드는 왼쪽 자식 노드이다. 그리고 합의 마지막 노드이다.

-힙의 삭제 과정에서 루트 노드로 올려진 마지막 노드는 자신의 위치를 찾을 때까지 아래로 이동하면서 자신의 위치를 찾아간다. 하지만 이러한 빈번한 이동을 코드에 그대로 담을 필요는 없다.
 최종 목적지가 결정되면 단번에 그리로 옮기면 된다.

-프로그래머가 우선순위의 판단 기준을 힙에 설정할 수 있어야 한다.

-좀 더 쓸만한 힙을 만들기 위해 데이터와 우선순의를 묶은 heamElem 구조체를 없애고 Heap 구조체에 우선순위의 높낮이를 판단하는 함수를 등록하기 위한 포인터를
 추가한다. 등록할 함수는 프로그래머가 직접 정의해야 한다. 초기화 때 함수도 같이 초기화한다.

-우선순위 큐를 고려하여 힙을 구현했기 때문에 사실상 우선순위 큐를 구현한 것이나 다름없다.

	10. 정렬(Sorting)

	10-1. 단순한 정렬 알고리즘

-버블 정렬(Bubble Sort):

 -정렬 알고리즘의 성능은 비교의 횟수와 이동의 횟수 두 가지를 근거로 판단하는 것이 일반적이다. 그 둘이 정렬 과정의 핵심연산이기 때문이다.

 -실제로 시간 복잡도에 대한 빅-오를 결정하는 기준은 '비교의 횟수'이다. 하지만 '이동의 횟수'까지 살펴보면 동일한 빅-오의 복잡도를 갖는 알고리즘간의 세밀한 비교가 가능하다.

 -데이터의 이동 횟수(교환횟수)는 최선의 경우와 최악의 경우가 구분이 된다.

-선택 정렬(Selection Sort):

 -선택 정렬은 정렬 순서에 맞게 하나씩 선택해서 옮기는, 옮기면서 정렬이 되게 하는 알고리즘이다.
  정렬 순서상 가장 앞서는 것을 선택해서 가장 왼쪽으로 이동시키고, 원래 그 자리에 있던 데이터는 빈 자리에 가져다 놓는다.

 -선택 정렬의 빅-오 역시 버블 정렬과 같이 n^2이다. 그러나 데이터의 이동 횟수가 더 적다.
 
 -최악의 경우를 놓고 보면 버블 정렬보다 선택 정렬에 좋은 성능을 기대할 수 있겠지만, 버블 정렬은 최선의 경우에 단 한 번의 데이터 이동도 발생하지 않는다는 점과, 실제로 데이터들이 늘
  최악의 상황으로 배치되지 않는다는 사실을 감안하면, 이 둘의 우열의 가리는 것은 무의미하다.

-삽입 정렬(Insertion Sort):
 
 -삽입 정렬은 정렬 대상을 두 부분으로 나눠서, 정렬 안 된 부분에 있는 데이터를 정렬 된 부분의 특정 위치에 '삽입'해 가면서 정렬을 진행하는 알고리즘이다.
 
 -정렬이 완료된 영역의 다음에 위치한 데이터가 그 다음 정렬 대상이다.

 -삽입할 위치를 발견하고 데이터를 한 칸씩 뒤로 밀수도 있지만, 데이터를 한 칸씩 뒤로 밀면서 삽입할 위치를 찾을 수도 있다.

 -최악의 경우 두 정렬들과 다를 바 없다. n^2의 빅-오를 가진다.

	10-2. 복잡하지만 효율적인 정렬 알고리즘

-힙 정렬(Heap Sort):
 
 -정렬의 대상인 데이터들을 힙에 넣었다가 꺼내는 것이 전부이다. 그럼에도 불구하고 정렬이 완료되는 이유는, 꺼낼 때 힙의 루트 노드에 저장된 데이터가 반환되기 때문이다.

 -힙 정렬의 시간 복잡도는 밑을 2로하는 로그 

-병합 정렬(Merge Sort):

 -병합 정렬은 '분할 정복(divide and conquer)'이라는 알고리즘 디자인 기법에 근거하여 만들어진 정렬 방법이다. 분할 정복이란, 복잡한 문제를 복잡하지 않은 문제로 '분할(divide)' 및
  '정복(conquer)'하는 방법이다. 단 분할했으니 후에 결합(combine)의 과정을 거쳐야 한다.
   1. 분할: 해결이 용이한 단계까지 문제를 분할해 나간다.
   2. 정복: 해결이 용이한 수준까지 분할된 문제를 해결한다.
   3. 결합: 분할해서 해결한 결과를 결합해여 마무리한다.

 -기본 원리: 8개의 데이터를 동시에 정렬하는 것보다, 이를 둘로 나눠서 4개의 데이터를 정렬하는 것이 쉽고, 또 이들 각각을 둘로 나눠서 2개의 데이터를 정렬하는 것이 더 쉽다.

 -실제 정렬은 나눈 것을 병합하는 과정에서 이뤄진다.

 -이전의 정렬 함수들의 경우에는 정렬 대상의 범위정보를 전달하지 않고, 대신에 정렬될 데이터의 개수 정보를 전달하였다. 하지만 병합 정렬의 경우는 정렬의 대상을 계속해서
  반으로 나눠가기 때문에 정렬의 범위를 지정할 수 있어야 한다.

 -병합 정렬의 성능은 MergeSort 함수가 아닌, MergeTwoArea 함수를 기준으로 계산해야 한다.

 -병합 정렬의 비교연산과 이동연산의 빅-오는 nlog2(n)으로 정리가 된다. 병합 정렬에는 임시 메모리가 필요하다는 단점이 있으나, 이는 정렬의 대상이 배열이 아닌 연결 리스트일
  경우 단점이 되지 않기 때문에, 연결 리스트의 경우에는 병합정렬에서 그만큼 더 좋은 성능을 기대할 수 있다.

-퀵 정렬(Quick Sort):
 -left는 정렬 대상의 가장 왼쪽 지점을 가리키는 이름
 -right는 정렬 대상의 가장 오른쪽 지점을 가리키는 이름
 -임의의 결정으로 피벗(pivot)을 정한다(편의상 가장 왼쪽)
 -low는 피벗을 제외한 가장 왼쪽에 위치한 지점을 가리키는 이름
 -high는 피벗을 제외한 가장 오른쪽에 위치한 지점을 가리키는 이름
 -low의 오른쪽 방향 이동: 피벗보다 정렬의 우선순위가 낮은 데이터를 만날 때까지
 -high의 왼쪽 방향 이동: 피벗보다 정렬의 우선순위가 높은 데이터를 만날 때까지
 -low와 high의 이동은 완전히 별개이다.
 -위 조건에 맞게 low와 high가 이동을 멈추면 값을 교환해 나간다.
 -low와 high가 가리키는 위치가 교차되는 상황이 발생하면 pivot과 high의 값을 교환한다.
 -위 과정을 반복해 나가다가 left > right의 교차되는 상황에 정렬할 대상이 없으므로 정지한다.
 -같은 값의 원소가 존재할 경우를 위해 while 조건문의 경계검사를 잊지 말아야 한다.

 -전체 데이터를 기준으로 중간에 해당하는 값을 피벗으로 결정할 때 좋은 성능을 보인다.

 -피벗이 중간에 해당하는 값일 경우, 정렬대상은 균등하게 나뉜다.

 -정렬의 과정에서 피벗의 수는 정의한 partition 함수의 호출횟수를 의미한다. 그리고 Partition 함수의 호출횟수가 많다는 것은 그만큼 데이터의 비교 및 이동의 횟수가 증가함을
  뜻한다. 즉 좋은 성능을 보이려면 최대한 중간 값에 가까운 피벗이 지속적으로 선택되어야 한다. 이를 위해서 다음과 같은 방법이 사용된다:
  정렬 대상에서 세 개의 데이터를 추출한다. 그리고 그 중에서 중간 값에 해당하는 것을 피벗으로 선택한다.

 -퀵 정렬의 경우 '중간에 가까운 피벗을 선택하는 방법'을 적용함으로써, 최선의 경우에 근사한 성능을 평균적으로 보이기 때문에 최선의 경우에 대한 빅-오를 구한다.

 -퀵 정렬은 시간 복잡도가 nlog2(n)인 알고리즘이다. 하지만 데이터의 이동이 데이터의 비교에 비해 현저히 적게 나타나고, 별도의 메모리 공간을 요구하지 않으므로 동일한
  빅-오를 갖는 다른 정렬 알고리즘 중에서 평균적으로 가장 빠른 정렬속도를 보이는 알고리즘이다.

-기수 정렬(Radix Sort):
 -기수 정렬은 정렬순서상 앞서고 뒤섬의 판단을 위한 비교연산을 하지 않는다.
 
 -정렬 알고리즘의 이론상 성능의 한계는 O(nlog2(n))으로 알려져 있는데, 기수 정렬은 이러한 한계를 넘어설 수 있는 유일한 알고리즘이다.

 -하지만 다른 알고리즘에는 없는 단점도 있는데, 그것은 바로 '적용할 수 있는 범위가 제한적'이라는 것이다.

 -길이가 같은 데이터들을 대상으로는 정렬이 가능하지만, 길이가 같지 않은 데이터들을 대상으로는 정렬이 불가능하다.

 -데이터의 길이가 다른 값들도 정렬의 대상이 될 수 있으나, 별도의 알고리즘을 고민해야 한다. 뿐만 아니라 별도의 알고리즘 적용으로 인한 효율의 문제도 고민해야 한다.

 -'기수(radix)'란 주어진 데이터를 구성하는 기본 요소를 의미한다(2진수는 0, 1 10진수는 0~9). 

 -따라서 기수 정렬은 "데이터를 구성하는 기본 요소, 즉 기수를 이용해서 정렬을 진행하는 방식"이라 할 수 있다.

 -LSD(Least Significant Digit)기수 정렬의 경우 작은 자릿수에서 시작해서 큰 자릿수까지 모두 비교를 해야 값의 대소를 판단할 수 있는 단점이 있다. 비교 중간에 대소를 
  판단하는 것은 불가능하다.

 -MSD(Most Significant Digit)는 가장 큰 자릿수에서부터 정렬이 시작된다.

 -MSD의 가장 큰 장점은 반드시 끝까지 가지 않아도 된다는 것이다. 중간에 정렬이 완료될 수도 있다.

 -하지만 모든 데이터에 일괄적인 과정을 거치게 할 수 없다는 단점이 있다.

 -정렬 대상의 일부는 다음 단계로 넘어가되 일부는 넘어가면 안 되는 상황도 빈번히 등장하기 때문에, MSD 방식에서는 중간에 데이터를 점검해야 한다. 따라서 구현의
  난이도가 LSD에 비해서 상대적으로 높다. 게다가 성능의 이점도 반감될 수 있다.

 -LSD와 MSD의 빅-오는 같다. MSD의 경우 조금의 성능 향상을 기대할 순 있지만, 모든 데이터에 일괄적인 과정을 거치게 할 수 없기 때문에 추가적인 연산과 별도의 메모리가
  요구된다. 따라서 일반적인 상황이라면 굳이 MSD 방식을 고집할 이유가 없다.

 -기수 정렬은 비교연산이 핵심이 아니다. 오히려 버킷으로의 데이터 삽입과 추출이 핵심이다. 따라서 이 정렬의 시간 복잡도는 삽입과 추출의 빈도수를 대상으로 결정해야 한다.

 -버킷을 대상으로 하는 데이터의 삽입과 추출을 한 쌍의 연산으로 묶으면, 연산 수행 횟수는 maxLen x num이다. 고로 시간 복잡도에 대한 빅-오는 O(n)이다.

 -기수 정렬의 성능은 뛰어나지만 적용 가능한 대상이 제한적이라는 단점이 있다.

	11-1 탐색의 이해와 보간 탐색

-굳이 따지자면 탐색은 알고리즘보다 자료구조에 더 가까운 주제이다.

-효율적인 탐색을 위해서는 '어떻게 찾을까'만을 고민해서는 안 된다. 그보다는 '효율적인 탐색을 위한 저장방법이 무엇일까'를 우선 고민해야 한다.

-효율적인 탐색이 가능한 대표적인 저장방법은 '트리'이다.

-이진 탐색은 찾는 대상의 위치에 따라서 탐색의 효율에 차이가 발생한다. 보간 탐색(Interpolation Search)은 그러한 이진 탐색의 비효율성을 개선시킨 알고리즘이다.
 개선의 원리: 이진 탐색처럼 그냥 중앙에서 탐색을 시작하지 말고, 탐색대상이 앞쪽에 위치해 있으면 앞쪽에서 탐색을 시작하자.

-'데이터'와 데이터가 저장된 위치의 '인덱스 값'이 직선의 형태로 비례하면(선형의 형태로 비례하면), 보간 탐색의 경우 단번에 데이터를 찾기도 한다. 단번에 찾지 못하더라도
 탐색의 위치가 찾는 데이터와 가깝기 때문에 탐색대상을 줄이는 속도가 이진 탐색보다 뛰어나다.

-보간 탐색은 데이터의 값과 그 데이터가 저장된 위치의 인덱스 값이 비례한다고 가정한다. 이를 근거로 다음의 비례식을 구성한다:
 A(arr[high] - arr[low]) : Q(arr[s] - arr[low]) = (high-low) : (s - low) 이를 통해 s를 구하면 인덱스 값을 구할 수 있다.

-위는 나눗셈 연산이 들어가는 데다 오차율을 최소화하기 위해서 실수형 나눗셈을 진행한다. 이는 보간 탐색의 단점이다.

-일반적인 탐색 상황에서는 탐색 키와 탐색 데이터를 묶는 형태의 구조체를 정의하게 되고, 정렬이나 탐색이나 그 탐색의 대상을 탐색 키에 맞추게 된다.

-탐색 키는 그 값이 고유해야 한다. 키에는 그 값이 유일하다는 의미가 담겨 있고 NULL과 같은 값이 채워질 수 없다는 의미도 담겨있다.

-이진 탐색과 보간 탐색의 유일한 차이점은 탐색의 대상을 선택하는 방법에 있으니, 이를 맞게 바꾸면 보간 탐색 구현이 완료된다.

	11-2 이진 탐색 트리

-이진트리는 단말 노드에 이르는 길의 갈래가 매우 많다. 따라서 찾는 데이터가 존재하는 제대로 된 길을 선택할 수 있어야 한다.

-이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.

-즉, '이진 트리'에 '데이터의 저장 규칙'을 더해놓은 것이 '이진 탐색 트리'이다. 

-이진 탐색 트리가 되기 위한 조건:
 -이진 탐색 트리의 노드에 저장된 키(key)는 유일하다.
 -루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키보다 크다.
 -루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다.
 -왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.

-왼쪽 자식 노드의 키 < 부모 노드의 키 < 오른쪽 자식 노드의 키 이기에 '작으면 왼쪽으로, 크면 오른쪽으로'라는 원칙을 기준으로 데이터를 삽입한다.

-이진 탐색 트리는 이진 트리의 확장이다.

-이진 탐색 트리의 핵심 연산 세 가지는 다른 자료구조들과 마찬가지로 삽입, 삭제 그리고 탐색이다.

-비교대상보다 값이 작으면 왼쪽 자식 노드로, 값이 크면 오른쪽 자식 노드로 이동한다:
 비교대상이 없을 때까지 내려간다. 그리고 비교대상이 없는 그 위치가 새 데이터가 저장될 위치이다.

-이진 탐색 트리의 삭제가 어려운 이유는 임의의 노드를 삭제하는 경우, 삭제 후에도 이진 탐색 트리가 유지되도록 빈 자리를 채워야 하기 때문이다.

-이진 탐색 트리 삭제의 경우의 수:
 1. 삭제할 노드가 단말 노드인 경우
 2. 삭제할 노드가 하나의 자식 노드를(하나의 서브 트리를) 갖는 경우
 3. 삭제할 노드가 두 개의 자식 노드를(두 개의 서브 트리를) 갖는 경우
 하지만 구현 방법에 따라서, 삭제 대상이 루트 노드인 경우와 그렇지 않은 경우를 나눠야 하기 때문에 삭제에 대한 경우의 수는 최대 여섯 가지로 구분할
 수도 있다.

-1의 상황은 삭제 대상인 단말 노드를 삭제하는 것으로 삭제의 과정이 완료된다.

-2의 상황에선 부모 노드와 자식 노드를 연결하는 작업만 추가하면 된다.

-3의 상황에선 대체할 후보로 두 개의 노드를 꼽을 수 있다:
 -삭제 대상 노드의 왼쪽 서브 트리에서 가장 큰 값
 -삭제 대상 노드의 오른쪽 서브 트리에서 가장 작은 값
 -가장 큰 값을 찾을 때는 NULL을 만날 때까지 계속해서 오른쪽 자식 노드로 이동하면 되고, 가장 작은 값을 찾을 때는 NULL을 만날 때까지 계속해서
  왼쪽 자식 노드로 이동하면 된다.
 -위 둘 중 어느 것으로 대체해도 이진 탐색 트리의 유지에는 지장이 없다.

-3의 상황에서의 삭제 과정:
 1. 삭제할 노드를 대체할 노드를 찾는다.
 2. 대체할 노드에 저장된 값을 삭제할 노드에 대입한다.
 3. 대체할 노드의 부모 노드와 자식 노드를 연결한다. -> 이 방법을 사용할 경우, 삭제 대상의 부모 노드와 자식 노드의 연결 유지를 위한 별도의 코드
    삽입이 불필요해진다.

-보통 '삭제' 또는 '제거'라고 하면 반드시 메모리의 해제까지 담당해야 하는 것으로 오해하는 경우가 많다. 하지만 '삭제'와 '메모리의 해제'는 별개의
 것이다. 삭제과정에서 메모리의 해제를 포함하는 경우도 있지만, 반드시 필요한 것은 아니며 오히려 포함해서는 안되는 경우도 존재한다. 

-삭제과정에서 메모리의 해제를 포함하지 않는 것이 일반적이다. 대신에 주소 값의 반환을 통해서 메모리의 해제에 대한 책임을 함수를 호출한
 영역으로 넘긴다.

-처음부터 필요로 할 모든 것을 완벽히 예측해서 도구를 만드는 것은 쉽지 않다. 그리고 그것이 옳은 것만은 아니다. 오히려 필요에 따라서 도구를
 확장하고 수정해 나가는 것이 현명한 방법이다.

-삭제 과정에서 가상의 루트 노드를 두는 이유는 삭제할 노드가 루트 노드인 경우의 예외적인 삭제흐름을 일반화하기 위함이다.

-삭제할 노드를 cNode가 가리키게 되는데, 삭제의 과정에서는 cNode의 부모와 자식을 연결시키는 과정이 등장하는 경우가 있다. 때문에 cNode의
 부모 노드를 언제든 가리키고 있어야 한다.

	12-1 균형 잡힌 이진 트리 탐색: AVL 트리의 이해

-이진 탐색 트리는 균형이 맞지 않을수록 O(n)에 가까운 시간 복잡도를 보인다. 

-이진 탐색 트리의 단점은 저장 순서에 따라 탐색의 성능에 큰 차이를 보인다는 것이다.

-이진 탐색 트리의 단점을 해결한 트리를 가리켜 '균형 잡힌 이진 트리'라 한다:
 AVL트리
 2-3 트리
 2-3-4 트리
 Red-Blakc 트리
 B 트리

-AVL 트리는 노드가 추가될 때, 그리고 삭제될 때 트리의 균형상태를 파악해서 스스로 그 구조를 변경하여 균형을 잡는다.

-AVL트리에서는 균형의 정도를 표현하기 위해서 '균형 인수(Balance Factor)'를 사용한다:
 군형 인수 = 왼쪽 서브 트리의 높이 - 오른쪽 서브 트리의 높이

-균형 인수의 절댓값이 크면 클수록 그만큼 트리의 균형이 무너진 상태이다. 따라서 AVL 트리는 균형 인수의 절댓값이 2이상인 경우에 균형을 잡기
 위한 트리의 재조정을 진행한다.

-리밸런싱은 4가지 방법이 있다.

-자식 노드 두 개가 왼쪽으로 연이어 연결되어서 균형 인수 +2가 연출되었다. 따라서 Left Left 상태: LL상태라 한다. 그리고 이러한 LL상태를 해결
 하기 위한 리밸런싱 방법을 가리켜 'LL회전'이라 한다. LL상태에서 균형을 잡기 위해 필요한 회전을 의미한다.

-RR상태와 LL상태의 차이점, 그리고 RR회전과 LL회전의 유일한 차이점은 방향이다.

-LR상태는 한 번의 회전으로 균형을 잡을 수 없다. 고로 LR상태를 한 번의 회전으로 균형이 잡히는 LL상태나 RR상태로 일단 바꾼다.

-LR상태는 RR회전을 통해서 LL상태가 되게 할 수 있다.

-RR회전을 통해서 부모와 자식의 관계가 바뀌는 부수효과를 얻을 수 있다.

-LR회전은 부분적 RR회전과 LL회전의 조합으로 이뤄진다.

-LR상태와 RL상태는 방향의 차이만 있기 때문에, RL회전은 부분적 LL회전과 RR회전의 조합으로 이뤄진다.

	12-2. 균형 잡힌 이진 탐색 트리: AVL 트리의 구현

-균형이 깨지는 상황은 노드의 삽입과 삭제의 과정에서 발생한다. 따라서 insert와 remove과정에서 리밸런싱 함수를 호출해 주어야 한다.

-회전과정에서 루트 노드가 변경될 수 있기 때문에 Rebalance 함수는 루트 노드의 주소값 정보를 반환한다.

-소스 파일에 정의된 모든 함수의 선언을 헤더파일에 담는 것은 혼란을 가중시킬 수 있어서 좋지 못하다. 

	13-1. 빠른 탐색을 보이는 해쉬 테이블

-AVL 트리의 탐색 연산이 O(log2(n))의 시간 복잡도를 보이는 반면, 테이블 자료구조의 탐색 연산은 O(1)의 시간 복잡도를 보인다.

-저장되는 데이터는 키(key)와 값(value)이 하나의 쌍을 이룬다.

-테이블에는 키와 관련해서 다음의 조건이 존재한다:
 키(key)가 존재하지 않는 '값'은 저장할 수 없다. 그리고 모든 키는 중복되지 않는다.

-자료구조 '테이블'은 '사전구조(dictionary)'라고도 불린다. 더불어 '맵(map)'이라 불리기도 한다.

-다음 조건을 만족한다면 단순한 배열도 테이블, 또는 테이블의 일부라 할 수 있다:
 "키를 결정하였다면, 이를 기반으로 데이터를 단번에 찾을 수 있어야 한다."
 즉 테이블에서 의미하는 키는 데이터를 찾는 도구가 되어야 한다. 그것도 단번에 찾을 수 있어야 한다.

-배열의 인덱스를 활용하여 테이블을 만드는 것은 문제가 있다. 번호의 범위가 인덱스 값으로 사용하기 적당하지 않을 수 있고, 범위가 넓으면
 그것을 수용할 수 있는 넓은 배열이 필요하다.

-위와 같은 문제를 해결해주는 것이 '해쉬 함수(hash function)'이다. 해쉬 함수는 넓은 범위의 키를 좁은 범위의 키로 변경하는 역할을 한다.

-해쉬 함수를 통해 줄여진 값이 동일하게 나오는 상황을 충돌(collision)이라고 한다.

-충돌은 피해야 하는 상황이 아니라 해결해야 하는 상황이다. 충돌의 해결방법에 따라서 테이블의 구조가 달리지는 경우가 있을만큼 충돌의
 해결 방법은 테이블에 있어서 큰 의미를 갖는다.

-슬롯이란 '테이블을 이루는, 데이터를 저장할 수 있는 각각의 공간'을 의미한다.

-데이터가 테이블의 전체 영역에 고루 분포된다는 것은 그만큼 '충돌'이 발생할 확률이 낮다는 것을 의미한다.

-좋은 해쉬 함수는 키의 일부분을 참조하여 해쉬 값을 만들지 않고, 키 전체를 참조하여 해쉬 값을 만들어 낸다.

-자릿수 선택(Digit Selection)방법:
 "여덟 자리의 수로 이뤄진 키에서 다양한 해쉬 값 생성에 도움을 주는 네 자리의 수를 뽑아서 해쉬 값을 생성한다."

-자릿수 폴딩(Digit Folding)은 종이를 접듯이 숫자를 겹치게 하여 더한 결과를 해쉬 값으로 결정하는 방법이다.

-충돌이 발생했을 때 그 옆자리가 비었는지 살펴보고, 비었을 경우 그 자리에 대신 저장하는 것이 바로 '선형 조사법(Linear Probing)'이다.

-선형 조사법은 충돌의 횟수가 증가함에 따라서 '클러스터 현상' 즉, 특정 영역에 데이터가 집중적으로 몰리는 현상이 발생한다는 단점이 있다.

-선형 조사법은 충돌 발생시 n칸 옆의 슬롯을 검사한다면, 이차 조사법은 n^2칸 옆의 슬롯을 검사한다. 조금 멀리서 빈 공간을 찾으려는
 노력이 담겨 있다.

-슬롯의 상태:
 EMPTY - 이 슬롯에는 데이터가 저장된바 없다.
 DELETED - 데이터가 저장된바 있으나 현재는 비워진 상태다.
 INUSE - 현재 유효한 데이터가 저장되어 있다.

-선형, 이차 조사법과 같은 충돌의 해결책을 적용하기 위해서는 슬롯의 상태에 DELETED를 포함시켜야 한다.

-선형, 이차 조사법을 적용하였다면, 탐색의 과정에서도 이를 근거로 충돌을 의심하는 탐색의 과정을 포함시켜야 한다.

-이중 해쉬(Double Hash) 방법에서는 두 개의 해쉬 함수를 마련한다. 하나는 키를 근거로 저장위치를 결정하기 위한 것이다. 다른 하나는 충돌이 발생했을 때, 몇 칸 뒤에 위치한 슬롯을 살펴볼지
 그 거리를 결정하기 위한 것이다:
 h1(k) = k % 15
 h2(k) = 1 + (k % c) // 일반적인 형태의 2차식
 -1을 더하는 이유는 2차 해쉬 값이 0이 되는 것을 막기 위해서이다.
 -c를 15보다 작은 값으로 결정하는 이유는, 가급적 2차 해쉬 값이 1차 해쉬 값을 넘어서지 않게 하기 위함이다.
 -c를 소수로 결정하는 이유는 소수를 선택했을 때 클러스터 현상의 발생 확률이 현저히 낮다는 통계때문이다.

-앞선 유형들을 열린 어드레싱 방법(open addressing method)이라 하는데, 이는 충돌이 발생하면 다른 자리에 대신 저장한다는 의미가 담겨 있다. 닫힌 어드레싱 방법(close addressing method)
 는 반대의 의미를 가지고 있다.

-닫힌 어드레싱 방법을 구현하는데는 배열을 이용하는 방법과 연결 리스트를 이용하는 방법이 있다. 그러나 2차원 배열은 충돌이 발생하지 않을 경우 메모리 낭비가 심하고, 충돌의 최대 횟수를
 결정해야 하는 부담이 있다.

-슬롯을 생성하여 연결 리스트의 모델로 연결해나가는 방식으로 충돌 문제를 해결하는 것이 '체이닝' 방법이다. 탐색을 위해서는 동일한 해쉬 값으로 묶여있는 연결된 슬롯을 모두 조사해야
 한다는 불편이 따르나, 해쉬 함수를 잘 정의한다면, 그래서 충돌의 확률이 높지 않다면 연결된 슬롯의 길이는 부담스러운 정도가 아닐 것이다.

-열린 어드레싱 방법을 택하는 경우에는 슬롯의 상태 정보를 표시해야 하지만, 닫힌 어드레싱 방법을 택하는 경우에는 슬롯의 상태 정보를 표시할 필요가 없다.

-체이닝의 구현을 위한 두 가지 방법:
 -슬롯이 연결 리스트의 노드 역할을 하게 하는 방법
 -연결 리스트의 노드와 슬롯을 구분하는 방법
  -노드에 슬롯의 주소 값을 Data로 typedef하여 저장하는 형태
  -슬롯이 노드의 멤버가 되기하는 형태

-노드와 슬롯을 구분하는 방법을 선택하면, 연결 리스트 관련 코드와 테이블 관련 코드의 구분이 용이하기 때문에 조금 더 편리하다.

-일반적으로 함수를 정의할 때에는 다음 두 가지를 고민해야 한다:
 함수호출을 통해서 얻고자 하는 데이터를 어떻게 전달할 것인가
 함수호출의 성공여부를 어떻게 전달할 것인가.

	14. 그래프

	14-1. 그래프의 이해와 종류

-정점 별로 연결된 간선의 수가 모두 짝수이어야, 간선을  한 번씩만 지나서 처음 출발했던 정점으로 돌아올 수 있다.

-'정점(vertex)'은 연결의 대상이 되는 개체 또는 위치를 의미하고, '간선(edge)'은 이들 사이의 연결을 의미한다.

-연결 관계에 있어서 방향성이 없는 그래프를 가리켜 '무방향 그래프(undirected graph)'라 한다.

-간선에 방향정보가 포함된 그래프를 가리켜 '방향 그래프(directed graph)' 또는 '다이그래프(digraph)'라 한다.

-'무방향 그래프'와 '방향 그래프'는 간선의 연결형태에 따라서 '완전 그래프(complete graph)'로 구분이 된다. 완전 그래프란 '각각의 정점에서 다른 모든 정점을 연결한 그래프'를 뜻한다.
 때문에 정점의 수가 동일한 완전 그래프라 하더라도, 방향 그래프의 간선의 수는 무방향 그래프의 간선의 수에 두 배가 된다.

-간선에 가중치 정보를 두어서 그래프를 구성할 수도 있다. 이러한 유형의 그래프를 가리켜 '가중치 그래프(Weight Graph)'라 한다.

-'부분 집합'과 유사한 개념으로 '부분 그래프'라는 것이 있다. 부분 집합이 원 집합의 일부 원소로 이루어진 집합인 것처럼, 부분 그래프는 원 그래프의 일부 정점 및 간선으로 이뤄진 그래프를
 뜻한다.

-그래프는 정점과 간선의 집합이다. 따라서 집합의 표기법을 이용해서 표현할 수 있다.

-그래프는 정점과 간선으로 이루어지므로, 정점의 집합과 간선의 집합으로 나누어서 표현한다:
 그래프 G의 정점 집합: V(G)
 그래프 G의 간선 집합: E(G)
 무방향 그래프에서 정점 A와 정점 B를 연결하는 간선을 (A, B)로 표시한다. ex) V(G1) = { A, B, C, D } E(G1) = { (A, B), (A, C), (A, D), (B, C), (C, D) }
 
 -무방향 그래프와 방향 그래프의 표현에서 유일한 차이는 방향성이 있는 간선의 표시법에 있다:
  정점 A가 정점 C를 가리키는 간선 <A, C>

-그래프를 구현하는 방법도 배열을 이용하는 방법과 연결 리스트를 이용하는 방법으로 나뉜다. 각각 다음과 같이 표현한다:
 인접 행렬(adjacent matrix) 기반 그래프  정방 행렬을 활용
 인접 리스트(adjacent list) 기반 그래프   연결 리스트를 활용

-정방 행렬은 가로세로의 길이가 같은 행렬을 의미하는데, 이러한 행렬은 2차원 배열로 표현한다.

-인접 행렬 기반:
  무방향 그래프:
   -정점이 4개이면 가로세로의 길이가 4인 2차원 배열을 선언한다. 그리고 두 정점이 연결되어 있으면 1로, 연결되어 있지 않으면 0으로 표시한다.
   -간선에 방향성이 없기 때문에 하나의 간선에 대해서 두 개의 지점을 1로 표시해야 한다. [m][n] == [n][m] 때문에 행렬은 대각선을 기준으로 대칭을 이룬다.

  방향 그래프:
   -A에서 B로 향하는 간선의 표시를 위해서 [0][1]인 위치를 1로 표시하는 것이 전부다.

-인접 리스트 기반:
 무방향 그래프:
 -각각의 정점은 자신과 연결된 정보를 담기 위해서 하나의 연결 리스트를 갖는다. 그리고 각각의 정점에 연결된 간선의 정보는 각각의 연결 리스트에 담아야 한다.

 방향 그래프:
 -방향 그래프에서는 각 정점 별로 가리키는 정점의 정보만을 연결 리스트에 담는다. 때문에 무방향 그래프에 비해서 추가되는 노드의 수가 반으로 준다.

	14-2. 인접 리스트 기반의 그래프 구현

-그래프의 구현 관점에서 무방향 그래프와 방향 그래프의 유일한 차이점은 연결 리스트에 추가하는 노드의 수에 있기 때문에, 이 둘의 구현방법에는 차이가 없다고 볼 수 있다.

	14-3. 그래프의 탐색

-그래프의 탐색을 위한 알고리즘 두 가지:
 깊이 우선 탐색 Depth First Search(DFS)
 너비 우선 탐색 Breadth First Search(BFS)

-DFS의 핵심 세 가지를 비상연락망에 빗대어 정리하면 다음과 같다:
 -한 사람에게만 연락을 한다.
 -연락할 사람이 없으면, 자신에게 연락한 사람에게 이를 알린다.
 -처음 연락을 시작한 사람의 위치에서 연락은 끝이 난다.

-너비 우선 탐색 Breadth First Search(BFS):
 DFS가 한 사람에게 연락을 취하는 방식이라면, BFS는 자신에게 연결된 모든 사람에게 연락을 취하는 방식이다.

-BFS에서 말하는 '폭(너비)'의 의미를 풀어서 설명하면, 한 사람을 기준으로 메세지를 전달하는 사람의 수(폭)이다.

-BFS는 '폭'을 우선시하는(넓히는) 방식이다. 다시 말해서, 한 사람을 기준으로 자신에게 연결된 모든 사람에게 메세지를 전달하는 방식이다. 

-전 단계에서 두 사람에게 연락이 갔을 때, 누가 먼누구에게 연락을 취하느냐에 따라서 연락의 흐름에는 차이가 날 수 있지만, BFS 알고리즘의 관점에서 이는 문제가 되지 않는다.

-마지막 사람에게 연락 기회를 주지 않으면, 그 다음 사람이 있을 경우에는 문제가 생긴다.

-DFS의 구현을 위해서 필요한 것 두 가지:
 스택 - 경로 정보의 추적을 목적으로 한다.
 배열 - 방문 정보의 기록을 목적으로 한다.

-방문한 정점을 떠날 때에는 떠나는 정점의 정보를 스택에 쌓아야 한다.

-한 정정에 연결된 다른 정점들을 모두 지나쳐 왔다면 마지막으로 지나온 정점에 기회를 넘겨야 한다. 그에 대한 정보는 스택에서 찾을 수 있다.

-BFS의 구현을 위해서 필요한 것 두 가지는 다음과 같다:
 큐: 방문 차례의 기록을 목적으로 한다.
 배열: 방문 정보의 기록을 목적으로 한다.

-BFS에 있어서 큐는 연락을 취할 정점의 순서를 기록하기 위한 것이다.

-큐의 마지막 정점에도 연결 점이 없는지 꼭 살펴봐야 한다.

	14-4 최소 비용 신장 트리

-두 개의 정점을 잇는 간선을 순서대로 나열한 것을 가리켜 '경로'라 한다.

-동일한 간선을 중복하여 포함하지 않는 경로를 가리켜 '단순 경로(simple path)'라 한다.

-단순 경로이면서 시작과 끝이 같은 경로를 가리켜 '사이클(cycle)'이라 한다.

-사이클을 형성하지 않는 그래프들을 가리켜 '신장 트리(spanning tree)'라 한다.

-신장 트리의 두 가지 특징:
 -그래프의 모든 정점이 간선에 의해서 하나로 연결되어 있다.
 -그래프 내에서 사이클을 형성하지 않는다.

-신장 트리의 모둔 간선의 가중치 합이 최소인 그래프를 가리켜 '최소 비용 신장 트리(minimum cost spanning tree)'또는 '최소 신장 트리(minimum spanning tree)'라 한다.

-최소 비용 신장 트리의 구성에 사용되는 대표적인 알고리즘 두 가지:
 -크루스칼(Kruskal) 알고리즘:
  가중치를 기준으로 간선을 정렬한 후에 MST가 될 때까지 간선을 하나씩 선택 또는 삭제해 나가는 방식.
 -프림(Prim) 알고리즘
  하나의 정점을 시작으로 MST가 될 때까지 트리를 확장해 나가는 방식.

-MST는 다음의 특성을 지닌다:
 간선의 수 + 1 = 정점의 수

-크루스칼 알고리즘의 흐름:
 -가중치를 기준으로 간선을 오름차순으로 정렬한다.
 -낮은 가중치의 간선부터 시작해서 하나씩 그래프에 추가한다.
 -사이클을 형성하는 간선은 추가하지 않는다.
 -간선의 수가 정점의 수보다 하나 적을 때 MST는 완성된다.

 -가중치를 기준으로 간선을 내림차순으로 정렬한다.
 -높은 가중치의 간선부터 시작해서 하나씩 그래프에서 제거한다.
 -두 정점을 연결하는 다른 경로가 없을 경우 해당 간선은 제거하지 않는다.
 -간선의 수가 정점의 수보다 하나 적을 때 MST는 완성된다.

-크루스칼 알고리즘의 경우 간선을 내림차순으로 정렬하면 낮은 가중치의 간선을 하나씩 추가하는 방식이 아니라, 높은 가중치의 간선을 하나씩 빼는 방식으로 알고리즘이 전개된다. 두 정점이
 다른 경로를 통해서도 연결되어 있는 경우에만 해당 간선을 삭제할 수 있다.

-삭제한 경로를 복원할 경우 우선순위 큐에 넣지 않고 별도로 저장하게 되는데 그 이유는 우선순위 큐에 다시 넣으면 PDequeue 함수 호출 시 다시 꺼내게 되기 때문이다.