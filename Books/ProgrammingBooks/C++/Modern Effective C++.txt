-lvalues correspond to objects you can refer to

-if you can take its address > lvalue.

-The type of an expression is independent of whether the expression is an lvalue or an rvalue.

-Parameters > lvalues,; arguments > rvalues or lvalues.

-Declarations introduce names and types without giving details.

	CHAPTER 1 Deducing Types

	Item 1: Understand template type deduction.

-Type deduction for templates is the basis for auto.

-template<typename T>
 void f(ParamType param);
 A call can look like this:
  f(expr)
 During compilation, compilers use expr to deduce two types: one for T and one for ParamType.


-There are three cases:
  1.ParamType is a pointer or reference type, but not a universal reference. 
  2.ParamType is a universal reference.
  3.ParamType is neither a pointer nor a reference.

-Case 1: ParamType is a Reference or Pointer, but not a Universal Reference
   1. If expr’s type is a reference, ignore the reference part.
   2. Then pattern-match expr’s type against ParamType to determine T.

  -Type deduction works exactly the same way for rvalue reference parameters.

  -If param were a pointer > same

-Case 2: ParamType is a Universal Reference
  template<typename T>
  void f(T&& param);
  Such parameters are declared like rvalue references
  • If expr is an lvalue, both T and ParamType -> lvalue references.
    -it’s the only situation in template type deduction where T is deduced to be a reference. 
  • If expr is an rvalue, the “normal” (i.e., Case 1) rules apply.

-Case 3: ParamType is Neither a Pointer nor a Reference
  template<typename T>
  void f(T param);
  This means that param will be a copy of whatever is passed in
  1. if expr’s type is a reference, ignore the reference part.
  2. If, expr is const, ignore that, too. If it’s volatile, also ignore that.
  Just because expr can’t be modified doesn’t mean that a copy of it can’t be.
  When ptr is passed to f, the pointer itself (ptr) will be passed by value.
  The constness of what ptr points to is preserved, but the constness of ptr itself is ignored

-There is no function parameter that’s an array. 

-void myFunc(int param[]);
 The array declaration is treated as a pointer declaration.

-But functions can declare parameters that are references to arrays.

-References to arrays enables creation of a template that deduces the number of elements:
 template<typename T, std::size_t N> // see info
 constexpr std::size_t arraySize(T (&)[N]) noexcept
 { 
      return N;
 }

Things to Remember
• During template type deduction, arguments that are references are treated as non-references, i.e., their reference-ness is ignored.
• When deducing types for universal reference parameters, lvalue arguments get special treatment.
• When deducing types for by-value parameters, const and/or volatile arguments are treated as non-const and non-volatile.
• During template type deduction, arguments that are array or function names decay to pointers, unless they’re used to initialize references.

	Item 2: Understand auto type deduction.

-With only one exception, auto type deduction is template type deduction.

-auto plays the role of T in the template

-The one way they differ:
 auto x1 = 27;     // type is int, value is 27
 auto x2(27);       // ditto
 auto x3 = { 27 }; // type is std::initializer_list<int>,
                      // value is { 27 }
 auto x4{ 27 };    // ditto
 -When the initializer_list is used with auto, the deduced type is a std::initializer_list.
  -If such a type can’t be deduced (e.g., because the values in the braced initializer are of different types), the code will be rejected:
   auto x5 = { 1, 2, 3.0 }; // error! can't deduce T for
                               // std::initializer_list<T>
  -There are two kinds of type deduction taking place.
   -std::initializer_list is a template. std::initializer_list<T>. T’s type must also be deduced.
 -braced initializers is the only way in auto type deduction and template type deduction differ. 

-C++14 permits auto to indicate a function’s return type

-a function with an auto return type that returns a braced initializer won’t compile.

Things to Remember
• auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std::initializer_list, and 
 template type deduction doesn’t.
• auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.

	Item 3: Understand decltype

-In C++11, decltype is primarily used to declare the return type that depends on its parameter types. 

-template<typename Container, typename Index> // C++14; works,
 decltype(auto)                              // but still
 authAndAccess(Container& c, Index i) // requires
 {                                              // refinement
  authenticateUser();
  return c[i];
 }

-The use of decltype(auto) is not limited to function return types. // apply decltype duduction rule

-template<typename Container, typename Index> // final
 decltype(auto)                                            // C++14
 authAndAccess(Container&& c, Index i)             // version
 {                                                             // can pass rvalue
  authenticateUser();
  return std::forward<Container>(c)[i];
 }
 C++11 version of the template:
 template<typename Container, typename Index> // final
 auto                                                        // C++11
 authAndAccess(Container&& c, Index i)             // version
 -> decltype(std::forward<Container>(c)[i])
 {
  authenticateUser();
  return std::forward<Container>(c)[i];
 }

- int x = 0; decltype(x) is int. decltype((x)) is therefore int&. Putting parentheses around a name can change the type that decltype reports.

Things to Remember
• decltype almost always yields the type of a variable or expression without any modifications.
• For lvalue expressions of type T other than names, decltype always reports a type of T&.
• C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.

	Item 4: Know how to view deduced types.

-3 possibilities of viewing the type deduction results: as you edit your code, during compilation, and runtime.

-IDE Editors:
 -hover your cursor over the entity.
 -your code must be in a compilable state; cuz the compiler do the work
 -the more complicated types are involved, the less the info are helpful.

-Compiler Diagnostics:
 -Compilation problems. The error message mentions the type.

-Runtime Output:
 std::cout << typeid(x).name() << '\n';
 -This approach relies on the fact that invoking typeid on an object yields a std::type_info object.
 -std::type_info::name are not reliable. std::type_info::name are treated as if it had been passed to a template function as a by-value parameter.

-The type information from IDE editors is not reliable
 -const std::_Simple_types<...>::value_type *const &
  The “...” -> the IDE editor’s way of saying “I’m omitting all that stuff that’s part of T’s type.”

-The Boost TypeIndex library (often written as Boost.TypeIndex) is designed to succeed.

Things to Remember
• Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library.
• The results of some tools may be neither helpful nor accurate, so an understanding of C++’s type deduction rules remains essential.

	CHAPTER 2 auto

-Using auto saves typing, but it also prevents correctness and performance issues

-But falling back on manual type declarations is not recommendable.

	Item 5: Prefer auto to explicit type declarations.

-auto variables must be initialized -> easy solution uninitialized variable problems

-it can represent types known only to compilers

-Rarameters to lambda expressions may involve auto:
auto derefLess = // C++14 comparison
 [](const auto& p1, // function for
const auto& p2) // values pointed
 { return *p1 < *p2; }; // to by anything
 // pointer-like

-std::function objects can refer to any callable object

-Using std::function is not the same as using auto.

-Instantiation of the std::function template has a fixed size. if memory is not enough -> allocate heap memory -> uses more memory than the auto-declared object.

-cuz of restricting inlining and yielding indirect function calls std::function object is slower than calling it via an auto-declared object.

-Another advantage:
std::vector<int> v;
…
unsigned sz = v.size();
 -The official return type of v.size() is std::vector<int>::size_type.
 -On 64-bit Windows, unsigned is 32 bits, while std::vector<int>::size_type is 64 bits. -> incorrect behavior
 -Using auto ensures that you don’t have to:
auto sz = v.size(); // sz's type is std::vector<int>::size_type

-use auto -> no worry about mismatches between variable type and the initializing expression type.

-some refactorings are facilitated by using auto.

Things to Remember
• auto variables must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of
  refactoring, and typically require less typing than variables with explicitly specified types.
• auto-typed variables are subject to the pitfalls described in Items 2 and 6.

	Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types.

-operator[] for std::vector<bool> doesn’t return a bool. it returns an object of type std::vector<bool>::reference

-std::vector<bool> represents its bools in packed form, one bit per bool -> a problem for operator[] cuz C++ forbids references to bits.
 -> operator[] returns an object that acts like a bool&.

-std::vector<bool>::reference -> implicit conversion to bool. (Not to bool&, to bool.)

-proxy class: a class that exists for the purpose of emulating and augmenting the behavior of some other type.

-Some proxy classes are apparent to clients. Other proxy classes are invisible.

-“invisible” proxy classes don’t play well with auto.

-But how can you recognize when proxy objects are in use?:
 -document.
 -understand library design you're using
 -Payul attention to the interfaces you’re using

-solution for the proxy class type deduction-> explicitly typed initializer idiom:
 auto highPriority = static_cast<bool>(features(w)[5]);

-Applications of the idiom is useful to emphasize creating a variable of a type that is different from the initializing expression.

Things to Remember
• “Invisible” proxy types can cause auto to deduce the “wrong” type for an initializing expression.
• The explicitly typed initializer idiom forces auto to deduce the type you want it to have.

	CHAPTER 3 Moving to Modern C++

	Item 7: Distinguish between () and {} when creating objects.

-Initialization:
int x(0); // initializer is in parentheses
int y = 0; // initializer follows "="
int z{ 0 }; // initializer is in braces

-C++ usually treats equals-sign-plus-braces syntax the same as the braces-only version.

-Widget w1; // call default constructor
 Widget w2 = w1; // not an assignment; calls copy ctor
 w1 = w2; // an assignment; calls copy operator=

-The confusion of multiple initialization syntaxes -> uniform initialization:

-Braces can be used to specify default initialization values.

-Uncopyable objects may be initialized using braces or parentheses, but not using “=”.

-Only braces can be used everywhere.

-A novel feature of braced initialization: it prohibits implicit narrowing conversions among built-in types.

-Initialization using parentheses and “=” doesn’t check for narrowing conversions, because that could break too much legacy code.

-The most vexing parse: when developers want to default-construct an object, but end up declaring a function

-Widget w2(); // most vexing parse! declares a function
 -default-constructing an object using braces doesn’t have this problem:
  Widget w3{};

-The drawback to braced initialization: tangled relationship among braced initializers, std::initializer_lists, and constructor overload resolution.

-The more you like auto, the less enthusiastic you’re likely to be about braced initialization.

-If constructors declare a parameter of type std::initializer_list, calls using the braced initialization syntax strongly prefer std::initializer_lists.

-If compilers construe a call using a braced initializer to be a constructor taking a std::initializer_list, compilers will employ that interpretation.
 even though it is the worse match

-copy and move construction can be hijacked by std::initializer_list constructors.

-braced initializer를 생성자의 std::initializer_list로 변환 불가일 시 ->normal overload resolution.

-Widget w1; // calls default ctor
 Widget w2{}; // also calls default ctor
 Widget w3(); // most vexing parse! declares a function!
 Widget w4({}); // calls std::initializer_list ctor with empty list
 Widget w5{{}}; // ditto

-Two primary takeaways:
 -Client code using braced initialization may see only the std::initializer_list overloads. 
  Constructors shouldn't affected by whether clients use parentheses or braces.

 -add std::initializer_list overloads only with great deliberation.

 -The second lesson: as a class client, choose between parentheses and braces carefully for construction

 -Braces pros: broad applicability, narrowing conversions prevention, and the immunity to C++’s most vexing parse.

 -parentheses pros: consistency with the C++98 syntactic tradition, 
                         avoidance of the auto-deduced-a-std::initializer_list problem, 
                         prevent inadvertently called std::initializer_list constructor.

Things to Remember
• Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it’s immune to C++’s most vexing parse.
• During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.
• An example of where the choice between parentheses and braces can make a significant difference is creating a std::vector<numeric type> with two arguments.
• Choosing between parentheses and braces for object creation inside templates can be challenging.

	Item 8: Prefer nullptr to 0 and NULL.

-C++’s primary policy is that 0  is an int, not a pointer.

-The same is true of NULL.

-It’s that neither 0 nor NULL has a pointer type.

-Passing 0 or NULL to such overloads never called a pointer overload

-nullptr’s advantage: it doesn’t have an integral type. // it doesn’t have a pointer type, either, but you can think of it as a pointer of all types.

-nullptr’s actual type is std::nullptr_t. The type std::nullptr_t implicitly converts to all raw pointer types -> nullptr acts like pointer of all types.

-Using avoids overload resolution surprises 

-It can also improve code clarity, especially when auto variables are involved.

-std::nullptr_t implicitly converts to all pointer types.

-template type deduction deduces the “wrong” types for 0 and NULL -> reason to use nullptr to refer to a null pointer.

-When you want to refer to a null pointer, use nullptr, not 0 or NULL.

Things to Remember
• Prefer nullptr to 0 and NULL.
• Avoid overloading on integral and pointer types.

	Item 9: Prefer alias declarations to typedefs.

typedef
 std::unique_ptr<std::unordered_map<std::string, std::string>>
 UPtrMapSS;
-C++11 also offers alias declarations:
 using UPtrMapSS =
 std::unique_ptr<std::unordered_map<std::string, std::string>>;

-Many people find the alias declaration easier to swallow when dealing with types involving function pointers:
typedef void (*FP)(int, const std::string&); // typedef
using FP = void (*)(int, const std::string&); // alias

-Alias declarations may be templatized, while typedefs cannot.
template<typename T> // MyAllocList<T>
using MyAllocList = std::list<T, MyAlloc<T>>;
MyAllocList<Widget> lw;                        // client code

 -With a typedef:
template<typename T>
struct MyAllocList {
 typedef std::list<T, MyAlloc<T>> type;
};
MyAllocList<Widget>::type lw; // client code

-The names of dependent types must be preceded by typename.

-When compilers see MyAllocList<T>::type they can’t know for sure that it names a type, not as MyAllocList<T> 

-C++11 tools to perform these kinds of transformations: //<type_traits>
std::remove_const<T>::type // yields T from const T
std::remove_reference<T>::type // yields T from T& and T&&
std::add_lvalue_reference<T>::type // yields T& from T

-The aliases have a common form: for each std::transformation<T>::type, there’s a corresponding C++14 alias template named std::transformation_t:
std::remove_const<T>::type // C++11: const T → T
std::remove_const_t<T> // C++14 equivalent
std::remove_reference<T>::type // C++11: T&/T&& → T
std::remove_reference_t<T> // C++14 equivalent
std::add_lvalue_reference<T>::type // C++11: T → T&
std::add_lvalue_reference_t<T> // C++14 equivalent

Things to Remember
• typedefs don’t support templatization, but alias declarations do.
• Alias templates avoid the “::type” suffix and, in templates, the “typename” prefix often required to refer to typedefs.
• C++14 offers alias templates for all the C++11 type traits transformations. 

	Item 10: Prefer scoped enums to unscoped enums

-enum Color { black, white, red };
 auto white = false; // error! white already
                         // declared in this scope

-Their new C++11 counterparts, scoped enums, don’t leak names in this way:
enum class Color { black, white, red }; // black, white, red are scoped to Color
auto white = false; // fine, no other "white" in scope
Color c = white; // error! no enumerator named "white" is in this scope
Color c = Color::white; // fine
auto c = Color::white; // also fine

-Scoped enum advantages:
 -The reduction in namespace pollution
 -their enumerators are much more strongly typed

-Enumerators for unscoped enums implicitly convert to integral types.

-There are no implicit conversions from enumerators in a scoped enum to any other type

-If you want to perform a conversion from enum class to a different type, use a cast // static_cast<>

-every enum in C++ has an integral underlying type that is determined by compilers.

-Compilers want to choose the smallest underlying type that’s sufficient to represent its range of enumerator values.

-The inability to forward-declare enums has drawbacks:increase in compilation dependencies.
 -a new enum value -> the entire system has to be recompiled

-solution:
 enum class Status;                     // forward declaration
 void continueProcessing(Status s); // use of fwd-declared enum

-If compilers need to know the size of an enum: the scoped enum underlying type is always known; default is int
 enum class Status;                  // underlying type is int
 -you can override it:
  enum class Status: std::uint32_t;

-To specify the underlying type for an unscoped enum, do the same thing: // the result may be forward-declared
enum Color: std::uint8_t; // fwd decl for unscoped enum;

-Underlying type specifications can also go on an enum’s definition

-one situation where unscoped enums may be useful: referring to fields within C++11’s std::tuples.
 auto val = std::get<1>(uInfo); // you have a lot of stuff to keep track of.
 -Unscoped enum can avoid the inconvenience:
  enum UserInfoFields { uiName, uiEmail, uiReputation };
  UserInfo uInfo;
  auto val = std::get<uiEmail>(uInfo); 

Things to Remember
• C++98-style enums are now known as unscoped enums.
• Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.
• Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.
• Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.

	Item 11: Prefer deleted functions to private undefined ones.

-functions(copy constructor, the assignment operator, or both)

-The C++98 call prevention method: declare them private and not define them.

-In C++11, better way: use “= delete”

-By convention, deleted functions are declared public for better error messages.

-An important advantage of deleted functions: any function may be deleted, while only member functions may be private.

-deleted functions are considered during overload resolution.

-deleted functions can prevent use of template instantiations that should be disabled.

-Two special cases of pointers: 
 -void* pointers: There is no way to dereference them
 -char* pointers, they represent pointers to C-style strings, not pointers to individual characters.
 -These special cases often call for special handling.
 -if, it should not be possible to call processPointer with void* or char* pointers:
 template<>
 void processPointer<void>(void*) = delete;
 template<>
 void processPointer<char>(char*) = delete;
 template<>
 void processPointer<const void>(const void*) = delete;
 template<>
 void processPointer<const char>(const char*) = delete;

-You can’t give a member function template specialization a different access level from that of the main template.
 //means the undefined private method is impossible

-The problem is that template specializations must be written at namespace scope, not class scope. Solution is deleted function:
class Widget {
public:
 …
 template<typename T>
 void processPointer(T* ptr)
 { … }
 …
};
template<>                                                   // still
void Widget::processPointer<void>(void*) = delete; // public, but deleted

Things to Remember
• Prefer deleted functions to private undefined ones.
• Any function may be deleted, including non-member functions and template instantiations.

	Item 12: Declare overriding functions override.

-For overriding to occur, several requirements must be met:
• The base class function must be virtual.
• The base and derived function names, parameter types, constness must be identical
• The return types and exception specifications of the base and derived functions must be compatible.

-C++11 adds one more:
• The functions’ reference qualifiers must be identical.

-Reference qualifiers: // Member functions need not be virtual to use them
class Widget {
public:
 …
 void doWork() &; // only when *this is an lvalue
 void doWork() &&; // only when *this is an rvalue
};

-"override"(C++11) makes it explicit that a derived class function is overriding:
 virtual void mf1() override;

-The keywords(override and final) are reserved only in certain contexts.

-override has a reserved meaning only when it occurs at the end of a member function declaration.

-To write a function that accepts only lvalue arguments, declare a nonconst lvalue reference parameter:
void doSomething(Widget& w);
-To write a function that accepts only rvalue arguments, declare an rvalue reference parameter:
void doSomething(Widget&& w);

-Member function reference qualifiers simply make it possible to draw the same distinction for the object on which a member function is invoked, i.e., *this.

-Using reference qualifiers to overload data for lvalue and rvalue Widgets makes that possible:
class Widget {
public:
 using DataType = std::vector<double>;
 …
 DataType& data() & // for lvalue Widgets,
 { return values; } // return lvalue
 DataType data() && // for rvalue Widgets,
 { return std::move(values); } // return rvalue
 …
private:
 DataType values;
};
-Notice the differing return types from the data overloads.

Things to Remember
• Declare overriding functions override.
• Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*this) differently.

	Item 13: Prefer const_iterators to iterators.

-const_iterators -> equivalent of pointers-to-const.

-alias declarations are a feature new to C++11.

-In C++98, there was no simple way to get a const_iterator from a non-const container.

-In C++98, locations for insertions (and erasures) could be specified only by iterators. const_iterators weren’t acceptable.

-There’s no portable conversion from a const_iterator to an iterator, not even with a static_cast.

-const_iterators were rarely worth the bother in C++98.

-That changed in C++11. Now const_iterators are both easy to get and easy to use. // cbegin(), cend()

-The only situation in which C++11’s const_iterators are insufficient: writing maximally generic library code. 
 Such code considers that containers offer begin and end (plus cbegin, cend, rbegin, etc.) as non-member functions.

here’s an implementation of non-member cbegin:
template <class C>
auto cbegin(const C& container) -> decltype(std::begin(container))
{
 return std::begin(container); // see explanation below
}

Things to Remember
• Prefer const_iterators to iterators.
• In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.

	Item 14: Declare functions noexcept if they won’t emit exceptions.

-Failure to declare a function noexcept is simply a poor interface specification.

-An additional incentive to apply noexcept to functions: better object code.

-The two ways of expressing no-exception:
int f(int x) throw(); // no exceptions from f: C++98 style
int f(int x) noexcept; // no exceptions from f: C++11 style

-C++98 exception specification: the call stack unwinding -> not relevant some actions -> program terminated. 

-C++11 exception specification: the stack is only possibly unwound before program execution is terminated.

-In a noexcept function, optimizers need not keep the runtime stack in an unwindable state if an exception would propagate out of the function. 

-Optimizers don't need to ensure that noexcept functions are destroyed in the inverse order of construction.
RetType function(params) noexcept; // most optimizable
RetType function(params) throw(); // less optimizable
RetType function(params); // less optimizable

-In C++11, a natural optimization replaces the copying of std::vector elements with moves -> the risk of violating exception safety guarantee.

-Legacy code could depend on push_back’s strong exception safety guarantee. 

-The silent change from copy to move are allowed only when the move operations won’t emit exceptions.

-Some standard library functions take advantage of this “move if you can, but copy if you must”.

-Declaring function noexcept ensures the operation won't emit exception

-Whether swaps in the Standard Library are noexcept is sometimes dependent on whether user defined swaps are noexcept:

template <class T, size_t N>
void swap(T (&a)[N],  T (&b)[N]) noexcept(noexcept(swap(*a, *b))); // below

template <class T1, class T2>
struct pair {
 void swap(pair& p) noexcept(noexcept(swap(first, p.first)) && noexcept(swap(second, p.second)));
};

-Changing the result of declaring a function noexcept later is hard to chieve.

-Most functions are exception-neutral: Such functions throw no exceptions, but functions they call might. 

-The exception-neutral function allows the emitted exception to pass through on its way to a handler. 

-Exception-neutral functions are never noexcept -> Most functions properly lack the noexcept designation.

-When you can say that a function should never emit exceptions, you should definitely declare it noexcept.

-In C++98, permitting the memory deallocation functions and destructors to emit exceptions was a bad style.

-in C++11, By default, all memory deallocation functions and all destructors are implicitly noexcept.

-A destructor is not noexcept when a data member type states its destructor may emit exceptions (e.g., declares it “noexcept(false)”).

-A function with a wide contract: No preconditions, no program state condition, no constraints on the arguments, never exhibit undefined behavior

-Functions with narrow contracts: if a precondition is violated, results are undefined.

-Compilers typically offer no help in identifying inconsistencies between function implementations and their exception specifications:
 ex. no warning when a noexcept function calls functions that lacking the noexception gurantee

Things to Remember
• noexcept is part of a function’s interface, and that means that callers may depend on it.
• noexcept functions are more optimizable than non-noexcept functions.
• noexcept is particularly valuable for the move operations, swap, memory deallocation functions, and destructors.
• Most functions are exception-neutral rather than noexcept.

	Item 15: Use constexpr whenever possible.

-constexpr value : constant and known during compilation.

-Don't assume the results of constexpr functions are const, nor their values are known during compilation.

-constexpr objects are const and have values that are known at compile time(Technically, their values are determined during translation)
 -translation consists  of compilation and linking

-Values known during compilation are privileged. They may be placed in read-only memory.

-integral constexpr values can be used in contexts where C++ requires an integral constant expression.

-Note that const doesn’t offer the same guarantee as constexpr, because const objects need not be initialized with values known during compilation.

-All constexpr objects are const, but not all const objects are constexpr.

-constexpr functions produce compile-time constants when they are called with compile-time constants.

-If any of the constexpr function arguments’ values is not known during compilation, your code will be rejected.

-constexpr function acts like a normal function when any of the arguments are not constexpr -> computing during runtime.
 ->don’t need two functions to perform the same operation

-In C++11, constexpr functions may contain just a return statement. 
 -“?:” operator can substitute if-else statements
 -recursion can substitute loops.

-In C++14, the restrictions got loose

-constexpr functions are limited to taking and returning literal types -> types that can have values determined during compilation.

-user-defined types may be literal because constructors and other member functions may be constexpr.

-getters can be constexpr if an object with a value known during compilation invokes them

-more code taking part in the migration -> faster (but compilation time increases)

-In C++11, two restrictions for having constexpr setters:
 -In C++11, constexpr member functions are implicitly const.
 -They have void return types. not literal

-C++14, even Point’s setters can be constexpr.

-Use constexpr whenever possible. reason: 
 -both constexpr objects and constexpr functions can be employed in wider contexts

Things to Remember
• constexpr objects are const and are initialized with values known during compilation.
• constexpr functions can produce compile-time results when called with arguments whose values are known during compilation.
• constexpr objects and functions may be used in a wider range of contexts than non-constexpr objects and functions.
• constexpr is part of an object’s or function’s interface.

	Item 16: Make const member functions thread safe.

-const functions that use mutable data memebers are not thread safe.

-The easiest way: employ a mutex // mutable std::mutex m; std::lock_guard<std::mutex> g(m);

-The mutex member should be mutable cuz locking and unlocking it are non-const member functions, and a const member function would consider m a const object

-std::mutex is a move-only type.

-adding std::mutex data memeber -> lose the ability to be copied.

-std::atomic would often be less expensive(depends on the hardware and implementation) than mutex
 //mutable std::atomic<unsigned> callCount{ 0 };

-std::atomics are move-only types either

-A single variable and memory location requiring synchronization -> atomic
 two or more -> mutex

Things to Remember
• Make const member functions thread safe unless you’re certain they’ll never be used in a concurrent context.
• Use of std::atomic variables may offer better performance than a mutex, but they’re suited for manipulation of only a single variable or memory location.

	Item 17: Understand special member function generation.

-A default constructor is generated only if the class declares no constructors.

-Auto generated special member: implicitly public, inline, and nonvirtual unless inherited from virtual destructor base class

-C++11 also auto-generates: move constructor, move assignment operator

-there is no guarantee for move execution -> types that aren’t move-enabled will be “moved” via copy operations.

-The heart of each memberwise move application: std::move ->determine whether a move or a copy

-The two copy operations are independent -> 하나 정의해도 다른 쪽 컴파일러 자동 생성 제공

-The two move operations are not independent. -> 하나 정의하면 컴파일러 자동 생성 x
 // 한쪽 move가 잘못되면 다른 쪽 move도 틀릴테니까

-copy operation 명시적 선언시 move operation 자동 생성 x
 -copy operation 재정의는 default copy opration이 부적절하다 암시하기에 default move operation도 부적절할거라 판단

-똑같이 move operation 명시적 선언시 copy operation 자동 생성 x

-no move sementic in C++98

-Rule of Three:
  -if you declare any of a copy constructor, copy assignment operator, or destructor, you should declare all three.
  -copy operation 재정의는 주로 리소스 관리에 필요
  -두 copy operaion은 서로 호출할 경우가 많고, destructor에서는 해제

-cuz of the rule of three, 소멸자 정의시 copy operation 자동 생성 막아야함
-But, In C++98, existence of user-defined destructor has no impact to generate copy operations.
-C++11 same but to prevent legacy code break.
 -> move operation는 user-declared destructor 존재 시 생성 x

-3 conditions for auto-generated move operations:
• No copy operations are declared in the class.
• No move operations are declared in the class.
• No destructor is declared in the class.

-declaring C++11’s “= default” can eliminate dependency

-소멸자를 =default로 선언 시 move sementic 적용 가능.

-using “= default” makes your intentions clearer and prevents subtle bugs

-추후에 소멸자 추가 ->  move 자동생성 x > 대신 copy로 작동 > 성능 저하
 // =default로 선언 시 해결

-The rules for constructor and destructors in C++11 and C++98 nearly same:
 -destructors are noexcept by default in C++11

Things to Remember
• The special member functions are those compilers may generate on their own:
default constructor, destructor, copy operations, and move operations.
• Move operations are generated only for classes lacking explicitly declared move operations, copy operations, and a destructor
• The copy constructor is generated only for classes lacking an explicitly declared copy constructor, and it’s deleted if a move operation is declared.
  The copy assignment operator is generated only for classes lacking an explicitly declared copy assignment operator, and it’s deleted if a move operation is
  declared. Generation of the copy operations in classes with an explicitly declared destructor is deprecated.
• Member function templates never suppress generation of special member functions.

	Chapter 4. Smart Pointers

-Cons of raw pointer:
 -doesn't indicate whether it is a single or an array
 -doesn't indicate when to delete it
 -cannot customize how to delete
 -doesn't indicate whether delete or delete[]
 -hard to ensure delete just once
 -no way to inform dangling pointers

-Smart pointers: wrappers around raw pointers that acts like raw pointers

-Prefer Smart pointers to raw pointers

-std::auto_ptr, std::unique_ptr, std::shared_ptr, and std::weak_ptr.

-바른 작동은 move sementics 필요 -> C++98은 move sementics x -> auto_ptr은 copy로 대신 -> 이상한 작동

-use unique_ptr instead of auto_ptr

	Item 18: Use std::unique_ptr for exclusive-ownership resource management.

-if a raw pointer is small enough and fast enough -> std::unique_ptr the same

-Moving a std::unique_ptr transfers ownership

-std::unique_ptr is a move-only type.

-A common use of std::unique_ptr is as a factory function return type

-std::unique_ptr can use custom deleters.
 // std::unique_ptr<Investment, decltype(delInvmt)>

-A custom deleter type must be specified as the second type argument to std::unique_ptr

-Assign a raw pointer to a std::unique_ptr won't compile.

-std::unique_ptr size == raw pointer size라고 합리적 추리 가능

-함수 포인터나 함수 객체를 custom deleter로 쓰면 std::unique_ptr 사이즈 증가.
 // 포인터 크기 만큼, 객체 크기 만큼

-Stateless function objects 사용시 크기 증가 패널티 x -> 선호

-std::unique_ptr는 pimpl idiom에서도 유용

-std::unique_ptr comes in two forms:
 std::unique_ptr<T>, 

-std::unique_ptr<T[]>보다 std::array, vector, string이 대부분 우월

Things to Remember
• std::unique_ptr is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.
• By default, resource destruction takes place via delete, but custom deleters can be specified. Stateful deleters and function pointers as deleters increase the
  size of std::unique_ptr objects.
• Converting a std::unique_ptr to a std::shared_ptr is easy.

	Item 19: Use std::shared_ptr for shared-ownership resource management

-In shared_ptr copy assignment operator, both increment and decrement of the reference count occur.

-The existence of the reference count has performance implications:
 • std::shared_ptrs == raw pointer size * 2; cuz of a raw pointer to the resource and reference count
 • Memory for the reference count must be dynamically allocated.
 • Increments and decrements of the reference count must be atomic

-이동 생성 시 reference count 증가 x -> no reference count manipulation -> moving is faster than copying

-std::unique_ptr과 다르게 std::shared_ptr은 custom delete 지정 시 템플릿 매개 변수로 전달 x
 // std::shared_ptr<Widget> pw1(new Widget, customDeleter1);

-또한 custom deleter 지정이 size 변화 x. how?
 -> reference count, weak count 등 shared_ptr 필요 정보를 담는 control block 데이터 구조의 포인터를 포함

-첫 shared_ptr가 set up control block

-그러나 특정 object에 대한 shared_ptr가 있는지 알 수 없음 -> rules for control block creation:
 • std::make_shared always creates a control block
 • when a std::shared_ptr is constructed from a unique-ownership pointer
 • When a std::shared_ptr constructor is called with a raw pointer

-std::shared_ptr constructors taking std::shared_ptrs or std::weak_ptrs don’t create new control blocks

-more than one std::shared_ptr -> multiple control blocks -> multiple reference count -> multiple object destroy -> undefined behavior

-Two lessons:
 -avoid passing raw pointers to a std::shared_ptr constructor. std::make_shared is usual alternative.
 -if you must pass a raw pointer, pass the result of new directly

-std::shared_ptr<Widget> spw2(spw1); // spw2 uses same control block as spw1

-std::vector<std::shared_ptr<Widget>> processedWidgets;
 processedWidgets.emplace_back(this); // wrong
 
-For the solution:
 std::enable_shared_from_this. // a template for a base class
 class Widget: public std::enable_shared_from_this<Widget> {}

-std::enable_shared_from_this는 control block 없이 현 객체의 std::shared_ptr를 생성하는 메서드 정의. // shared_from_this()
 // processedWidgets.emplace_back(shared_from_this());

-shared_from_this()는 현재 객체의 control block 참조 -> std::shared_ptr가 미리 존재해야함 -> 없으면 undefined behavior

-위를 막기 위해 private 생성자를 호출하여 std::shared_ptr를 반환하는 팩토리 함수 사용.
 template<typename... Ts>
 static std::shared_ptr<Widget> create(Ts&&... params);

-using std::shared_ptrs incurs virtual function cost either(used by the control block).

-but the cost is reasonable

-Dereferencing costs of a raw pointer and std::shared_point are not diff

-The virtual function machinery in the control block -> when the object is destroyed

-shared ownership 필수일 때만 shared_ptr 나머진 unique_ptr

-shared_ptr -> unique_ptr 쉬움. 반대는 불가.

-There’s no std::shared_ptr<T[]>

Things to Remember
• std::shared_ptrs offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.
• Compared to std::unique_ptr, std::shared_ptr objects are typically twice as big, incur overhead for control blocks, and require atomic reference count manipulations.
• Default resource destruction is via delete, but custom deleters are supported. The type of the deleter has no effect on the type of the std::shared_ptr.
• Avoid creating std::shared_ptrs from variables of raw pointer type

	Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle

-std::weak_ptr를 통해 std::shared_ptr dangling 문제 해결 가능

-std::weak_ptr can't be dereferenced, nor can they be tested for nullness.

-std::weak_ptrs are typically created from std::shared_ptrs.
 // std::weak_ptr<Widget> wpw(spw);

-std::weak_ptrs that dangle are said to have expired.
 if (wpw.expired()) // checks dangling

-There is no way to dereference std::weak_ptr

-2 ways to create std::shared_ptr from std::weak_ptr:
 -std::weak_ptr::lock() // returns std::shared_ptr. if expired, null
 -use std::shared_ptr constructor that takes std::weak_ptr. throw exception when std::weak_ptr is expired

-std::weak_ptrs can detect dangling only when an object’s lifetime is managed by std::shared_ptrs

- a child node should never have a lifetime longer than its parent.

-From an efficiency perspective, the std::weak_ptr == for std::shared_ptr

Things to Remember
• Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.
• Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles

	Item 21: Prefer std::make_unique and std::make_shared to direct use of new.

-make_shared(): C++11
 make_unique(): C++14

-make functions reduce code duplication

-make functions prevent memory leak when:
 processWidget(std::shared_ptr<Widget>(new Widget), computePriority());

-The arguments for a function must be evaluated before the function can be invoked

-std::make_shared improves efficiency: just one allocation for both control block and memory -> one allocation call
                                                obviates some bookkeeping information in the control block

-But none of the make functions permit the specification of custom deleters 

-Also within the make functions, the perfect forwarding code uses parentheses constructors, not braces.

-You must use new to construct with a braced initializer

-make functions require prefector forwarding ability, but initialize_list can't be perfect-forwarded

-workaround: using auto
auto initList = { 10, 20 };
auto spv = std::make_shared<std::vector<int>>(initList); // create std::vector using std::initializer_list ctor

-make_shared is problematic in few more cases:
 -new를 재정의 한 경우. 정해진 크기의 메모리를 할당하게 되는데 control block size 때문에 맞지 않게됨
 -make_shared의 size, speed 이점은 control block이 memory와 같은 덩어리에 있다는 곳에서 기인 > 
  control_block 해제 x -> memory도 해제 안됨 >
  control_block은 weak_count reference(weak_ptr의 control_block 참조 개수)도 가짐 >
  weak_ptr 개수가 > 0 이면 control_block도 해제 안됨 >
  std::shared_ptr, std::weak_ptr 모두 소멸할 때까지 shared_ptr 해제 안됨

Things to Remember
• Compared to direct use of new, make functions eliminate source code duplication, improve exception safety, and, for std::make_shared and std::allocate_shared, generate code 
  that’s smaller and faster.
• Situations where use of make functions is inappropriate include the need to specify custom deleters and a desire to pass braced initializers.
• For std::shared_ptrs, additional situations where make functions may be ill-advised include (1) classes with custom memory management and (2) sys‐
  tems with memory concerns, very large objects, and std::weak_ptrs that outlive the corresponding std::shared_ptrs.

	Item 22: When using the Pimpl Idiom, define special member functions in the implementation file.

-Part 1 of the Pimpl Idiom: the declaration of a data member that’s a pointer to an incomplete type.
 Part 2: the dynamic allocation and deallocation of the object that holds the data members that used to be in the original class.

-#include "widget.h"
  Widget w; // error! // Widget is pimpl class that holds std::unique_ptr
 -why:
  -std::unique_ptr의 디폴트 deleter가 호출되기 전 static_assert로 raw pointer가 incomplete타입이 아닌지 검사
   -> 그런데 compiler-generated destructor는 implicitly inline
 -solution:
  -Declare Widget’s destructor in widget.h, but don’t define it there or Widget::~Widget() = default; 

-Pimpl Idiom are natural candidates for move support
 -> 위 문제 해결을 위해 destructor 정의 시 컴파일러는 move operations 생성 x
 -> 직접 정의나 명시적 디폴트
 -> move operations 명시적 디폴트 시 reassignment 과정 중 소멸자 호출 필요(주로 예외 발생)로 같은 문제 발생
 -solution:
  -move the definition(or default specification) of the move operations into the implementation file

-pimp idiom 활용 시 copy operations이 필요할 수 있다.
 -허나 컴파일러는 move-only type에 copy operation 자동 생성 x
 -제공해도 shallow copy

-pimpl idiom에는 exclusive ownership이 적용되므로 std::unique_ptr이 적절.

-The advice of this item can't be applied to std::shared_ptr.
-The difference stems from the way each smart pointer supports custom deleter:
 -For std::unique_ptr, the type of the deleter is part of the type of the smart pointer -> greater efficiency, types must be complete
 -For std::shared_ptr, the type of the deleter is not part of the type of the smart pointer.

Things to Remember
• The Pimpl Idiom decreases build times by reducing compilation dependencies between class clients and class implementations.
• For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file. Do this even
  if the default function implementations are acceptable.
• The above advice applies to std::unique_ptr, but not to std::shared_ptr.

	CHAPTER 5. Rvalue References, Move Semantics, and Perfect Forwarding

-Move semantics makes it possible for compilers to replace expensive copying operations with less expensive moves.

-Perfect forwarding makes it possible to write function templates that take arbitrary arguments and forward them to other functions such that the target func
 tions receive exactly the same arguments as were passed to the forwarding functions

	Item 23: Understand std::move and std::forward.

-std::move doesn’t move anything. std::forward doesn’t forward anything.

-std::move and std::forward are merely cast functions

-std::move unconditionally casts its argument to an rvalue
template<typename T> // C++14;
decltype(auto) move(T&& param)
{
 using ReturnType = remove_reference_t<T>&&;
 return static_cast<ReturnType>(param);
}

-explicit Annotation(const std::string text) : value(std::move(text)) { } // copy not move
                                                                                     // const rvalue cannot be moved

-Two lessons:
 -Don’t declare objects const to move
 -std::move not only doesn’t move, it doesn’t guarantee that the object it’s casting will be eligible to be moved.
 -The only thing you know for sure about the result of std::move: an object is a rvalue.

-std::forward와 std::move는 유사하나 std::forward는 conditional cast.

-템플릿에서 호출하는 함수가 rvalue와 lvalue 버전을 오버로딩 돼있을 때 매개변수 따라 선택하는 메커니즘 필요 -> std::forward

-std::forward: it casts to an rvalue only if its argument was initialized with an rvalue.

-The type we pass to std::forward should be a non-reference.

Things to Remember
• std::move performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything.
• std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.
• Neither std::move nor std::forward do anything at runtime.

	Item 24: Distinguish universal references from rvalue references.

-Two meanings of 'T&&': rvalue, universal reference

-Universal references arise in two contexts: function template parameter, auto declarations
 // auto&& var2 = var1; // var2 is a universal reference
 -The sharing feature is type deduction
 -lvalue -> lvalue reference, rvalue -> rvalue reference

-For universal reference, the form is quite constrained; “T&&”
template<typename T>
void f(std::vector<T>&& param); // param is an rvalue reference
 -even const qualifier disqualifies a reference from being universal

-"T&&"형태라도 type duduction이 발생하는게 아니면 rvalue reference 처리.
 // ex. vector의 push_back(). vector를 인스턴스화 하는 타입을 그대로 쓰기 때문.

-The key is type deduction and the form

Things to Remember
• If a function template parameter has type T&& for a deduced type T, or if anobject is declared using auto&&, the parameter or object is a universal reference.
• If the form of the type declaration isn’t precisely type&&, or if type deduction does not occur, type&& denotes an rvalue reference.
• Universal references correspond to rvalue references if they’re initialized with rvalues. They correspond to lvalue references if they’re initialized with lvalues.

	Item 25: Use std::move on rvalue references, std::forward on universal references

-Rvalue references bind only to objects that are candidates for moving. 

-take advantage of the object’s rvalueness
 // Widget(Widget&& rhs) : name(std::move(rhs.name)), p(std::move(rhs.p)) { … }

-A universal reference might be bound to an object that’s eligible for moving.

-rvalue references should be unconditionally cast to rvalues (via std::move)
-universal references should be conditionally cast to rvalues (via std::forward)

-avoid using std::forward with rvalue references // wordy, error-prone, unidiomatic

-using std::move with universal reference is the worst idea. // unexpectedly changed lvalue

-universal reference로 매개변수를 perfect forwarding하는 것이 lvalue, rvalue 오버로딩 버전을 각각 두는 것보다 효율적:
 -no temporary object
 -shorter code
 -poor design // 매개변수가 많아진다면? 매개변수 개수에 제한이 없다면?

-when you return by value, using std::move in the return statement yields more efficient code.
Matrix operator+(Matrix&& lhs, const Matrix& rhs)
{
 lhs += rhs;
 return std::move(lhs);
}

-The same logic can be applied to std::forward()

-local variable을 return by value하는 copy overhead는 함수 리턴 값을 위해 할당된 메모리에 construct 함으로써 회피 가능: RVO(Return Value Optimization)

-RVO conditions:
 -The type of the local variable == return type
 -The local object is what being returned

-웬만한 컴파일러는 RVO 적용

-최적화를 위해 local variable 리턴 시 std::move 적용은 오히려 손해. 두 번째 조건이 어긋나며 RVO 실행 x
-RVO 실행 조건을 충족하지만 컴파일러가 실행하지 않아도 자동으로 rvalue reference로 리턴.

-function parameter return-by-value도 유사. 리턴시 컴파일러가 rvalue reference로 자동 전환.

Things to Remember
• Apply std::move to rvalue references and std::forward to universal references the last time each is used.
• Do the same thing for rvalue references and universal references being returned from functions that return by value.
• Never apply std::move or std::forward to local objects if they would otherwise be eligible for the return value optimization.

	Item 26: Avoid overloading on universal references.

-universal reference overload는 많은 argument type들을 가려버린다. // e.g. promotion으로 적법하게 호출될 수 있는 함수
 -perfect forwarding constructor에서 두드러지는 문제.
 -이동, 복제 생성자가 자동 생성 되고 non-const lvalue로 복제 생성하려 해도 templatized constructor에서 non-const lvalue instance가 생성될 수 있기에 그쪽이 호출됨.

Things to Remember
• Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.
• Perfect-forwarding constructors are especially problematic, because they’re typically better matches than copy constructors for non-const lvalues, and
  they can hijack derived class calls to base class copy and move constructors.

	Item 27:Familiarize yourself with alternatives to overloading on universal references.

-Abandon overloading: no use

-Pass by const T&: 디자인 비효율적.

-Pass by value: value로 오버로딩

-Use Tag dispatch:
 -의도가 perfect forwarding이라면 universal reference는 필수

 -포워딩 받는 함수에 태그 역할의 매개 변수 추가 후 포워딩 하는 함수에서 태그 지정하여 호출
template<typename T>
void logAndAdd(T&& name)
{
 logAndAddImpl(std::forward<T>(name),
 std::is_integral<typename std::remove_reference<T>::type>()
}

template<typename T>
void logAndAddImpl(T&& name, std::false_type // or std::true_type)
{...}

-Constraining templates that take universal references:

 -Use it when universal reference is greedy, yet not greedy enough to act as a single dispatch function

 -universal reference에 의해 special function들이 가려지는 문제는 enable_if로 해결 // 매개변수 타입이 같은 클래스 타입이 아닐때만 template 인스턴스화 되도록.
 class Person {
 public:
 template<typename T, typename = typename std::enable_if<!std::is_base_of<Person, typename std::decay<T>::type>::value>::type
 && !std::is_integral<std::remove_reference_t<T>>::value>
 explicit Person(T&& n);
 }

 -std::decay<T> type traits는 const, volatile, reference 타입 제거.

 -is_base_of로 derived class에서도 맞게 작동.

 -enable_if_t 등을 사용하면 ::type 제거 가능

-Trade-offs:
 -some types can't be perfect-forwarded
 -low comprehensibility of the error message // 맞지 않는 타입의 매개변수가 전달 됐을 때 이해 불가 에러 메세지
  -static_assert와 std::is_constructible<T>활용.

Things to Remember
• Alternatives to the combination of universal references and overloading include the use of distinct function names, passing parameters by lvalue reference-to-const, 
  passing parameters by value, and using tag dispatch.
• Constraining templates via std::enable_if permits the use of universal references and overloading together, but it controls the conditions under which
  compilers may use the universal reference overloads.
• Universal reference parameters often have efficiency advantages, but they typically have usability disadvantages.

	Item 28: Understand reference collapsing.

-universal reference에 lvalue -> lvalue reference
                            rvalue -> non-reference

-reference to reference는 허용되지 않지만 경우에 따라서 컴파일러가 생성. universal reference의 경우.

-universal reference에 lvalue면 void func(Widget& && param); 같은 reference to reference 인스턴스가 발생 -> reference collapsing

-reference는 두 가지, 총 네 가지 reference to refernce: l to l, l to r, r to l, r to r

-reference collapsing rule: if either reference is lvalue -> lvalue reference else rvalue reference

-reference collapsing is the key of std::forward

-template<typename T>
 T&& forward(typename
 remove_reference<T>::type& param)
{
 return static_cast<T&&>(param);
}

-4 contexts of reference collapsing:
 -template instantiation
 -auto type generation
 -use and declaration of type defs and alias // typedef T&& RavlueRefToT;
 -decltype

-universal reference is, in fact, rvalue reference in two conditions:
 -Type deduction distinguishes lvalues from rvalues.
 -Reference collapsing occurs.

Things to Remember
• Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.
• When compilers generate a reference to a reference in a reference collapsing context, the result becomes a single reference. If either of the original refer‐
  ences is an lvalue reference, the result is an lvalue reference. Otherwise it’s an rvalue reference.
• Universal references are rvalue references in contexts where type deduction distinguishes lvalues from rvalues and where reference collapsing occurs.

	Item 29: Assume that move operations are not present, not cheap, and not used.

-move sementic은 compiler에 강제되는것이 아니라 require된다.

-C++11 식으로 수정된 것이 아니면 C++98코드에서 move sementics 이점을 보기 힘들다. move operations가 명시적 선언이 아니거나 자동 생성되지 않기에.

-explict move support된다 해도 항상 빠른건 아니다. STL container를 옮기는 예에서 원소를 빠르게 옮기는 방법이 없거나, 되도 조건이 만족돼야 되는 경우가 있다.

-contexts which C++11 move sementics do no good:
 -No move operations
 -Move not faster  // 힙 할당 x 버퍼 e.g. SSO(Small String Optimization)
 -Move not usable // no exception move operation이 필요한데 noexcept 선언이 안됐을 때

Things to Remember
• Assume that move operations are not present, not cheap, and not used. // template의 경우 무슨 타입이 될지 알 수 없다.
• In code with known types or support for move semantics, there is no need for assumptions.

	Item 30:Familiarize yourself with perfect forwarding failure cases.

-Forwarding: one function passes-forward-its parameters to another function.

-Perfect forwarding: we also forward the salient characteristics such as types, cv, lvalue or rvalue

-perfect forwarding fails if calling f with a particular argument does one thing, but calling fwd with the same argument does something different

-Braced initializers:

 -포워딩 템플릿 함수에선 매개변수 타입을 변환이 아닌 추론한다.

 -Perfect forwarding fails when:
  -Compilers are unable to deduce a type
  -Compilers deduce the "wrong" type // f와 fwd의 동작이 다를 때도 포함

 -passing a braced initializer to a function template parameter that’s not declared to be a std::initializer_list is decreed to be, as the Standard puts it, a “non-deduced context.”
  // 하지만 auto로 변수 타입 추론후 전달은 가능.

-0 or NULL as null pointers:

 -Neither 0 or NULL can be forwarded as a null pointer. // use nullptr

-Declaration-only integral static const data members:

 -perfect-forward는 참조로 인자를 받고 참조는 역참조 자동화 포인터랑 유사 >
  Declaration-only integral static const data members는 정의가 되지 않아서 주소가 없음 > 
  컴파일러에 따라 포워딩 가능 여부 갈림 >
  portability 하락 > 
  Declaration-only integral static const data members 정의로 해결

-Overloaded function names and template names:

 -오버로드 및 템플릿 함수들은 포워딩 시 타입 특정 불가
  > 명시적으로 오버로드 버전 및 인스턴스 지정.

-Bitfields:

 -C++ standard condemns: "A non-const reference shall not be bound to a bitfield." cuz there is no way to directly address arbitrary parts of machine words

 -하드웨어 측면에서 포인터와 레퍼런스는 같다.

 -The smallest thing you can point to is a char -> no way to create a reference to bit.

 -bitfield가 값으로 전달될 수 있는 유일한 매개변수 타입: reference-to-const

 -Standard integral type에 copy된 bitfield를 포워딩 하는 방식으로 해결:
  auto length = static_cast<std::uint16_t>(h.totalLength);
  fwd(length);

Things to Remember
• Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.
• The kinds of arguments that lead to perfect forwarding failure are braced initializers, null pointers expressed as 0 or NULL, declaration-only integral const
  static data members, template and overloaded function names, and bitfields.

	CHAPTER.6 Lambda Expressions

-Lambda expression is a convenient way to create a function object.

-A lambda expression is just an expression
-A closure is the runtime object created by a lambda. Depending on the capture mode, closures hold copies of or references to the captured data.
-A closure class is a class from which a closure is instantiated.

-It’s possible to have multiple closures of a closure type corresponding to a single lambda.

	Item 31: Avoid default capture modes.

-by-reference capature의 수명이 local variable보다 길다면 dangling 발생.

-by-value capture는 어느 정도 면역이 있지만 pointer를 capture 했을 때 lambda 밖에서 그 포인터가 delete되는 것을 막을 수 없어 dangling 발생 가능.

-Captures apply only to non-static local variables visible in the scope where the lambda is created.

-method에서 capture를 사용해 lambda를 처리할 경우 this 포인터가 같이 capture되면서 dangling의 위험 증가.

-data member의 local copy를 만들고 그것을 capture 함으로써 해결 가능.

-In C++14, generalized lambda capture is a better option: [divisor = divisor] (int value) { return value % divisor == 0; }

-default by-value capture는 static storage duration을 가진 객체를 캡쳐 시 reference로 캡쳐 하기에 외부 수정에 안전하지 않다.

Things to Remember
• Default by-reference capture can lead to dangling references.
• Default by-value capture is susceptible to dangling pointers (especially this), and it misleadingly suggests that lambdas are self-contained.

	Item 32: Use init capture to move objects into closures.

-copy capture가 아닌 move capture는 C++11에서 제공x -> init capture 추가.

-init capture로 closure에서의 data member name과 초기화 표현식 명시 가능.

-auto func = [pw = std::move(pw)] { return pw->isValidated() && pw->isArchived(); };

-[pw = std::move(pw)]에서 =의 좌측은 closure scope, 우측은 람다가 정의된 scope

-lambda body code는 closure scope

-In C++11, to emulate init capture:
 auto func = std::bind([](const std::vector<double>& data) { /* uses of data */ }, std::move(data));

-By default, the operator() member function inside the closure class generated from a lambda is const.

-If the lambda were delcared mutable, operator() in its closure would not be declared const:
 auto func = std::bind([](std::vector<double>& data) mutable { /* uses of data */ }, std::move(data));

-A bind object stores copies of all the arguments passed to std::bind. The lifetime of the closure == the lifetime of the bind object

Things to Remember
• Use C++14’s init capture to move objects into closures.
• In C++11, emulate init capture via hand-written classes or std::bind.

	Item 33: Use decltype on auto&& parameters to std::forward them.

-generic lambdas: lambdas that use auto in their parameter specifications

-generic lambda's operator() in the lambda’s closure class is a template.

-std::forward에 rvalue든 rvlaue reference든 같은 리턴 타입.

-lambda를 포워딩 함수로 쓰려면:
auto f = [](auto&& param) { return func(normalize(std::forward<decltype(param)>(param))); };

Things to Remember
• Use decltype on auto&& parameters to std::forward them.

	Item 34: Prefer lambdas to std::bind.

-C++14, 11에선 lambda가 거의 언제나 나은 선택지

-The most important reason: readability

-bind로 lambda를 대신했을 때 steady::clock::now()와 같은 함수는 bind된 함수가 아닌 bind가 호출될 때 호출된다.

-C++14에서 템플릿 타입 매개변수는 주로 생략 가능. // 추론

-bind나 lambda에서 호출하려는 함수에 추가 매개변수를 받는 오버로딩 버전이 추가되면 bind는 모호성에 compile fail
 -특정 버전 function pointer로 static_cast하는 방법이 있으나 컴파일러 inline 최적화 효과를 받지 못한다 ->  lambda faster

-in C++11, the lambda couldn’t take an auto parameter

-bind는 호출 함수에 전해지는 매개변수를 값으로 저장하나 이것을 알 방법이 없다.

-Code using std::bind is less readable, less expressive, and possibly less efficient.

-No reasonable use cases for std::bind in C++14

-2 justifiable use cases of std::bind in C++11:
 -Move capture
 -Polymorphic function objects

Things to Remember
• Lambdas are more readable, more expressive, and may be more efficient than using std::bind.
• In C++11 only, std::bind may be useful for implementing move capture or for binding objects with templatized function call operators.

	Chapter7. The Concurreny

	Item 35: Prefer task-based programming to thread-based

-int doSyncWork();
 thread-based: std::thread t(doSyncWork);
 task-based: auto fut = std::async(doSyncWork);

-it's much easier to get return value through task-base; // get이 리턴값, exception 리턴.

-3 meanings of thread in concurrent C++ software:
 -Hardware threads that actually perform computation
 -Software threads that OS manages across all processes and schedules for execution on hardware threads.
 -std::thread in a C++ process that act as handles to underlying software threads

-Software threads are a limited resource. 시스템 생성 가능 스레드보다 더 생성하면 nothrow여도 exception

-unblocked software threads 수 >  hardware threads 수 -> time-slices the software threads on the hardware. 시간 다되면 context switch 발생 -> thread management overhead
 -last time slice와 다른 core에 배정될 시 더 심각해짐 // oversubscription

-최적화된 software hardware thread 비율은 동적으로 정해지기에 avoiding oversubscription은 어렵다 -> std::async()로 책임 전가.

-std::async()는 스레드 관리 책임을 C++ STL 구현에 넘긴다.

-std::async()는 새 스레드 생성을 보장하지 않는다. 호출 함수 리턴값을 요구하는 스레드에서 실행한다.

-Some situations where using threads may be appropriate:
 -You need access to the API of the underlying threading implementation.
 -You need to and are able to optimize thread usage for your application.
 -You need to implement threading technology beyond the C++ concurrency API

Things to Remember
• The std::thread API offers no direct way to get return values from asynchronously run functions, and if those functions throw, the program is terminated.
• Thread-based programming calls for manual management of thread exhaustion, oversubscription, load balancing, and adaptation to new platforms.
• Task-based programming via std::async with the default launch policy handles most of these issues for you.

	Item 36: Specify std::launch::async if asynchronicity is essential.

-Two std::async launch policy:
 -std::launch::async: f must be run asynchronously
 -std::launch::defferred: f may run only when get or wait is called on the future returned by std::async

-std::async(f); == std::async(std::launch::async | std::launch::deferred, f); 

-Given a thread t executing -> auto fut = std::async(f);
 -It’s not possible to predict whether f will run concurrently with t.
 -It’s not possible to predict whether f runs on a thread different from the thread invoking get or wait on fut.
 -It may not be possible to predict whether f runs at all

Things to Remember
• The default launch policy for std::async permits both asynchronous and synchronous task execution.
• This flexibility leads to uncertainty when accessing thread_locals, implies that the task may never execute, and affects program logic for timeout-based wait calls.
• Specify std::launch::async if asynchronous task execution is essential.

	Item 37: Make std::threads unjoinable on all paths

-destruction of a joinable std::thread terminates your program, because the two obvious alternatives—an implicit join and an implicit detach—were considered worse choices.

-Use RAII thread 

Things to Remember
• Make std::threads unjoinable on all paths.
• join-on-destruction can lead to difficult-to-debug performance anomalies.
• detach-on-destruction can lead to difficult-to-debug undefined behavior.
• Declare std::thread objects last in lists of data members.

	Item 38: Be aware of varying thread handle destructor behavior

Things to Remember
• Future destructors normally just destroy the future’s data members.
• The final future referring to a shared state for a non-deferred task launched via std::async blocks until the task completes.

	Item 39:Consider void futures for one-shot event communication

Things to Remember
• For simple event communication, condvar-based designs require a superfluous mutex, impose constraints on the relative progress of detecting and react‐
ing tasks, and require reacting tasks to verify that the event has taken place.
• Designs employing a flag avoid those problems, but are based on polling, not blocking.
• A condvar and flag can be used together, but the resulting communications mechanism is somewhat stilted.
• Using std::promises and futures dodges these issues, but the approach uses heap memory for shared states, and it’s limited to one-shot communication

	Item 40: Use std::atomic for concurrency, volatile for special memory.

Things to Remember
• std::atomic is for data accessed from multiple threads without using mutexes. It’s a tool for writing concurrent software.
• volatile is for memory where reads and writes should not be optimized away. It’s a tool for working with special memory.

	Item 41:Consider pass by value for copyable parameters that are cheap to move and always copied.

-코드 중복 발생시 global reference의 포워딩 함수로 해결 가능
 -But there are some forwarding failure cases

Things to Remember
• For copyable, cheap-to-move parameters that are always copied, pass by value may be nearly as efficient as pass by reference, it’s easier to implement, and it
can generate less object code.
• Copying parameters via construction may be significantly more expensive than copying them via assignment.
• Pass by value is subject to the slicing problem, so it’s typically inappropriate for base class parameter types.

	Item 42:Consider emplacement instead of insertion.

-호환되지만 정확하지 않은 타입을 매개변수로 전달하면 임시 객체를 생성하고 그 임시 객체로 다시 copy construct하는 최적화 문제 발생 e.g. std::string과 string literals

-해결법: emplace_back

-emplace_back uses whatever arguments are passed to it to construct directly inside the std::vector.

-emplace_back uses perfect forwarding

-emplace_back is available for every standard container that supports push_back

-Insertion functions take objects to be inserted, while emplacement functions take constructor arguments for objects to be inserted.
 ->최적화 문제를 피할 수 있는 이유

-Emplacement functions can thus do everything insertion functions can.

-There are also situations where the insertion functions run faster.
 > But not easy to characterize
 > benchmark them both

-If all the following are true, emplacement will almost certainly outperform insertion:
 -The value being added is constructed into the container, not assigned: move 발생 -> 임시 객체 필요
 -The argument type(s) being passed differ from the type held by the container.
 -The container is unlikely to reject the new value as a duplicate: emplace는 원소 중복 여부 판단을 위해 노드를 생성 및 비교 -> 중복x 시 노드 생성 및 소멸 비용 발생

-When working with containers of resource-managing objects, if you choose an emplacement function over its insertion counterpart, 
 you’re not paying for improved code efficiency with diminished exception safety.

-you shouldn’t be passing expressions like “new Widget” to emplace_back or push_back or most any other function because this leads to the possibility of exception safety problems.

-The code should be like:
 std::shared_ptr<Widget> spw(new Widget, killWidget);

 ptrs.push_back(std::move(spw)); // ptrs.emplace_back(std::move(spw));

-Emplacement functions use direct initialization, which means they may use explicit constructors

-when you use an emplacement function, be especially careful for passing the correct arguments, because even explicit
 constructors will be considered by compilers as they try to find a way to interpret your code as valid.

Things to Remember
• In principle, emplacement functions should sometimes be more efficient than their insertion counterparts, and they should never be less efficient.
• In practice, they’re most likely to be faster when (1) the value being added is constructed into the container, not assigned; (2) the argument type(s) passed
  differ from the type held by the container; and (3) the container won’t reject the value being added due to it being a duplicate.
• Emplacement functions may perform type conversions that would be rejected by insertion functions.