	1.1.1

-빌드:
 preprocessor - 소스 코드에 담긴 메타 정보 처리
 compiler - 소스 코드를 머신이 읽을 수 있는 목적 파일로 변환
 linker - 변환한 여러 오브젝트 파일을 애플리케이션으로 엮음.

-#pragma [xyz]: xyz에 대한 동작은 컴파일러 의존. 주로 지시자에 도달할 때 에러 메세지를 화면에 표시하는 용도로 사용.

	1.1.2 네임스페이스

-네임스페이스는 이름 충돌 문제 해결책.

-컴파일러는 using 지시자를 보면 그 뒤는 using에 지정된 네임스페이스에 속하는 것으로 처리.

* 헤더 파일 안에서는 절대로 using문을 작성하면 안 된다. 그러면 그 헤더 파일을 인클루드하는 모든 파일에서 using문으로 지정한 방식으로 호출해야 한다.

-C++17 nested namespace, namespace alias // 59p

	1.1.3 리터럴

-리터럴(literal)은 코드에 표시한 숫자나 스트링과 같은 값을 의미.

-숫자 리터럴은 자릿수 구분자를 사용 가능. // 23'456'789

	1.1.4 변수

-초기화 필수.

-자동 캐스팅 시 데이터 손실 주의.

	1.1.5 연산자

	1.1.6 타입

-열거 타입(enumerated type)을 사용하면 숫자를 나열하는 방식과 범위를 마음대로 정의해서 변수를 선언하는 데 활용할 수 있다.

-타입을 엄격히 따지는 것을 '스트롱 타입(strongly typed)' 또는 '타입 세이프하다'고 표현

-타입 세이프 -> enum class 사용한.

-enum class 값 이름들은 스코프가 자동으로 확장x. 따라서 스코프 지정 연산자 필요.

* 열거 타입을 사용할 때는 타입에 안전하지 않은, 즉 타입 언세이프(type-unsafe)한 enum보다는 스트롱 타입 버전인 enum class로 작성하는 것이 좋다.

* C++17 부터 if 문 안에 이니셜라이저(initializer)를 넣는 기능이 추가됐다. // p69

-C++에서 switch 문에 지정할 수 있는 표현식: 정수 타입, 정수 타입 변환 가능 타입, 열거 타입, 엄격한 열거 타입, 상수와 비교 가능.

-switch 문의 case 문은 break 문이 나타날 때까지 실행. 이때 break 문이 없다면 다음 case문도 계속 실행 -> 폴스루(fallthrough).

-폴스루 방식으로 작성하면 버그가 발생하기 쉽다. 

-C++17부터 [[fallthrough]]로 의도적 폴스루 컴파일러에 알림 가능.

	1.1.8 논리 연산자

-C++는 단락 논리(short-circuit logic, 축약 논리) 방식 적용.

-단락 되는 논리식을 작성할 때는 가볍게 검사를 앞에.

	1.1.9 함수

-C++에서 함수를 사용하려면 사용 위치보다 앞에서 선언.

-함수 이름과 매개변수 목록 -> 함수 시그내처(function signature)

-C++14부터는 auto 키워드를 사용 가능

-함수마다 내부 정의 __func__ 로컬 변수는 현재 함수의 이름을 값으로 갖는다.

	1.1.10 C 스타일 배열

-배열의 크기를 지정할 때 이니셜라이저 리스트에 나온 원소 수가 배열의 크기로 지정한 개수보다 적으면 나머지 원소는 0으로 초기화된다.

-스택 기반의 C 스타일 배열의 크기는 C++17부터 제공하는 std::size() 함수로 알아낼 수 있다(<array> 헤더 include 필요).

-컴파일러가 C++17을 지원하지 않는다면 sizeof 연산자로 크기를 구한다.

	1.1.11 std::array

-std::array 고정 크기 컨테이너를 제공. 자동으로 포인터를 캐스팅하지 않아서 특정한 종류의 버그를 방지.

	1.1.12 std::vector

-vector는 동적이다.

	1.1.13 구조적 바인딩

-C++17부터 구조적 바인딩(structured binding) 도입. 여러 개의 변수를 배열, 구조체, 페어 또는 튜플의 값으로 초기화 가능.

	1.1.14 반복문

-continue는 꼭 필요할 때만.

	1.1.15 이니셜라이저 리스트

-이니셜라이저 리스트(initializer_list)는 <initialzer_list> 헤더 파일에 정의.  초기화 쉽게

-initializer_list는 클래스 템플릿이다.

-이니셜라이저 리스트는 타입 세이프.

	1.2.2

-함수가 실행된 상태에서 다른 함수를 호출하면 스택 프레임(stack frame)이 올라온다. 전달된 매개변수는 다음 스택프레임으로 복제.

-함수의 실행이 끝나면 해당 스택 프레임이 삭제.

-변수를 계속 유지하고 싶다면 힙에 저장.

-포인터를 초기화하지 않고 사용하면 크래쉬(crash).

-NULL은 상수 0과 같아서 문제가 발생할 여지가 있다. 정식 널 포인터 상수인 nullptr를 사용.

-std::unique_ptr와 std::shared_ptr는  <memory> 헤더 파일에 정의.

-unique_ptr를 생성은 반드시 std::make_unique<>()를 사용.
 auto anEmployee = make_unique<Employee>();

-make_unique()는 C++14부터 추가됐다. 지원하지 않는 컴파일러를 사용한다면: unique<Employee> amEmployee(new Employee);

-unique_ptr는 C 스타일 배열을 저장하는 데도 활용할 수 있다.
 auto employees = make_unique<Employee[]>(10);

-shared_ptr는 std::make_shared<>()로 생성한다.

-C++17부터 shared_ptr에 배열도 저장할 수 있다. 하지만 make_shared<>()를 사용할 순 없다:
 shared_ptr<Employee[]> employees(new Employee[10]);

-기존에 사용하던 일반 포인터는 소유권과 관련이 없는 경우에만 사용한다.

	1.2.3

-C++에서는 non-const변수를 const 변수로 캐스팅할 수 있다.

	1.2.4

-레퍼런스를 사용하면 기존 변수에 새 이름을 지정할 수 있다.

* 함수에 객체를 전달할 때 const 레퍼런스로 전달하는 것이 좋다. 객체를 함수 안에서 수정하려면 non-const.

	1.2.5 익셉션

-익셉션이란 예상하지 못한 상황을 표현하는 클래스/객체.

-throw 문장이 실행되면 함수에서 값을 리턴하지 않고 실행 즉시 중단.

	1.2.6 타입 추론

-auto는 복잡한 타입 적용 시 편리.

-auto로 타입을 추론하면 지정된 레퍼런스나 const 한정자가 제거된다.

-const 레퍼런스 타입으로 지정하면 auto 키워드 앞뒤에 레퍼런스 타입과 const 키워드를 붙인다.

* auto를 지정하면 레퍼런스와 const 지정자가 사라져서 값이 복제된다는 점에 주의한다. 복제 방식으로 전달되지 않게 하려면 auto&나 const auto&로 지정한다.

-decltype 키워드는 인수로 지정한 표현식의 타입을 알아낸다.

-decltype은 레퍼런스나 const 지정자를 삭제하지 않는다는 점에서 auto와 다르다.

	1.3 C++의 객체지향 언어 특성

	1.3.1 클래스 정의

-클래스란 객체의 특성을 정의한 것.

-클래스의 데이터 멤버 이름 앞에 소문자 'm'을 붙이는 관례가 있다.

	1.4 유니폼 초기화

-유니폼 초기화를 사용하면 축소 변환(narrowing)을 방지.

-유니폼 초기화는 동적 할당 배열을 초기화할 때도 적용 가능.

	1.4.1 직접 리스트 초기화와 복제 리스트 초기화

-이니셜라이저는 복제리스트 초기화(copy list initialization)과 직접리스트 초기화(direct list initialization)가 있다.

-C++17 이전에는 복제 리스트 초기화와 직접 리스트 초기화 모두 initializer_list<>로 처리했다.

	1.6.2 Employee 클래스

-#pragma once는 같은 파일을 여러 번 임포트하지 않게 해준다.

-코드가 아무리 단순하더라도 getter와 setter를 구현.

	2. 스트링과 스트링 뷰 다루기

-C언어는 널로 끝나는 문자 배열로 스트링을 표현.

	2.1 동적 스트링

	2.1.1 C 스타일 스트링

-C 스트링을 다룰 때 \0 문자를 담을 공간을 할당하지 않는 실수 주의.

-<cstring>는 C 언어 스트링 연산 함수 제공.

-sizeof() 연산자는 데이터 타입이나 변수의 크기를 구하는 데 사용.

	2.1.2 스트링 리터럴

-"hello"처럼 곧바로 값으로 표현한 스트링을 스트링 리터럴(string literal)이라 부른다.

-스트링 리터럴은 메모리의 읽기 전용 영역에 저장. 

-컴파일러는 스트링 리터럴이 코드에 중복되면 레퍼런스를 재사용하는 방식으로 메모리를 절약 -> 리터럴 풀링(literal pooling).

-스트링 리터럴 참조 시 const 문자에 대한 포인터를 사용하는 것이 안전.

-문자 배열(char[]) 초깃값을 설정 때도 스트링 리터럴을 사용. 이때 컴파일러는 주어진 스트링을 충분히 큰 배열을 생성 뒤, 스트링 값 복사.

-위의 경우 스트링 리터럴을 읽기 전용 메모리에 넣지 않으며 재사용하지도 않는다.

-로 스트링 리터럴(raw string literal)이란 여러 줄에 걸쳐 작성한 스트링 리터럴. 이스케이프 시퀀스는 일반 텍스트 취급.
 const char* str = R"(Hello "World"!)";

-로 스트링 리터럴은 )"로 끝나기 때문에 그 안에 )"를 넣을 수 없다. )" 문자를 추가하려면 확장 로 스트링 리터럴 구문으로 표현해야 한다.
 R"d-char-sequence(r-char-sequence)d-char-sequence"
 -구분자 시퀀스는 로 스트링 리터럴 안에 나오지 않는 값으로 지정.

	2.1.3 C++ std::string 클래스

-std::string은 basic_string이라는 클래스 템플릿의 인스턴스. <cstring>의 함수와 기능 유사. 메모리 할당 작업 자동 처리.

-string 클래스의 c_str() 메서드로 C 언어와 호환성을 보장. 이 메서드는 C 스타일 스트링을 표현하는 const 문자 포인터 리턴.

-string의 data() 메서드는 C++14까지는 cosnt char* 타입으로 리턴. C++17부터 non-const 스트링에 대해 호출하면 char* 리턴

-표준 사용자 정의 리터럴's'를 사용하면 스트링 리터럴을 std::string으로 만들 수 있다.
 auto string1 = "Hello World"s; // using namespace std::string_literals; 또는 using namespace std; 필요.

-std 네임스페이스는 숫자, string 변환 편의 함수를 제공.
 string to_string(... val);

-위와 반대로 변환하는 함수도 정의돼 있다.
 stoi, stol etc.

-C++17부터 로우 레벨 숫자 변환에 대한 함수도 다양하게 제공. <charconv> 헤더에 정의. 이 함수는 메모리 할당 관련 작업 지원 전무. 버퍼를 할당하는 방식으로 사용.

-숫자 데이터와 포맷(JSON, XML 등) 사이 변환 작업을 로케일에 독립적이면서 빠른 속도로 처리하려면 로우 레벨 함수 사용:
 to_chars_result to_chars(char* first, char* last, IntegerT value, int base = 10); // 138p

 struct to_chars_result {
     char* ptr;
     errc ec;
 }

-정상적으로 변환됐다면 ptr 멤버는 끝에서 두 번째 문자, 그렇지 않으면 last 값(이때 ec== errc::value_too_large다).
 if (result.ec == std::errc()) { /* 제대로 변환된 경우 */}

-또한 부동소수점 타입에 대한 변환 함수도 제공.
 to_chars_result to_chars(char* first, char* last, FloatT value, chars_format format, int precision)

-스트링을 숫자로 변환하는 함수.
 from_chars_result from_chars(const char* first, const char* last, FloatT& value, chars_format format = chars_format::general);

 struct from_chars_result {
     const char* ptr;
     errc ec;
 };

-ptr 멤버는 변환 실패 시 첫 번째 문자에 대한 포인터. 제대로 변환될 때는 last. 변환된 문자가 없다면 ptr는 first, 에러 코드는 errc::invalid_argument

-from_chars()는 앞에 나온 공백 문자를 무시하지 않는다.

	2.1.4 std::string_view 클래스

-std::string_view는 std::basic_string_view 클래스 템플릿의 인스턴스. <string_view> 헤더. 

-string_view는 const_string& 대신 사용할 수 있으며 오버헤드도 없다.

-string_view 인터페이스는 c_str() 부재 제외, std::string과 같다.

-string과 string_view를 서로 연결/결합 불가.

-string_view는 대부분 값으로 전달. 스트링에 대한 포인터와 길이만 갖고 있어서 복사하는 데 오버헤드가 적기 때문.

-string_view 생성자 중에서 원시(raw) 버퍼와 길이를 매개변수로 받는 것도 있다. 이러한 생성자는 NULL로 끝나지 않는 스트링 버퍼로 string_view를 생성할 때 사용한다.

-string_view 사용으로 string이 생성되지는 않는다. string 생성자 호출, string_view::data()로 생성.

* 읽기 전용 스트링을 받는 함수나 메서드의 매개변수 타입은 std::string_view로 지정.

-표준 사용자 정의 리터럴인 'sv'를 사용하면 스트링 리터럴을 std::string_view로.

* C 스타일 스트링은 사용하지 않는다.

* MFC나 QT 등에서 기본적으로 제공하는 스트링처럼 현재 사용하는 프레임워크에서 제공하는 스트링을 프로젝트의 표준 스트링으로 삼는다.

	3. 코딩 스타일

	3.1.2 바람직한 스타일의 기준

-잘 작성된 코드에서 볼 수 있는 공통적인 속성:
 문서화, 분할, 명명규칙, 언어 사용, 포매팅

	3.2 코드 문서화

-문서화(documentation)란 주석을 의미.

-클라이언트에 코드를 사용 방법을 알려주기 위해서. 코드만으로 표현할 수 없는 특정 조건 등을 기입.

* 회사의 코딩 가이드라인에 함수 주석 방식을 따로 정해두지 않았다면 상식적으로 판단해서 작성한다. 이때 함수의 이름, 리턴값의 타입, 매개변수의 이름 및 타입으로 분명히 드러나지 않는
  정보만 주석으로 남긴다.

-알고리즘이 난해할 때 코드에서 사용하는 알고리즘과 (반복문의) 불변 속성에 대한 주석을 추가.

-불변 속성(invariant)이란 루프와 같은 일정한 코드 영역을 실행하는 동안 반드시 만족해야할 조건.

-메타 정보(meta-information)를 제공하기 위한 목적으로도 주석을 단다. 메타 정보는 코드 생성과 관련된 세부사항.

	3.2.2 주석 스타일

-문장 단위 주석: 모든 문장에 주석을 작성

* 모든 문장 주석은 비추천. 코드가 복잡하다면 코드의 작성 의도를 설명.

-머리말 주석:
 첫머리에 남기면 좋은 정보: 최종 수정 일자, 최초 작성자, 변경 내역, 파일에서 구현한 기능의 ID, 저작권 정보, 파일/클래스에 대한 간략한 설명, 미완성 기능, 발견된 버그

-고정 양식 주석:
 주석을 외부 문서화 도구로 처리할 수 있도록 표준 양식에 따라 작성하는 사례가 늘고 있다. C++프로그래머는 Doxygen이란 무료 툴을 많이 사용한다.

-잘 작성된 코드는 대체로 주석이 적다. 좋은 코드는 읽기 쉽다.

* 잘 읽히면서 주석에는 꼭 필요한 정보만 담긴 코드가 좋은 코드다.

	3.3 코드 분할

-가장 바람직한 형태는 함수나 메서드마다 한 가지 작업만 수행.

	3.3.1 리팩토링을 통한 코드 분할

-리팩토링(refactoring)이란 코드의 구조를 재조정하는 작업.
 ex) 필드 캡슐화, 타입 일반화, 메서드 추출, 클래스 추출 등등

-코드 리팩토링 과정에서의 발생 버그 최소화를 위해 테스팅 프레임워크를 활용.

	3.3.2 디자인 기준으로 코드 분할하기

-모든 기능을 코드로 작성하지 말고, 코드 분할 기법을 적용해서 나중에 모듈, 메서드, 함수에서 구현할 부분을 빼놓으면 코드 밀집도를 하락 및 체계적 구조 성취.

-코드부터 작성하지 말고 먼저 프로그램 디자인부터.

	3.4 명명 규칙

-규칙:
 -이름의 첫 글자로 숫자가 나올 수 없다
 -더블 언더스코어는 특정한 용도로 사용되기 때문에 이름에 넣을 수 없다
 -언더스코어로 시작하는 이름도 특정한 용도로 사용하기 때문에 쓸 수 없다.

	3.4.1 좋은 이름과 나쁜 이름

-좋은 이름은 그 용도가 명확히 드러나는 것.

	3.4.2 흔히 쓰는 명명 규칙

-2D 데이터를 다룬다면 행, 열 인덱스로 row와 column.

-접두어:
 m, m_: member 
 s, ms, ms_: static 
 k: constant
 b, is: boolean
 n, mNum: number

* 가독성을 해치지 않으면서 용도가 드러나는 이름이 좋은 이름.

	3.5 언어의 기능에 스타일 적용하기

	3.5.1 상수 사용법

-나쁜 코드는 매직 넘버가 어지럽게 흩어져 있다.

	3.5.2 포인터 대신 레퍼런스 사용하기

-포인터보다 레퍼런스가 더 안전.

-레퍼런스는 메모리의 소유권을 명확히 표현할 수 있다는 것.

	3.6 포매팅

	3.6.1 중괄호 정렬에 관련된 논쟁

	3.6.3 스페이스와 탭

-탭과 스페이스는 다르다. 탭은 길이에 제한이 없지만 스페이스는 언제나 한 칸.

	3.8 요약

-스타일은 프로그래밍에서 굉장히 중요한 요소라고 확실히 인식하는 것이 중요하다.

-자신이 작성한 코드를 다른 사람과 공유하기 전에 반드시 스타일에 따라 작성했는지 검토하는 습관을 들인다.

	4. 전문가다운 C++ 프로그램 디자인

-프로젝트를 시작할 때 시간을 충분히 투자해서 제대로 디자인하면 오히려 프로젝트 완료 시점을 앞당길 수 있다.

	4.1 프로그램 디자인의 정의

-가장 먼저 할 일은 요구사항을 분석. 이 단계에서 핵심 결과는 기능 요구사항 문서다. 이 문서는 작성할 코드가 정확히 할 일만 표현.

-소프트웨어 디자인이란 (기능 및 비기능)요구사항을 만족하는 프로그램 구현을 위한 구조 명세서. 즉, 정리된 프로그램의 구현 계획.

-디자인 문서 포맷은 대부분 크게 두 부분으로 구성된다:
 프로그램을 구성하는 서브 시스템
 서브시스템별 세부사항

* 디자인 과정의 핵심은 프로그램 작성 전에 먼저 생각해보는 것.

	4.3 C++에 적합한 디자인 방법

	4.4 C++ 디자인에 관련된 두 가지 원칙

-가장 핵심적인 원칙은 추상화와 재사용.

	4.4.1 추상화

-외부 인터페이스와 내부 구현의 분리

-함수와 클래스를 디자인할 때는 내부 구현사항을 몰라도 쉽게 사용할 수 있게.

	4.4.2 재사용

-기존 코드가 있다면 재사용할 수 있는지 반드시 검토.

-프로그램은 클래스, 알고리즘, 데이터 구조를 재사용할 수 있도록 디자인해야 한다.

-당장 주어진 문제에만 적용할 수 있도록 특화된 형태로 디자인하지 않는 것이 좋다.

	4.5 코드 재사용

-재사용 가능 코드의 형태 파악.

* 코드 재사용이란 단순히 기존 코드를 복사해서 붙이는 것이 아니다. 이와 정반대로 일일이 복제하지 않고도 코드를 재사용할 수 있어야 한다.

	4.5.1 용어 정리

-재사용할 코드를 만드는 형식:
 독립 함수 또는 클래스
 라이브러리: 특정한 작업을 처리하는 데 필요한 코드를 한데 묶은 것.
 프레임워크: 디자인할 프로그램의 기반이 되는 코드를 모아둔 것.

* 라이브러리는 특정한 기능을 제공하는 반면 프레임워크는 프로그램의 디자인과 구조에 대한 토대를 제공

-API는 특정한 기능을 수행하는 코드나 라이브러리에 대한 인터페이스.

* API와 라이브러리는 서로 다른 개념. 라이브러리는 구현을 의미, API는 라이브러리를 외부에 제공하기 위한 인터페이스.

-윈도우 환경을 위한 GUI 프로그램을 C++로 작성할 때는 MFC나 Qt와 같은 프레임워크.

-코드 재사용 여부는 상황과 목적에 따라 판단.

-언제든지 결정을 뒤집어도 된다. 프로그램을 제대로 추상화했다면 결정을 바꾸더라도 큰 부담 없이 대응할 수 있다.

	4.5.3 코드 재사용 전략

-기능과 제약사항 파악하기:
 -사용할 코드를 충분히 분석. 제약사항도 파악.

-성능 파악하기:
 재사용하려는 코드의 성능이 적당한지 반드시 확인.

 * 빅오 표기법은 입력에 따라 속도가 변하는 알고리즘에만 적용된다. 입력을 받지 않거나 실행 시간이 무작위인 알고리즘에는 적용할 수 없다.

 -빅오 실행 시간이 같아도 실행해보면 실제 속도는 다를 수 있다.

 -빅오 표기법은 입력의 크기가 작을 때는로 정확히 표현할 수 없다.

 -문서를 너무 믿지 않는다. 사용할 라이브러리의 성능이 충분한지는 직접 성능 테스트를 해보고 판단.

-플랫폼 제약사항 파악하기:

-라이센스와 기술 지원 파악하기:
 
 * 배포 및 판매 목적 프로그램에서 서드파티 라이브러리를 사용 시 반드시 라이센스 제약사항을 파악.


-라이브러리에서 제공하는 기능을 익히는 가장 좋은 방법은 직접 코드를 작성해보는 것이다.

	4.5.4 서드파티 애플리케이션을 번들로 제공하기

-서드파티 애플리케이션을 번들로 포함시킬 때도 라이브러리 재사용에 관련된 가이드라인과 주의사항을 똑같이 적용. 특히 라이센스.

	4.5.5 오픈소스 라이브러리

-오픈소스(open source)란 일반적으로 누구나 코드를 들여다 볼 수 있다는 것을 의미한다.

-오픈소스 운동:
 자유 소프트웨어(free software): 여기서 자유는 소스 코드를 보고, 수정하고, 재배포할 자유를 의미.
 오픈소스 소프트웨어: 소스 코드가 반드시 제공되는 소프트웨어를 가리킨다. 오픈소스 소프트웨어는 소스 코드를 사용하고, 수정하고, 재배포할 자유를 보장할 필요가 없다는 차이.

-오픈소스 포털
 www.boost.org
 www.gnu.org
 github.com/open-source
 www.sourceforge.net

	4.5.6 C++ 표준 라이브러리

-C++는 C의 기능을 대부분 포함.

-C 표준 라이브러리도 그대로 사용 가능.

* C++는 C언어보다 향상된 스트링 및 I/O 기능을 제공. C++ 제공 스트링과 I/O 스트링을 활용하는 것이 바람직.

	4.6 체스 프로그램 디자인

	4.6.2 디자인 단계

-보통 프로그램을 디자인할 때는 일반적인 부분에서 시작해서 점차 구분적인 부분으로 진행한다.

1. 프로그램을 서브시스템으로 분할하기:
 -프로그램을 기능에 따라 서브시스템 단위로 분할 및 각각의 인터페이스와 연동 방식을 정의.

2. 스레드 모델 선택하기:
 -프로그램에서 사용할 최상위 스레드 수와 상호작용 방식정도는 정해두는 것이 좋다.

 -프로그램에서 뚜렷이 구분되는 작업이 여러 개고, 동시에 실행할 수도 있다면 멀티스레드로 구성.

3. 서브시스템의 클래스 계층 구성하기:

4. 서브시스템의 클래스, 데이터 구조, 알고리즘, 패턴 지정

5. 서브시스템의 에러 처리 방법 정하기:
 -에러 처리 방법 나열. 시스템 에러뿐만 아니라 사용자 에러도 고려.

 -에러 처리의 기본 원칙은 모든 에러를 처리하는 것. 따라서 발생 가능한 경우의 수를 면밀히 검토한다.

	5. 객체지향 디자인

-절차형 프로그래밍과 객체지향 프로그래밍은 프로그램의 실행 과정을 표현하는 방식만 다르다는 점.

	5.1 절차형 사고방식

-절차형 언어는 하나의 작업만 담당하는 프로시저라 부르는 작은 단위로 코드를 구성.

* C는 함수형 언어가 아니다. 함수형 언어에서 말하는 함수와 절차형 언어의 함수(프로시저)는 서로 다른 개념이며, 추상화 방식도 완전히 다르다.

-일정한 단계에 따라 진행하는 프로그램을 작성할 때는 절차형 접근 방식이 적합.

	5.2 객체지향 철학

-절차형 접근 방식: '이 프로그램이 무슨 일을 하는가?
 객체지향 접근 방식: '현실세계의 어떤 대상을 모델링하는가?

-객체지향 프로그래밍에서는 프로그램 물리적인 대상에 대한 모델로 나눈다: 클래스, 컴포넌트, 프로퍼티(속성), 동작

	5.2.1 클래스

-클래스는 어떤 대상의 유형을 정의하는 속성을 정리한 것.

-객체란 어떤 클래스에 속하는 구체적인 인스턴스(instance, 사례)다.

	5.2.2 컴포넌트

-컴포넌트는 본질적으로 클래스와 같다. 클래스보다 작고 구체적이라는 점만 다르다.

	5.2.3 프로퍼티

-객체는 프로퍼티로 구분한다. 

	5.2.4 동작

-OOP에서는 코드를 클래스 단위로 묶는다.

	5.3 객체 관점에서 바라보기

	5.3.1 과도한 객체화

-디자인에 뚜렷한 정답은 없으나, 충분한 고민 필요.

	5.3.2 지나친 일반화

-과도한 일반화는 '과도한 객체화'보다 나쁘다.

-객체를 과도하게 일반화하면 구체적인 대상을 표현하기 힘들다.

	5.4 객체 관계

	5.4.1 has-a 관계

-A는 B를 가진다 표현되는 객체 관계를 has-a관계 또는 집합(aggregation)관계라 한다.

	5.4.2 is-a 관계

-is-a 관계는 상속(inheritance)에 대한 것. 상속은 파생, 서브클래싱, 확장 등으로 다양하게 표현된다.

-여러 클래스의 코드가 상당 부분 겹친다면 그 부분을 상위 클래스로 묶어서 빼내는 게 좋다.

2. 다형성과 코드 재사용:
 -다형성(polymorphism)이란 프로퍼티와 메서드의 표준 셋을 정해두면 그 형식에 맞는 객체라면 서로 바꿔서 적용할 수 있다는 개념이다.

	5.4.3 has-a 관계와 is-a 관계 구분하기

-has-a는 외부 공개 인터페이스를 정하기 쉽고, 기능 손상을 걱정을 할 필요가 없다는 장점.

-LSP(Liskov Substitution Principle, 리스코프 치환 원칙): '동작을 바꾸지 않고도 베이스 클래스 대신 파생 클래스를 사용할 수 있어야 한다'

-is-a 관계와 has-a 관계를 쉽게 구분법: LSP

	5.4.4 not-a 관계

-불필요한 클래스 및 파생 클래스 관계를 주의.

-객체지향 방식으로 계층을 구성하려면 기능 관점에서 관계를 표현.

-불필요한 상속 관계를 만들지 않으려면 디자인 초안부터. 

-프로퍼티나 메서드를 갖지 않는 클래스가 있거나 추상 베이스 클래스가 아닌 클래스의 프로퍼티와 메서드를 전부 오버라이드한다면 디자인을 바꾸는 것이 좋다.

	5.4.5 클래스 계층

-파생 클래스의 공통점 -> 부모 클래스로 옮긴다.

-한 가지 명심할 점은 계층은 얼마든지 다르게 구성할 수 있다.

-제대로 구성된 계층의 특성:
 -기능적으로 의미 있는 관계에 따라 클래스를 구성.
 -쉬운 코드 재사용.
 -과도한 오버라이드 없음. 

	5.4.6 다중 상속

-사용할 때 각별히 주의.

-다중 상속의 반대 이유:
 -시각적으로 표현 복잡.
  -클래스의 관계를 파악하기 힘들다.
 -구조의 명확성이 깨질 수 있다.
 -구현 어려움.
  -코드 이해 힘듬.

-다중 상속을 피하도록 계층을 재구성 가능.

	5.4.7 믹스인 클래스

-믹스인의 문법은 다중 상속과 같지만 의미는 다르다.

-믹스인 클래스는 is-a 관계를 완전히 구현하지 않고도 기능을 추가할 때 사용.

-믹스인 클래스와 베이스 클래스의 차이점은 코드보다는 생각하는 방식에 있다.

	5.5 추상화

	5.5.1 인터페이스와 구현

-잘 정의한 인터페이스는 public 메서드만 가지고 있다.

	5.5.2 외부에 공개할 인터페이스 결정하기

1. 사용자 고려하기:
  -가장 먼저 인터페이스 사용자 분석.

  -바람직한 방법은 고객이 참여해서 공개 기능을 함께 정하는 것.

2. 용도 고려하기:
  -인터페이스의 용도부터 확실히 파악.

  -외부 사람이 제공 API를 사용하기 시작하면 변경 최소화.

  -API를 디자인할 때 가장 고민해야 할 사항은 사용성과 유연성의 절충점.

  -'잘 만든 API란 쉬운 일은 쉽게, 복잡한 일은 가능하게'

  -서브시스템에서 가장 먼저 고려할 점은 서브시스템의 핵심 목적을 분명히 하는 것.

  -서브시스템에서 할 일을 파악했다면 어떤 형태로 제공할지 결정. 구현의 세부사항에 너무 빠지지 않도록 주의.

  -개인용 인터페이스이더라도 공개다는 생각으로 디자인.

3. 미래 고려하기:
  -인터페이스를 디자인할 때는 반드시 미래에 사용할 일도 고려.

	5.5.3 바람직한 추상화 디자인

-인터페이스는 끊임없이 개선.

-추상화가 잘된 인터페이스는 public 메서드로만 구성.

-계층 구조가 너무 깊다면 주 인터페이스를 보조할 다른 클래스를 도입하는 것이 좋다.

	6. 재사용을 고려한 디자인

-항상 재사용 가능성을 염두에 두고 코드를 디자인.

	6.1 재사용 철학

-코드는 반드시 작성자뿐만 아니라 다른 프로그래머도 재사용할 수 있게 디자인.

-명심할 좌우명:
 -작성은 한 번, 사용은 여러 번
 -반드시 코드 중복은 피한다.
 -같은 일을 반복하지 않는다.

-재사용성이 낮으면 중복된 코드 증가.

-중복된 코드가 늘어나면 유지보수가 힘들어진다.

	6.2 코드를 재사용할 수 있도록 디자인하는 방법

-코드를 재사용할 수 있게 만드는 방법 두 가지:
 1. 용도나 분야가 달라도 사용할 수 있도록 범용성을 갖춘다.
 2. 재사용 가능 코드는 사용하기 쉽게.

-재사용할 수 있는 코드 디자인에 가장 중요한 부분은 추상화.

-재사용할 수 있는 코드를 디자인하는 과정은 크게 두 가지로 나뉜다:
 1. 코드의 구조를 잘 구성하는 것
 2. 제공 기능 사용하는 데 '진입점' 역할을 하는 인터페이스를 디자인.

	6.2.1 추상화 방법

-추상화 시 클라이언트의 잘못된 사용에서 예상치 못한 동작이나 버그의 발생 방지.

* 인터페이스 디자인 시 구현 세부사항을 클라이언트에 드러내지 않는다.

-리턴 정보 전달을 위해 클라이언트 코드에서 보관하는 정보: 핸들(handle)

-핸들 사용 시 불투명(opaque) 클래스로 구현. 

-불투명 클래스: 게터나 세터로 간접적으로 접근하게 만든 클래스.

-추상화 원칙은 너무나 중요해서 디자인 과정 전반에 적용.

-클라이언트가 인터페이스를 사용하기 위해 내부 구현사항을 알아야 하는지 검토.

	6.2.2 재사용에 최적화된 코드 구조화

1. 서로 관련 없거나 논리적으로 구분되는 개념은 합치지 않기
 -컴포넌트는 반드시 한 작업만 처리하거나 성격이 같은 것들만 처리하도록 디자인 -> 단일 책임성 원칙(Single Responsibility Principle, SRP).

 -기능을 논리적으로 별도인 컴포넌트로 구현해야 재사용성 상승.

 -서브시스템을 디자인할 때 최대한 결합도(coupling)를 낮게.

 -서로 관련 없는 개념도 하나로 합치면 안 된다.

2. 제네릭 데이터 구조와 알고리즘을 템플릿으로 구현하기

 -템플릿은 문법이 복잡, 동형(homogeneous) 데이터 구조만 지원.

 -템플릿? 상속?
  -동일한 기능을 다양한 타입에 > 템플릿.
  -구체적인 타입마다 동작을 다르게 > 상속.

3. 적절한 검사 기능과 안전장치 제공하기:
 -안전한 코드를 작성하기 위해 적용할 수 있는 두 가지 스타일:
  1. 계약에 따른 디자인(design by contract)
   -사전 조건, 사후 조건, 불변 조건의 세 가지 관점

4. 확장성을 고려한 디자인
 -개방/폐쇄 원칙 (Open/Closed Principle, OCP)
 -Strategy pattern

	6.2.3 사용성 높은 인터페이스 디자인

-재사용성을 높이는데 인터페이스 중요.

-인터페이스는 항상 제대로 구성. 재사용할 수도 있기 때문.

-인터페이스의 핵심 기능은 코드를 쉽게 사용하는 데 있다.

-인터페이스 기법:
 1. 인터페이스를 사용하기 쉽게 디자인하기
  -최대한 간결하고 직관적으로 사용하게.
  
  -사용하기 쉬운 인터페이스를 디자인하기 위한 네 가지 원칙:
   1. 익숙한 방식 따르기
     -표준 방식을 따르는 것

* 항상 사용자 입장에서 인터페이스를 고려해야 한다. 상식에 맞는지, 사용자가 충분히 예상할 수 있는지 따져본다.
  
   2. 필요한 기능 빼먹지 않기
    -이 원칙은 두 단계로 적용한다:
     1. 클라이언트가 필요로 하는 동작을 모두 인터페이스에 추가한다.
      -클라이언트 경우의 수 전부 고려.
      -향후 발생 가능 사례를 전부 지원은 불필요.
     2. 최대한 많은 기능을 구현한다:

   3. 군더더기 없는 인터페이스 제공하기
    -꼭 필요한 기능만 포함

   4. 문서와 주석 제공하기
    -방법은 두 가지. 인터페이스 코드 안에 주석, 별도 문서
    -구현이 아닌 동작 설명
    -구현에 대한 세부사항 너무 담지 않기.

 2. 범용 인터페이스 디자인
  -인터페이스는 범용적으로 구성.

  1. 하나의 기능을 다양한 방식으로 실행하게 만들기
 
  2. 커스터마이즈 지원하기

 3. 범용성과 사용성의 조화
   1. 여러 가지 인터페이스 제공하기
    -인터페이스 분리 원칙(Interface Segregation Principle, ISP): 사용자가 미사용 메서드에 의존하지 않아야 한다.

   2. 자주 사용하는 기능 쉽게 만들기

	6.2.4 솔리드 원칙

-객체지향 디자인의 기본 원칙을 기억하기 쉽도록 흔히 SOLID란 약어고 표현한다:
 SRP, Single Responsibility Principle
 OCP, Open/Closed Principle
 LSP, Liskov Substitution Principle
 ISP, Interface Segregation Principle
 DIP, Dependency Inversion Princible

	7. 메모리 관리

* 요즘은 C++에서 로우레벨 메모리 연산은 가급적 피하고 컨테이너나 스마트 포인터와 같은 최신 기능을 활용하는 추세다.

	7.1 동적 메모리 다루기

	7.1.1 메모리의 작동 과정 살펴보기

-로컬 변수를 자동 변수(automatic variable)라고 부르며 스택에 저장.

-int* ptr = new int;의 ptr 변수 스택에, 이 변수가 가리키는 값은 힙에.

*항상 포인터 변수를 선언하자마자 nullptr나 적절한 포인터로 초기화해야 한다. 절대로 초기화하지 않은 상태로 내버려두지 않는다.

	7.1.2 메모리 할당과 해제

1. new와 delete 사용법:

* new로 메모리를 할당할 때 스마트 포인터가 아닌 일반 포인터로 저장했다면 반드시 그 메모리를 해제하는 delete 문을 new와 짝을 이루도록 작성해야 한다.

* 메모리를 해제한 포인터는 nullptr로 다시 초기화한다. 그래야 이미 해제된 메모리를 가리키는 포인터를 모르고 다시 사용하는 실수를 방지할 수 있다.

2. malloc()

-malloc() 대신 new를 사용하는 것이 바람직

-free()는 소멸자 호출x delete는 o
* C++에서는 malloc()과 free()를 절대 사용하지 말고 new와 delete만 사용한다.

3. 메모리 할당에 실패한 경우:

-new가 실패하면 프로그램이 종료

-nothrow new도 있다. 이 버전은 익셉션 대신 nullptr를 리턴. // int* ptr = new(nothrow) int; 버그 가능성이 높음.

	7.1.3 배열

1. 기본 타입 배열:

-배열 메모리 할당 시 실제 메모리에서도 연속된 공간을 할당. 이때 메모리 한 칸은 배열의 한 원소 크기.

* 간혹 스택에 가변 크기 배열을 생성하는 기능을 지원하는 컴파일러도 있다. 하지만 C++ 표준 규격에 정의된 것이 아니므로 가능하면 이 기능은 사용하지 않는 것이 좋다.

-배열을 힙에 할당하면 실행 시간에 크기를 정할 수 있다는 장점.

-C 스타일 배열을 사용 시 정확한 크기를 알 수 없음.

-동적으로 할당된 배열(dynamically allocated array)와 동적 배열(dynamic array)는 다르다.

* C 스타일 배열 대신 표준 라이브러리 컨테이너를 사용하는 것이 안전.

* C++에서는 realloc()을 절대 사용하지 않는다. 사용자 정의 객체는 비트 단위 복사 작업에 맞지 않다.

2. 객체 배열:

-new[]를 호출하면 각 객체마다 제로 인수(=디폴트) 생성자(zero-argument constructor) 호출.

3. 배열 삭제하기:

-배열의 원소가 객체일 때만 모든 원소에 소멸자가 호출. 포인터 배열에 대해 delete[]를 호출할 때는 일일이 해제해야 한다.

4. 다차원 배열:

-다차원 스택 배열:
 
 -스택에 생성한 이차원 배열의 메모리 상태는 일차원 배열처럼 나열.

 -삼차원을 넘어가면 잘 사용하지 않는다.

-다차원 힙 배열:
 
 -차원 수를 실행 시간에 결정 -> 힙 배열.
 
 -힙에서는 메모리 공간이 연속적으로 할당되지 않기 때문에 스택 방식의 다차원 배열처럼 메모리를 할당하면 안 된다.

 -첫 번째 차원 배열의 각 원소(하위 배열) 메모리는 직접 하나씩 할당해야 한다.

* C 스타일 배열 대신 C++ 표준 라이브러리 컨테이너 사용.

	7.1.4 포인터 다루기

2. 포인터에 대한 타입 캐스팅:

-포인터는 타입 스트롱 x. 포인터 타입은 C 스타일 캐스팅 쉽게 이용 가능

-정적 캐스팅(static cast)를 사용하면 좀 더 안전. 관련 없는 타입으로 캐스팅 -> 컴파일 에러.

-상속 관계끼리 캐스팅 시 동적 캐스팅이 더 안전.

	7.2 배열과 포인터의 두 얼굴

	7.2.1 배열 = 포인터

-배열의 주소는 (인덱스가 0인) 첫 번째 원소의 주소.

-C++ 배열은 크기 정보를 다루지 않는다.

-컴파일러는 배열을 함수로 전달하는 부분을 포인터로 취급.

-길이를 알고 있는 스택 배열을 레퍼런스 전달 방식으로 함수에 전달하는 방법: // 힙 배열엔 적용 불가.
 void doubleIntsStack(int (&theArray)[4]);

-배열 문법 선언 배열은 포인터로도 접근 가능. 컴파일러는 함수로 전달하는 배열을 포인터로 취급.

	7.2.2 포인터가 모두 배열은 아니다.

* 모든 배열은 포인터로 참조할 수 있지만, 모든 포인터가 배열은 아니다.

	7.3 로우레벨 메모리 연산

	7.3.1 포인터 연산

-C++ 컴파일러는 포인터 연산을 수행할 때 포인터에 선언된 타입을 이용

	7.3.2 커스텀 메모리 관리

-메모리를 직접 관리하면 오버헤드를 좀 더 줄일 수 있다.

-메모리를 직접 다룰 때 객체 크기를 사전에 알고 있다면 객체 크기를 관리할 공간을 줄일 수 있다.

	7.3.3 가비지 컬렉션

	7.4 스마트 포인터

-모든 리소스를 제대로 해제하려면 리소스를 마지막으로 사용한 포인터가 해제해야 한다. -> 레퍼런스 카운팅(reference counting) 스마트 포인터

-shared_ptr는 스레드에 안전.

* 주로 unique_ptr를 사용. shared_ptr는 리소스 공유 때만 사용.

* 리소스를 할당 시 그 결과를 스마트 포인터에 저장하거나 다른 RAII 클래스를 사용.

	7.4.1 unique_ptr

1. unique_ptr 생성 방법:

* unique_ptr를 생성할 때는 항상 make_unique()를 사용한다.

2. unique_ptr 사용 방법:

-get() 메서드: 내부 포인터에 직접 접근.

-reset(): unique_ptr 내부 포인터를 해제 및 필요하면 다른 포인터로 변경.

-release(): 내부 포인터를 리턴한 뒤 스마트 포인터를 nullptr로 설정. 그러면 반환 리소스를 반드시 직접 해제.

-unique_ptr는 복사 불가

4. 커스텀 제거자

-unique_ptr는 메모리를 표준 free() 함수로 해제. 메모리가 아닌 다른 리소스를 관리하기에 편하기 때문.

	7.4.2 shared_ptr

* shared_ptr를 생성할 때는 반드시 make_shared().

-C++17부터 shared_ptr도 C 스타일 동적 할당 배열에 대한 포인터를 저장 가능. 

-reset() 동작 유사. release()는 지원하지 않는다.

-커스템 제거자의 타입을 템플릿 타입 매개변수로 지정하지 않아도 된다.

2. 레퍼런스 카운팅이 필요한 이유:

-스마트 포인터가 중복 삭제 방지.

-unique_ptr는 레퍼런스 카운팅과 복제 생성자(copy constructor)를 지원하지 않는다.

-가능하면 shared_ptr를 복사할 때 복제 생성자를 사용.

3. 앨리어싱:

	7.4.3 weak_ptr

-weak_ptr는 shared_ptr가 가리키는 리소스의 레퍼런스를 관리하는 데 사용. 

-weak_ptr는 리소스를 간접 소유 -> shared_ptr의 리소스를 해제에 영향x.

-weak_ptr는 삭제될 때 가리키던 리소스를 삭제하지 않고, shared_ptr가 그 리소스를 해제했는지 알아낼 수 있다. 

-weak_ptr의 생성자는 shared_ptr나 다른 weak_ptr를 인수로 받는다.

-weak_ptr에 저장된 포인터에 접근하려면 shared_ptr로 변환.

	7.4.4 이동 의미론

-표준 스마트 포인터는 이동 의미론 지원.

	7.4.5 enable_shared_from_this

-std::enable_shared_from_this를 이용하면 객체의 메서드에서 shared_ptr나 weak_ptr를 안전하게 리턴 가능.

	7.4.6 현재는 폐기된 auto_ptr

* 기존에 제공되던 스마트 포인터인 auto_ptr를 사용하지 말고, unique_ptr나 shared_ptr를 사용한다.

	7.5.1 스트링 과소 할당 문제

-C 스타일 스트링에서 흔히 발생하는 문제는 과소 할당(underallocation)이다. 널문자('\0') 공간을 빼고 공간을 할당 및 스트링의 최대 크기를 미리 정해둘 도 발생

-과소 할당 문제 해결법:
 1. C++ 스타일 스트링 사용.
 2. 버퍼를 힙에 할당. 공간이 부족하면 추가 할당 및 복사, 삭제.
 3. 최대 문자 수('\0' 포함)를 입력받아서 버퍼에 남은 공간과 현재 위치를 추적.

	7.5.2 메모리 경계 침범

-할당된 공간을 지나서 다른 메모리를 덮어 쓸 때: 버퍼 오버플로 에러(buffer overflow error)

* 안전하지 않은 C 스타일 스트링, 배열 보다, string이나 vector처럼 메모리 관리 기능을 제공하는 C++ 기능을 활용

	7.5.3 메모리 누수

-할당했던 메모리를 제대로 해제하지 않을 때 발생

1. 비주얼 C++를 이용한 윈도우 애플리케이션의 메모리 누수 탐지 및 수정 방법:

p.304

2. 밸그라인드를 이용한 리눅스 애플리케이션의 메모리 누수 탐지 및 해결 방법:

p.306

* 메모리 누수 현상이 발생하지 않도록 최대한 스마트 포인터를 적용.

	7.5.4 중복 삭제와 잘못된 포인터

-delete로 해제된 메모리를  다른 부분에서 사용: 댕글링 포인터(dangling pointer)

-nullptr에 대해 delete를 호출해도 문제 없음. 아무 일도 하지 않는다.

	8. 클래스와 객체 숙달하기

	8.2.1 클래스 정의

-클래스 정의 작성 파일의 이름은 주로 클래스 이름과 똑같이 짓는다.

1. 클래스 멤버:

-멤버 변수를 데이터 멤버라고도 부른다.

-객체를 변경하지 않는 멤버 함수는 항상 const로

2. 접근 제어:

-메서드가 없거나 개수가 적다면 주로 struct로 정의

3. 선언 순서:

-C++에서는 멤버와 접근 제한자를 선언하는 순서를 따로 정해두지 않았다.

4. 클래스 내부의 멤버 이니셜라이저

-멤버 변수를 선언하는 동시에 초기화 가능

	8.2.2 메서드 정의 방법

-일반 메서드 호출 시 메서드가 속한 객체의 포인터인 this가 숨겨진 매개변수 형태로 전달

	8.2.3 객체 사용법

-객체 생성 방법: 스택에 생성, 힙에 생성

* new로 객체를 할당했다면 다 쓴 후 delete로 해제해야 한다. 하지만 스마트 포인터를 사용하면 메모리를 자동으로 관리해준다.

	8.3 객체의 라이프 사이클

-객체의 라이프 사이클: 생성(creation), 소멸(destruction), 대입(assignment)

	8.3.1 객체 생성

-객체가 생성되면 그 안에 담긴 객체도 함께 생성된다.

-초깃값을 항상 설정

* C++ 프로그래머는 생성자를 간단히 ctor라고 부르기도 한다.

-인수 없이 호출하는 생성자: 디폴트 생성자

-포인터를 곧바로 초기화하지 않을 경우 반드시 nullptr로 초기화.

-한 생성자에서 다른 생성자 호출 시 의도한 대로 실행되지 않는다. 단, 위임 생성자(delegating constructor) 이용 시 가능

4. 디폴트 생성자:

-영인수(zero argument) 생성자라고도 부른다.

-디폴트 생성자가 필요한 경우:
 
 -객체 배열 생성 과정 두 단계: 공간 연속된 메모리에 할당, 각 객체마다 디폴트 생성자 호출

 -스택 배열이라면 이니셜라이저 제공으로 문제 해결 가능.

 -표준 라이브러리 컨테이너에 저장하려면 반드시 디폴트 생성자 정의.

-생성자를 하나라도 선언하면 컴파일러 디폴트 생성자 자동 생성x.

-명시적 디폴트 생성자:
 -C++ 03 이하 버전은 빈 디폴트 생성자를 반드시 정의해야 했다.

 -C++는 명시적 디폴트 생성자를 제공. // SpreadsheetCell() = default;

-명시적으로 삭제된 생성자:
 -Myclass() = delete;

5. 생성자 이니셜라이저:

-생성자 이니셜라이저 이용 시 생성하는 과정에서 초기화 가능. 훨씬 효율적.

* 생성자 이니셜라이저를 이용하면 객체를 생성하는 시점에 데이터 멤버를 초기화할 수 있다.

-주의점: 클래스 정의에 작성한 순서대로 초기화

6. 복제 생성자

-복제 생성자는 다른 객체와 똑같은 객체를 생성할 때 사용

-복제 생성자를 직접 작성하지 않으면 컴파일러가 대신 생성. 

-컴파일러 생성 복제 생성자: 기본 타입 -> 복사, 객체 타입 -> 그 객체의 복제 생성자 호출

-복제 생성자가 호출되는 경우:

 -함수나 메서드에 객체를 값으로 전달 시

 -함수에서 객체를 값으로 리턴 시

-레퍼런스로 객체 전달하기:

 -레퍼런스로 전달 -> 오버헤드 하락. 객체의 주소만 복사하기에

 -레퍼런스 전달 방식을 사용하면 객체의 동적 메모리 할당에 관련된 문제도 피할 수 있다.

 -string_view는 포인터와 길이만 가진다 -> 복제 오버헤드가 적기 때문에 주로 값 전달 방식 작성

 -기본 타입은 반드시 값으로 전달. const 레퍼런스로 전달 성능 향상 미미

-복제 생성자 삭제 시 복제 불가. 객체를 값으로 전달하지 않게 할 때 사용.

7. 이니셜라이저 리스트 생성자:

-이니셜라이저 리스트 생성자란 std::initializer_list<T>를 첫 번째 매개변수로 받고, 다른 매개변수는 없거나 디폴트 값을 가진 생성자

-이니셜라이저 리스트 생성자 안에서 각 원소에 접근: for 문으로 구현 가능

-표준 라이브러리 클래스는 모두 이니셜라이저 리스트 생성자를 지원

8. 위임 생성자:

-위임 생성자를 사용하면 같은 클래스의 다른 생성자를 안에서 호출 가능

-반드시 생성자 이니셜라이저에서 호출 및 멤버 이니셜라이저 리스트엔 이것만

-생성자 재귀 호출 주의

9. 컴파일러가 생성하는 생성자에 대한 정리:

-복제 생성자 명시적 정의x -> 컴파일러 복제 생성자 생성

-어떤 생성자라도 정의했다면 컴파일러는 디폴트 생성자를 만들지 않는다.

	8.3.2 객체 소멸

-객체 제거 과정은 두 단계: 소멸자 호출, 할당받은 메모리를 반환

-스택 객체 삭제 순서는 선언 및 생성 순서와 반대. 객체로 된 데이터 멤버도 똑같이 적용된

-스마트 포인터를 사용하지 않은 힙 객체는 자동으로 삭제되지 않는다.

	8.3.3 객체에 대입하기

-복제(copy)는 객체 초기화 때만 적용되는 표현. 덮어쓸 때는 대입(assign)

-대입 연산자는 복제 대입, 이동 대입

-C++에서 대입 연산자 자동 생성

1. 대입 연산자 선언 방법:
 // SpreadsheetCell& operator=(const SpreadsheetCell& rhs);

2. 대입 연산자 정의 방법:
 
 -자기 대입 반드시 고려

-컴파일러 생성 대입 연산자 명시적 디폴트 및 삭제 가능.

	8.3.4 컴파일러가 만들어주는 복제 생성자와 복제 대입 연산자

-C++11; 사용자 선언 복제 대입 연산자, 소멸자 있으면 -> 컴파일러 복제 생성자 자동 생성x. // 원하면 명시적 디폴트 선언

-C++11; 사용자 선언 복제 생성자, 소멸자가 있으면 -> 컴파일러 복제 대입 연산자 자동 생성x. // 원하면 명시적 디폴트 선언

	8.3.5 복제와 대입 구분하기

1. 리턴값이 객체인 경우:

-값으로 리턴 시 복제 생성자와 대입 연산자의 오버헤드는 컴파일러마다 다르게 처리가능

-오버헤드가 크다면 리턴값 최적화(ReturnValue Optimization, RVO) 또는 복제 생략(Copy elision)으로 최적화

2. 복제 생성자와 객체 멤버:

-컴파일러 생성 복제 생성자는 객체에 담긴 객체의 복제 생성자를 재귀적으로 호출.

	9. 클래스와 객체 마스터 하기

	9.1 friend

-스탠드얼론(standalone)(멤버가 아닌 독립) 함수도 클래스 프렌드 가능

-프렌드 지정은 반드시 접근할 클래스 안에서.

-프랜드는 캡슐화 원칙을 깬다. 꼭 필요할 때만 사용.

	9.2 객체에 동적 메모리 할당하기

* 최신 C++에서는 절대로 일반 포인터를 사용하면 안 된다.

-객체의 메모리 요구량을 모른다면 메모리 동적 할당. 

-동적 할당 시 메모리 해제, 객체 복제 처리, 객체 대입 연산 처리 등 문제 발생

	9.2.2 소멸자로 메모리 해제하기

-객체 안 동적 할당 메모리 소멸자에서 해제하는 것이 좋다. 

-소멸자는 익셉션을 발생하지 않기 때문에 기본적으로 noexcept 적용

* 아무런 익셉션도 던지지 않는 함수 앞에는 noexcept 키워드를 붙인다.

	9.2.3 복제와 대입 처리하기

-컴파일러 생성 기본 타입 복제 생성자나 대입 연산자는 비트 단위 복제(bitwise copy), 얕은 복제(shallow copy) 또는 대입 적용.

* 클래스에 동적 할당 메모리가 있다면 이를 깊은 복제로 처리하도록 복제 생성자와 대입 연산자를 직접 정의해야 한다.

-포인터 대입 처리 시 복제 후 맞바꾸기 (copy-and-swap) 적용

-복제 후 맞바꾸기 패턴 swap() 함수에서 절대로 익셉션을 던지면 안 된다. noexcept 지정.

-우변의 복제본(temp) 생성 및 *this와 교체 -> 익셉션 안정성 상승

-복제 후 맞바꾸기:
 1. 임시 복제본 생성.
 2. swap() 함수로 현재 객체와 임시 복제본 교체.
 3. 임시 객체 제거.

* C++는 복제뿐만 아니라 이동 의미론도 지원한다. 이를 사용하려면 이동 생성자와 이동 대입 연산자를 정의해야 한다. 그러면 특정 상황에서 성능을 높일 수 있다.

	9.2.4 이동 의미론으로 이동 처리하기

-원본 객체는 정상적이지만 미확정된 상태로 남게 된다. 이러한 원본 객체의 데이터 멤버는 대부분 널 값으로 초기화 -> 소유권 이전

1. 우측값 레퍼런스

-함수 매개변수에 &&를 붙여서 우측값 레퍼런스로.

-리터럴은 우측값 레퍼런스 버전 호출

-std::move(): 좌측 값을 우측값으로 캐스팅 -> 우측값 레퍼런스 버전 함수 호출 유도 가능.

-이름 있는 변수는 좌측값. 따라서 우측값 레퍼런스 타입 매개변수는 좌측값. 

-우측값 레퍼런스 매개변수를 다른 함수에 우측값으로 전달하려면 std::move()를 이용하여 좌측값을 우측값으로 캐스팅.

* 우측값 레퍼런스 매개변수는 타입이 우측값 레퍼런스이더라도 매개변수 자체는 이름이 있기 때문에 좌측값이라는 점에 주의한다.

2. 이동 의미론 구현 방법:

-이동 생성자와 이동 대입 연산자를 noexcept로 지정 필수.

-p.372

-이동 의미론은 원본 객체를 삭제할 때만 유용

-이동 생성자와 이동 대입 연산자도 명시적 삭제, 디폴트로 만들 수 있다.

-클래스에 복제 생성자, 복제 대입 연산자, 이동 대입 연산자, 소멸자를 직접 선언하지 않았다면 컴파일러 디폴트 이동 생성자 생성.

-클래스에 복제 생성자, 이동 생성자, 복제 대입 연산자, 소멸자를 직접 선언하지 않았다면 컴파일러 디폴트 이동 대입 연산자 생성.

* 클래스에 동적 할당 메모리를 사용하는 코드를 작성했다면 소멸자, 복제 생성자, 이동 생성자, 복제 대입 연산자, 이동 대입 연산자를 반드시 구현한다. 이를 5의 규칙(Rule of Five)이라 한다.

-데이터 멤버가 객체라면 std::move()로 객체를 이동

-데이터 맴버 추가 대비: 이동 생성자와 이동 대입 연산자를 디폴트 생성자와 swap() 함수로 구현한다.

-이동 생성자 디폴트 생성자를 위임 호출. 그 후 디폴트 생성자가 만든 *this를 원본 객체와 맞바꾼다.

-이동 대입 연산자는 rhs로 이동 생성으로 로컬 인스턴스 생성 후 그 로컬 인스턴스를 *this와 맞바꾼다.

-이동 의미론으로 swap 함수 구현하기:

 -표준 라이브러리 std::swap()이 이렇게 구현됐다. // p.378

	9.2.5 영의 규칙

-영의 규칙(Rule of zero): 다섯 가지 특수 멤버 함수를 구현할 필요가 없도록 디자인하는 것

* 최신 C++로 작성할 때는 0의 규칙을 적용한다.

	9.3 메서드의 종류

	9.3.1 static 메서드

-클래스 단위로 적용되는 메서드: static(정적, 스태틱) 메서드

-static 메서드는 this 포인터 비소유. non-static 멤버에 접근 불가

-static 메서드는 private static, protected static 멤버만 접근 가능. 

-같은 클래스 안에서는 static 메서드를 일반 함수처럼 호출 가능. 

-클래스 밖 호출 시 스코프 지정 연산자(::) 필요.

	9.3.2 const 메서드

-const 객체 사용 시 const 메서드만 호출할 수 있다.

-const는 메서드 프로토타입의 일부분

-static 메서드에 const 키워드를 붙이는 것은 무의미.

-메서드에 const 키워드 -> 그 메서드 안에서 각 데이터 멤버에 대한 const 레퍼런스를 가진 것처럼 행동.

-객체를 const로 선언하지 않음 -> const, non-const 메서드를 모두 호출 가능
 const로 선언 -> const 메서드만 호출 가능

1. mutable 데이터 멤버:

-의미상으로는 const인 데이터 멤버를 변경하는 경우 -> mutable로 선언

	9.3.3 메서드 오버로딩

-리턴 타입에 대한 오버로딩은 지원 x.

1. const 기반 오버로딩:

-const를 기준으로 오버로딩 가능.

-const 버전과 non-const 버전의 코드 중복 -> const-cast() 패턴 적용(non-const 버전에서 const버전 호출 후 const-cast. C++17에서 추가된 std::as_const활용). // p.384

2. 명시적으로 오버로딩 제거하기:

-delete로 오버로딩 메서드 명시적 삭제 가능.

	9.3.4 인라인 메서드

-메서드 호출을 곧바로 구현(정의) 코드로 작성하는 방법: 인라이닝(inlining)

-컴파일러는 inline이란 키워드를 단지 참고만 한다.

-인라인 메서드 호출 코드는 정의 코드 접근이 가능해야 함 ->  인라인 메서드 프로토타입과 구현 코드를 헤더 파일에 작성

* 고급 C++ 컴파일러는 inline으로 선언하지 않거나 헤더 파일에 정의하지 않아도 함수나 메서드의 크기가 작으면 자동으로 인라인으로 처리한다.

	9.3.5 디폴트 인수

-디폴트 인수는 메서드 선언 코드에서만 지정 가능

-디폴트 인수로 가능한 기능을 메서드 오버로딩으로도 구현 가능

	9.4 데이터 멤버의 종류

	9.4.1 static 데이터 멤버

-static 데이터 멤버는 전역 변수와 비슷하지만 자신이 속한 클래스 범위를 벗어날 수 없다.

-static 클래스 멤버를 정의하면 소스 파일에서 이 멤버에 대한 공간을 할당해야 한다. 주로 해당 클래스 정의 소스 파일에서 처리. 

-기본적으로 0으로 초기화. static 포인터는 nullptr로 초기화

-size_t Spreadsheet::sCoutner = 0; 스코프 지정 연산자를 제외하면 전역 변수를 선언할 때와 같다. // p.389

-C++17부터 static 멤버를 inline 선언 가능 -> 소스 파일 공간 할당 불필요. // static inline size_t sCounter = 0;

-static 멤버 외부 접근 -> static get/set 메서드 구현.

	9.4.2 const static 데이터 멤버

-특정 클래스에만 적용되는 상수 -> static const 데이터 멤버

-정수 및 열거 타입 static const 데이터 멤버는 인라인 지정 없이 선언과 동시에 초기화 가능

	9.4.3 레퍼런스 데이터 멤버

-서로에 대한 참조가 필요한 순환 참조 -> 헤더 파일 중 어느 한 곳에 포워드 선언(forward declaration)

-초기화 후 레퍼런스가 가리키는 객체 변경 불가능.

	9.4.4 const 레퍼런스 데이터 멤버

-const 레퍼런스에서 non-const 메서드를 호출하면 컴파일 에러

	9.5 중첩 클래스

-중첩 클래스, 구조체(struct), 타입 엘리어스(typedef), 열거 타입(enum) 선언 가능. 스코프는 모두 선언된 클래스

-코드가 길어지지 않게 중첩 클래스를 선언만 하고 정의 코드는 따로 작성

	9.6 클래스에 열거 타입 정의하기

-p.398

	9.7 연산자 오버로딩

-컴파일러는 맞는 operator를 찾을 때 정확한 타입 변환 방법도 탐색.

-암시적 변환을 금지하려면 생성자 앞에 explicit 키워드

-explicit 키워드는 정의 코드에서만 지정 가능. 인수를 하나만 지정해서 호출할 수 있는 생성자에만 적합.

-묵시적 변환은 성능 하락 야기. 항상 임시 객체를 생성하기 때문

-연산자를 전역 함수로 오버로딩하려면 헤더 파일에 선언해야 한다.

* C++에서는 연산자 우선순위를 바꿀 수 없다. 사용자 정의 연산자는 구체적인 동작만 정의 가능. 또한 C++는 새로운 연산자 기호를 정의 및 인수 개수를 변경 불허.

	9.7.2 산술 연산자 오버로딩

-operator/를 처리할 때는 0으로 나누지 않도록 주의.

-축약형 연산자는 기존 객체를 변경 하기에 기본 연산자 오버로딩과 다름. 또한 대입 연산자처럼 수정된 객체에 대한 레퍼런스를 생성.

-축약형 산술 연산자는 좌변에 반드시 객체 -> 전역 함수가 아닌 메서드로 구현

-일반 버전과 축약 버전을 모두 정의 시 코드 중복을 피하도록 축약형을 기준으로 일반 버전 구현// p.406

	9.7.3 비교 연산자 오버로딩

* 부동소수점끼리 비교 시 정밀도에 따른 오차 범위 고려 요망 -> 입실론 테스트(epsilon test) 적용

-==와 < 구현 뒤 이를 바탕으로 나머지 비교 연산자를 구현하면 간편

	9.7.4 연산자 오버로딩을 지원하는 타입 정의하기

-연산자 오버로딩 요점 -> 클래스를 기본 타입에 가깝게 정의하는 것

	9.8 안정적인 인터페이스 만들기

-핌플 이디엄( pimpl idiom, private implmentation idion 또는 브릿지 패턴(bridge pattern):
 인터페이스 클래스와 구현 클래스 별도 정의. 서로 똑같은 public 메서드를 제공하되 구현 클래스 객체에 대한 포인터를 갖는 데이터 멤버 하나만 정의

-인터페이스 클래스 메서드는 구현 클래스 객체에 있는 동일한 메서드를 호출하도록 구현. 컴파일 의존성 감소.

* 인터페이스 클래스를 안정적으로 구현하면 빌드 시간 단축.

	10.1.1 클래스 확장하기

-Base 포인터로 Derived 클래스 메서드 호출 불가. 컴파일러는 여전히 그 객체의 타입을 Base로 해석.

-메서드도 기본적으로 private로 선언. 외부 공개 시 별도로 public 선언

-C++ 클래스 정의 시 final 키워드 -> 상속 불가. 

	10.1.2 메서드 오버라이딩

-베이스 클래스에서 virtual 키워드 선언 메서드만 오버라이드 가능

-베이스 클래스에 나온 것과 똑같이 선언 후 맨 뒤에 override 키워드

-virtual 지정 시 모든 파생 클래스에서도 virtual. 파생 클래스에서 virtual 키워드를 제거하더라도.

-파생 클래스를 인식해서 적합한 메서드를 호출하는 기능은 포인터나 레퍼런스 객체에만 적용.

* 파생 클래스 객체를 업캐스팅 시 클래스 고유의 정보가 사라짐 -> 슬라이싱(slicing) // 베이스 클래스 포인터나 레퍼런스로 참조할 때 유지.

-오버라이드할 메서드는 항상 virtual로 선언

-virtual로 선언되지 않은 오버라이딩은 그저 다른 클래스 범위의 새로운 메서드가 생성된 것

* virtual 미선언 메서드는 오버라이드 시 베이스 클래스 정의 숨김.

-virtual 메서드의 내부 작동 방식:

 -클래스를 컴파일 -> 바이너리 객체가 생성된다.
 -컴파일러는 비virtual 선언 메서드 호출 부분을 컴파일 시간에 결정된 타입의 코드로 교체 -> 정적 바인딩(static binding) 이른 바인딩(early binding)

 -virtual 선언 시 vtable(가상 테이블)를 통해 적합한 구현 코드 호출.
 -virtual 메서드가 하나 이상 정의된 클래스마다 vtable이 하나씩. 클래스 객체마다 vtable에 대한 포인터 소유
 -virtual 메서드의 구현 코드에 대한 포인터는 vtable에 담겨 있다. 
 -객체에 대해 메서드 호출 ->  vtable로 적합한 버전의 메서드 실행 -> 동적 바인딩(dynamic binding) 또는 늦은 바인딩(late binding)

-virtual 키워드는 vtable에 대한 오버헤드를 줄이기 위해 만들어졌다. virtual 메서드를 호출 시 포인터 역참조 오버헤드 발생

-객체마다 메모리 오버헤드도 발생 -> vtable 메모리 공간

-클래스 final 선언을 제외한 나머지 경우는 항상 소멸자를 virtual로 선언하는 것이 좋다.

-메서드도 final로 지정 가능

	10.3 부모를 공경하라

-부모 클래스가 있다면 부모 클래스를 먼저 초기화

-C++는 부모 클래스에 디폴트 생성자가 있으면 자동 호출. 

-부모 클래스에 디폴트 생성자가 없거나 다른 생성자를 사용할 때는 생성자 이니셜라이저로 생성자 체인 엮기 가능.

* 컴파일러가 생성한 디폴트 소멸자는 virtual이 아니므로 최소한 부모 클래스에서만이라도 virtual 소멸자를 따로 정의하거나 명시적으로 default로 지정한다.

	10.3.3 부모 클래스 참조하기

-C++ 이름 처리 순서: 로컬 스코프 -> 클래스 스코프

* 마이크로소프트 비주얼 C++에서 제공하는 __super(언더스코어 두개) 키워드를 사용해서 부모 클래스 참조 가능.
  // return __super::getTemperature() + "";

	10.3.4 업캐스팅과 다운캐스팅

-베이스 클래스 타입으로 파생 클래스를 참조 -> 업캐스팅(upcasting).

* 업캐스팅할 때 슬라이싱이 발생하지 않게 하려면 베이스 클래스를 포인터나 레퍼런스로 접근한다.

-베이스 클래스를 파생 클래스로 캐스팅 -> 다운캐스팅(downcasting). 다운캐스팅은 객체가 파생 클래스에 속한다고 보장할 수 없다.

-다운캐스팅은 완벽히 통제할 수 있는 상황에서만

-다운캐스팅을 할 때는 반드시 dynamic_cast()를 호출. 이 함수는 캐스팅이 잘못됐다면 처리 x

-dynamic_cast()는 vtable이 있는 객체에만 적용 가능

-포인터 변수에 대해 dynamic_cast()가 실패하면 포인터의 값이 nullptr.

-레퍼런스에 대해 dynamic_cast()가 실패하면 std::bad_cast 익셉션 발생

* 다운캐스팅은 꼭 필요할 때만 사용하고, 반드시 dynamic_cast()를 활용한다.

	10.4 다형성을 위한 상속

-순수 가상 메서드(pure virtual method)란 클래스 정의 코드에서 명시적으로 정의하지 않는 메서드다. 

-순수 가상 메서드가 하나라도 정의된 클래스 -> 추상 클래스(abstract class).

* 클래스를 파생 클래스가 아닌 다른 코드에서 직접 인스턴스를 생성하지 못하게 하려면 추상 클래스로 만든다.

	10.4.4 파생 클래스 구현하기

-순수 가상 메서드 중 파생 클래스에 구현하지 않은 것이 있으면 파생 클래스도 추상 클래스

	10.4.6 나중에 대비하기

-계층화 구현이 이롭다.

-형제 클래스끼리 변환하는 기능은 변환 생성자(converting constructor 또는 타입 생성자, typed constructor)를 추가. 형제 클래스 객체 레퍼런스를 인수로 받는다.

	10.5 다중 상속

	10.5.2 이름 충돌과 모호한 베이스 클래스

-다중 상속의 이름 충돌 해결 -> dynamic_cast()로 명시적 업캐스팅, 스코프 지정 연산자

-아니면 using 문으로 상속할  버전 구체적으로 지정

-데이터 멤버에 대해서도 모호함 발생 가능.

-다이아몬드 형태 계층 -> 최상단 클래스를 순수 가상 메서드로만 구성. 

	10.6 상속에 관련된 미묘하면서 흥미로운 문제들

1. 리턴 타입 변경하기:

-베이스 클래스의 리턴 타입이 포인터나 레퍼런스면 오버라이드 시 리턴 타입을 그 클래스의 파생 클래스에 대한 포인터나 레퍼런스 타입으로 변환 가능 -> 공변 리턴 타입(covariant return type)

-템플릿에 대해서는 리턴 타입을 오버라이딩할 수 없다.

2. 메서드 매개변수 변경하기:

* 파생 클래스에서 베이스 클래스와 이름은 같고 매개변수는 다른 메서드를 만들 이유는 별로 없다.

	10.6.2 생성자 상속

-using 키워드로 베이스 클래스 정의 메서드를 지정하는 방법은 생성자에도 적용 가능.

-Base생성자로 Derived 객체 생성 -> Derived 클래스에서 Base 생성자 using으로 명시적 상속. // using Base::Base

-using 지정 시 부모 클래스의 디폴트 생성자 제외 모든 생성자 상속.

-베이스 클래스의 생성자 중 일부만 상속할 수는 없다.

-여러 베이스 클래스에서 매개변수 목록이 같은 생성자는 상속 불가.

	10.6.3 메서드 오버라이딩의 특수한 경우

1. 베이스 클래스 메소드가 static인 경우:

-C++에서는 static 메서드를 오버라이드 불가

-메서드에 static과 virtual 동시에 지정 불가.

-static 메서드는 this포인터도 없고 객체에 접근 불가

-static 메서드 호출 시 컴파일 시간 지정 타입만 보고 호출할 메서드를 결정

2. 베이스 클래스 메서드가 오버로드된 경우:

-베이스 클래스의 다양한 오버로드 메서드 중 한 버전만 오버라이드하면 다른 버전의 메서드는 가려짐. 

-오버라이드하고 싶은 버전은 하나인데 나머지 메서드가 가려지는 문제를 해결하려면 using 키워드를 사용. 

-using 구문이 있으면 나머지 버전도 그대로 받아 씀 -> 디버그 난해

* 위와 같은 버그를 방지하려면 모든 버전을 명시적으로 오버라이드하거나 using 키워드를 적절히 활용한다.

3. private나 protected로 선언된 베이스 클래스 메서드:

-private나 protected 메서드도 오버라이드 가능. 접근 지정자는 메서드 호출 대상만 제한.

* 기존 클래스의 전반적인 골격은 그대로 유지한 채 특정한 기능만 변경할 때는 private와 protected 메서드를 오버라이드하는 것이 좋다.

4. 베이스 클래스 메서드에 디폴트 인수가 지정된 경우:

-파생 클래스와 베이스 클래스 지정 디폴트 인수가 서로 다를 수 있다. 

-C++에서 디폴트 인수는 상속되지 않는다.

* 디폴트 인수가 지정된 메서드를 오버라이드할 때는 파생 클래스에서도 반드시 디폴트 인수를 지정하고 기왕이면 값도 똑같이 지정하는 것이 좋다. 

5. 베이스 클래스 메서드와 접근 범위를 다르게 지정하는 경우:

* 베이스 클래스에서 public으로 선언한 메서드의 접근 범위는 완벽히 좁힐 수 없고, 또한 굳이 좁힐 일도 거의 없다.

* 구현 코드를 변경하지 않고 메서드의 접근 권한만 변경하고 싶다면 파생 클래스 정의에서 간단히 using 문으로 접근 범위만 원하는 종류로 바꾸면 된다.

	10.6.4 파생 클래스의 복제 생성자와 대입 연산자

-파생 클래스에서 복제 생성자를 명시적으로 정의하면 반드시 부모 클래스의 복제 생성자를 호출.

-파생 클래스에서 oeprator=을 오버라이드하면 부모 버전의 대입 연산자도 함께 호출해야 한다.

* 전문 C++ 프로그래머는 상속 계층에서 복제 기능을 구현할 때 흔히 다형성 버전의 clone() 메서드를 구현하는 기법을 사용한다.

	10.6.5 실행 시간 타입 정보

-실행 시간에 객체를 들여다보는 기능: RTTI(Real-Time Type Information, 실행 시간 타입 정보) ex) dynamic_cast, typeid

* typeid 연산자는 클래스에 vtable이 있을 때만 올바르게 작동한다. 또한 전달 대상 레퍼런스, const 타입 정보를 제거.

* 로깅, 디버깅 용도 외엔 typeid보다는 virtual 메서드로

	10.6.6 non-public 클래스 상속

-부모에 대한 접근 범위 일괄 축소는 대부분  잘못된 상속 관계 디자인

* non-public 클래스를 상속하는 경우는 매우 드물다. 따라서 굳이 이렇게 해야 한다면 구현할 때 각별히 주의한다.

	10.6.7 가상 베이스 클래스

-중복되는 부모 클래스는 가상 베이스 클래스로 해결. 하위 타입이 하나만 생성되기 때문

* 클래스 계층의 모호함을 방지하기 위한 좋은 방법은 가상 베이스 클래스를 사용하는 것이다.

	11. C++의 까다롭고 유별난 부분

	11.1 레퍼런스

-레퍼런스는 변수의 주소를 가져오거나 역참조 연산을 자동 수행하는 특수한 포인터라고 볼 수 있다.

	11.1.1 레퍼런스 변수

-이름 없는 값은 레퍼런스를 생성할 수 없다. const 값에 대해서는 가능

-임시 객체도 마찬가지다.

* 레퍼런스를 초기화하고 나면 레퍼런스가 가리키는 변수를 변경할 수 없고, 그 변수의 값만 바꿀 수 있다.

2. 포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터:

-레퍼런스에 대한 레퍼런스를 선언 불가

	11.1.3 레퍼런스 매개변수

-매개변수 타입이 레퍼런스 -> 인수 지정 시 그 인수의 레퍼런스가 함수로 전달

-일반 레퍼런스 변수 상수로 초기화 불가

-non-const 레퍼런스 전달 방식 함수의 인수로 상수를 전달 불가

1. 포인터를 레퍼런스로 전달하기:

-레퍼런스 타입 매개변수에 포인터를 전달하려면 -> 포인터를 역참조해서 레퍼런스로 '변환'

2. 레퍼런스 전달 방식과 값 전달 방식:

-값 전달 방식은 인수가 기본 타입, 수정할 필요가 없을 때만 사용. 나머지는 레퍼런스, const 레퍼런스 전달 방식

	11.1.4 레퍼런스 리턴값

-이동 의미론 지원 함수는 값 리턴도 효율적 처리

	11.1.6 레퍼런스와 포인터의 선택 기준

-포인터 사용 코드는 대부분 레퍼런스로 표현 가능

-메모리 소유권이 변수를 받는 코드에 있으면 -> (스마트)포인터로 표현 
 메모리 소유권이 변수를 받는 코드에 없다면 레퍼런스

* 포인터보다 레퍼런스를 사용하는 것이 좋다. 레퍼런스를 사용불가면 포인터

-결과를 매개변수로 전달하는 방식은 기피

	11.2.1 const 키워드

* const 변수가 복잡하게 선언됐을 때 쉽게 이해하는 방법은 오른쪽부터 왼쪽으로 읽는 것이다.

* 매개변수 전달 대상이 객체라면 기본적으로 const 레퍼런스로 선언. 변경할때만 const 생략

3. constexpr 키워드:

-상수 표현식(constexpr)은 컴파일 시간에 계산(평가, evaluate)된다.

-constexpr 적용 제약사항:
 -goto, try/catch, 미초기화 변수, non-literal 변수 등이 없어야 하고, 익셉션 던지기 불가.
 -리턴 타입 반드시 리터럴 타입
 -동적 요소 추가 불가

-사용자 정의 타입 상수 표현식 변수를 만들고 싶다면 constexpr 생성자 정의. 제약사항:
 -가상 베이스 클래스를 가질 수 없다.
 -생성자 본문 명시적 디폴트 지정, constexpr 함수 본문과 같은 요구사항 만족
 -모든 데이터 멤버를 상수 표현식으로 초기화

	11.2.2 static 키워드

2. static 링크:

-C++는 오브젝트 파일들을 링크 단계에서 연결. 

-외부 링크(external linkage): 다른 소스 파일에서 이름을 사용 가능
 내부 링크(internal linkage 또는 정적 링크, static linkage): 같은 파일에서만 가능

-함수나 전역 변수는 기본적으로 외부 링크. 선언문 앞에 static 키워드를 붙이면 내부 링크

-같은 함수 프로토타입을 여러 파일에 작성 가능. 

-전처리기는 #include 파일을 보고 헤더 파일에 나온 프로토타입을 소스 파일에 추가

-익명 네임스페이스(anonymous namespace)로 내부 링크 적용 가능.

* 내부 링크로 지정할 때는 static 키워드 보다는 익명 네임스페이스를 사용하는 것이 바람직하다.

-const와 typedef는 기본적으로 내부 링크 처리된다. extern을 붙이면 외부 링크

-extern 지정 시 선언문으로 취급. 따라서 정의하는 문장을 따로 작성 필요

-extern으로 선언하는 동시에 초기화해도 된다.

* 전역 변수는 사용하지 않는 것이 좋다. 코드가 커질수록 이해하기 힘들고 에러가 발생하기 쉽기 때문이다.

3. 함수 안의 static 변수:

-static의 다른 용도: 특정한 스코프 안에서만 값을 유지하는 로컬 변수를 생성.

-static 변수 불필요 코드 구조로 변경하는 것이 바람직.

* static 변수를 따로 만들어서 상태를 관리하지 말고, 상태를 객체 안에서 관리하게 만든다.

	11.2.3 비로컬 변수의 초기화 순서

-전역 변수와 static 클래스 데이터 멤버는 main() 시작 전 소스 파일 선언 순서대로 초기화. 

* 여러 소스 파일에 선언된 비로컬 변수의 초기화 순서는 C++ 표준에 정의돼 있지 않다.

	11.2.4 비로컬 변수의 소멸 순서

-비로컬 변수의 소멸 순서도 알 수 없다.

	11.3.1 타입 앨리어스

-타입 앨리어스: 기존 선언 타입에 다른 이름을 붙이는 것. // using IntPtr = int*;

-타입 앨리어스 정의 시 스코프 지정자(scope qualifier)도 포함 가능

	11.3.3 메서드와 데이터 멤버를 가리키는 포인터에 대한 타입 앨리어스

-클래스 데이터 멤버와 메서드 주소를 가져오는 기능도 정식 지원. 하지만 해당 객체의 문맥에서 포인터를 역참조 해야함:
 Employee employee;
 int (Employee::*methodPtr)() const = &Employee::getSalary;
 cout << (employee.*methodPtr)() << endl;

 Employee employee;
 using PtrToGet = int (Employee::*) () const;
 PtrToGet methodPtr = &Employee::getSalary;

* C++에서는 객체를 거치지 않고서도 static 데이터 멤버나 메서드 포인터를 역참조할 수 있다.

	11.3.4 typedef

* typedef보다는 타입 앨리어스를 사용

	11.3.5 캐스팅

-const_cast(), static_cast(), dynamic_cast(), reinterpret_cast()

1. const_cast():

-변수 const 속성 추가, 제거 시 사용.

-C++17 std::as_const() 헬퍼 메서드: <utility> 헤더 정의. 레퍼런스 매개변수를 const 레퍼런스로 변환. // as_const(obj) == const_cast<const T&>(obj)

2. static_cast():

-static_cast()는 언어 제공 명시적 변환 기능 수행

-다운 캐스팅할 때도 static_cast()를 사용 가능.

-static_cast()은 실행 시간에 타입 검사 x.

-static_cast()은 C++의 타입 규칙 불허 요소는 모두 할 수 없다

3. reinterpret_cast()

-reinterpret_cast()는 C++ 타입 규칙에서 불허라도 상황에 따라 캐스팅하는 것이 적합할 때 적용

-void*로 변환한 -> 원래 타입: reinterpret_cast(). 

-void* 포인터는 아무런 타입 정보가 없다. 그저 특정 메모리 지점 가리킴

* 포인터를 int타입으로 변환하거나 그 반대로 변환할 때도 reinterpret_cast() 사용할 수 있다.

4. dynamic_cast():

-dynamic_cast()는 같은 상속 계층끼리 캐스팅 시 실행 시간 타입 검사. 포인터나 레퍼런스를 캐스팅할 때 이용 가능.

-dynamic_cast()는 캐스팅 실패:
 포인터: 널 포인터 리턴 
 레퍼런스: std::bad_cast 익셉션

-static_cast(), reinterpret_cast()로도 상속 계층 하위 타입으로 캐스팅 가능. 차이점은 실행 시간에 타입 검사 수행 여부.

-실행 시간 타입 정보는 객체의 vtable에 저장 -> dynamic_cast()를 적용하려면 클래스에 virtual 메서드

	11.4 스코프

-이름 접근 시 가까운 스코프부터 시작하여 전역 스코프까지 검색. 못찾으면 정의되지 않은 심벌 에러(undefined symbol error)

	11.5 어트리뷰트

-어트리뷰트란 특정 벤더에서만 제공하는 정보나 옵션을 소스 코드에 추가하는 메커니즘

-C++11부터는 어트리뷰트를 모두 이중 대괄호를 이용하여  [[어트리뷰트]]와 같은 문법으로 표기하도록 표준화됐다.

-C++ 표준은 여섯 가지 어트리뷰트만 지원한다.

	11.5.1 [[noreturn]]

-함수가 호출한 측으로 제어를 리턴하지 않는다는 것.

	11.5.2 [[deprecated]]

-미지원 대상 지정 시 사용

-지원 중단 함수 사용 시 컴파일 에러 또는 경고 메시지

	11.5.3 [[fallthrough]]

-C++17부터

-switch 문에서 의도적으로 폴스루(fallthrough)를 적용하고 싶을 때 사용.

	11.5.4 [[nodiscard]]

-함수 호출 코드에서 리턴 값 미사용 시 경고 메시지 발생

	11.5.5 [[maybe_unused]]

-미사용 코드 경고 메시지를 출력 x

	11.6 사용자 정의 리터럴

-C++는 리터럴 직접 정의 기능 제공. 이러한 사용자 정의 리터럴은 반드시 언더스코어(_)로 시작. 언더스코어 다음 첫 문자는 반드시 소문자

-사용자 정의 리터럴은 리터럴 연산자(literal operator) 정의로 구현. 

-리터럴 연산자는 미가공 모드(raw mode)나 가공 모드(cooked mode)로 작동: 
 미가공 모드: 단순히 문자 나열로 취급
 가공 모드: 특정한 타입의 값으로 해석

-p.542

	11.7 헤더 파일

-헤더 파일 중복, 순환 참조 주의

-인클루드 가드(include guard) 메커니즘으로 중복 정의 회피:
 #ifndef LOGGER_H
 #define LOGGER_H
 #endif
 // #pragma once로 대체

-참조해야 하는 클래스의 헤더 파일을 인클루드 불가: 전방 선언(포워드 선언, forward declaration)으로 해결.

-헤더 파일에 다른 헤더 파일을 인클루드 < 전방 선언. 컴파일 의존성 하락

-C++17; 헤더 파일 존재 여부 -> __has_include("파일명"),  __has_include(<파일명>) 전처리 상수. 존재하면 1, 아니면 0

	11.8.1 가변 길이 인수 리스트

-... 매개변수는 반드시 <cstdarg> 정의 매크로로 접근

-va_list 타입 변를 선언 뒤 va_start를 호출해서 초기화. 

-va_start()의 두 번째 매개변수는 반드시 매개변수 리스트의 이름 있는 변수 중에서 오른쪽 끝에 있는 것. 

-가변 길이 인수 리스트를 가진 함수라면 반드시 이름 있는 매개변수가 한 개 이상 있어야 한다.

-마지막엔 va_end()를 호출해서 가변 길이 인수 리스트에 대한 접근 종료. 

-va_start()를 호출했다면 반드시 이에 대응되는 va_end()를 호출해서 함수 스택 상태 일관성 유지

-인수에 직접 접근하고 싶다면 va_arg() 매크로. va_list와 해석할 타입을 인수로 받는다. 

-인수 리스트의 끝은 명시적 지정외엔 알 방법이 없다.

-C 스타일 가변 길이 인수 리스트는 매개변수 개수, 인수 타입을 알 수 없다.

* C 스타일 가변 길이 인수 리스트는 가능하면 사용하지 않는 것이 좋다.

	11.8.2 전처리 매크로

-C++ 전처리기로 간단한 함수 형태의 매크로(macro)를 정의할 수 있다.

-매크로는 C 언어에서 물려받은 기능으로, 타입 검사를 하지 않고 이를 호출한 모든 부분을 전처리기가 텍스트 바꾸기를 하듯 교체한다는 점을 제외하면 inline 함수와 비슷하다.

-매크로를 잘못 사용하면 성능에 지장을 줄 수 있다.

-매크로는 디버깅할 때도 문제가 된다. 전처리기는 찾아서 바꾸는 방식으로 처리하기 때문에 프로그래머가 볼 때와 컴파일러나 디버거가 볼 때 코드 형태가 서로 다르다. 그래서 매크로 대신
 인라인 함수를 사용하는 것이 바람직하다.

* 컴파일러는 대부분 전처리기를 거친 소스 코드를 다른 파일이나 표준 출력으로 출력하는 기능을 제공한다. 이 결과를 이용해 전처리기의 코드 처리 방식을 파악할 수 있다.

	12.2 클래스 템플릿

-제네릭 프로그래밍의 가장 큰 장점은 타입 안전성

-클래스 정의 코드 안: Grid == Grid<T>. 
 클래스 정의 밖: 반드시 Grid<T>

-템플릿에서 메서드 정의 시 반드시 템플릿 지정자(template <typename T>) 명시.

* 템플릿 정의 시 메서드 구현 코드를 헤더 파일에. 컴파일러가 템플릿 인스턴스 생성 전 클래스 정의 전체를 알게 하기 때문.

-템플릿 인스턴스화로 객체를 힙에 동적 생성 가능

	12.2.3 컴파일러에서 템플릿을 처리하는 방식

-컴파일러는 템플릿 메서드 정의 코드의 문법 검사만 하고 컴파일은 x. 어떤 타입을 사용할지 알 수 없기 때문.

-컴파일러는 항상 제네릭 클래스의 모든 가상 메서드에 대한 코드 생성. 하지만 virtual 비선언 메서드는 특정 타입에 대해 호출하는 메서드만 컴파일 ->
 선택적 인스턴스화(selective instantiation)

-타입 독립 코드를 작성하려면 적용 타입 고려 필요.

-템플릿을 인스턴스화할 타입이 그 템플릿에 정의된 모든 연산을 적용할 수 없다면 -> 선택적 인스턴스화

	12.2.4 템플릿 코드를 여러 파일로 나누기

1. 헤더 파일에 템플릿 정의하기

-메서드 정의 코드를 헤더 파일에 함께 적는 방법

-템플릿 메서드 정의 코드를 가진 헤더 파일을 클래스 정의를 담은 헤더 파일에서 #include 문으로 불러오는 방법. 이때 메서드 정의가 담긴 헤더를 반드시 클래스 정의 코드 뒤에

2. 소스 파일에 템플릿 정의하기

-소스 파일을 추가하는 #include 문을 작성. 그 소스 파일이 프로젝트 빌드 목록에 추가되지 않도록 주의.

-클래스 템플릿을 특정한 타입에만 적용하게 만들고 싶다면 다음에 나온 테크닉을 적용한다:
 1. 템플릿을 헤더 파일에 작성(메서드 정의, #include문 없이)
 2. 정의 코드가 담긴 .cpp 파일을 빌드 목록에 추가
 3. .cpp파일의 마지막에 템플릿에서 허용하는 타입으로 명시적으로 인스턴스화 ex) template class Grid<int>; template class Grid<double>;

* 명시적 클래스 템플릿 인스턴스화(explcit class template instantiation) 기법을 적용 시 미사용이어도 그 템플릿에 있는 모든 메서드를 컴파일 한다.

	12.2.5 템플릿 매개변수

1. 비타입 템플릿 매개변수:

-정수 계열 타입, 열거 타입, 포인터, 레퍼런스, std::nullptr_t 등만 비타입 매개변수로 사용 가능

-C 스타일 배열은 이동 의미론을 지원 x.

* 비타입 템플릿 매개변수는 인스턴스화 된 객체의 타입에 포함. // Grid<int, 10, 10>과 Grid<int, 10, 11>은 서로 다른 타입이다.

2. 타입 매개변수의 디폴트값

-template<typename T = int, size_t WIDTH = 10, size_t HEIGHT = 10>

-템플릿 매개변수를 모두 생략하더라도 꺾쇠괄호는 반드시 적어야 한다.

3. 생성자에 대한 템플릿 매개변수 추론 과정:

-C++17부터 클래스 템플릿 생성자 인수를 통한 템플릿 매개변수 추론 기능 추가.

-템플릿 매개변수 추론 규칙 사용자 정의 가능. // p.577 // SpreadsheetCell cell(myString); // SpreadsheetCell(const char *) -> SpreadsheetCell<std::string>;

-위의 문장은 반드시 클래스 정의 밖에. 단, 네임스페이스는 같게.
 explict 템플릿_이름(매개변수 목록) -> 추론된_템플릿;

	12.2.6 메서드 템플릿

-메서드 템플릿은 클래스 템플릿에 복제 생성자와 대입 연산자를 정의할 때 유용.

* 가상 메서드와 소멸자는 메서드 템플릿으로 만들 수 없다.

	12.2.7 클래스 템플릿의 특수화

-특정한 경우에 대해서만 템플릿을 다르게 구현하는 것: 템플릿 특수화(template specialization).

-템플릿 특수화를 적용할 때 원본 템플릿도 반드시 참조할 수 있어야 한다 -> include 문 추가

-특수화의 대표적인 장점: 특수화가 사용자에게 드러나지 않음.

-특수화 구현의 경우 메서드 앞에 template<> 구문 불필요.

	12.2.8 클래스 템플릿 상속하기

-클래스 템플릿도 상속 가능. 

-템플릿을 상속한 파생 클래스도 템플릿이어야 한다. 

-인스턴스화한 템플릿 클래스를 상속할 때는 파생 클래스가 템플릿이 아니어도 된다.

-템플릿 파생 클래스는 부모 클래스 즉시 상속 x. 인스턴스화할 때마다 그 타입에 대해 부모 클래스 인스턴스화 클래스를 상속하는 것.
 template<typename T>
 class GameBoard : public Grid<T> {};

* 구현을 확장하거나 다형성을 지원하려면 상속을 사용하고, 특정한 타입에 대한 템플릿 구현을 커스터마이즈하고 싶다면 특수화를 사용한다.

	12.2.10. 앨리어스 템플릿

-타입 매개변수 중 일부만 지정 가능: 앨리어스 템플릿(alias template)
 template <typename T1>
 using OtherName = MyTemplateClass<T1, double>;

	12.3 함수 템플릿

-템플릿 함수는  두 가지 호출 방식: 꺾쇠괄호 안에 타입 매개변수 명시적 지정, 타입 생략 후 매개변수 추론.

-함수 템플릿도 비타입 매개변수 사용 가능.

	12.3.1 함수 템플릿의 특수화

-함수 템플릿도 특수화 가능. // template<> size_t Find<const char*>(...)

	12.3.2 함수 템플릿 오버로딩

-함수 템플릿도 일반 함수처럼 오버로딩 가능.

-템플릿 특수화 버전과 일반 함수 버전 동시 사용 가능.

-컴파일러는 항상 템플릿 버전보다 일반 함수 버전을 우선시. 

-템플릿 인스턴스화 명시적 지정 시 컴파일러는 무조건 템플릿 버전을 선택.

	12.3.5 함수 템플릿의 리턴 타입

-C++14부터 컴파일러의 함수 리턴 타입 자동 추론 옵션 추가.
 // decltype(auto) C++14이후
 // template<typename T1, typename T2> auto add(const T1& t1, const T2& t2) -> decltype(t1 + t2) C++14이전

	12.4 변수 템플릿

-C++14부터 변수 템플릿(variable template)도 제공.
 //template<typename t>
   constexpr T pi = T(3.14);

 float piFloat = pt<float>;

	13.1.1 스트림의 정체

-cin: 입력 스트림. '입력 콘솔'에 들어온 데이터를 읽는다.
 cout: 버퍼를 사용하는 출력 스트림. 데이터를 '출력 콘솔'에 쓴다.
 cerr: 버퍼를 사용하지 않는 출력 스트림. 데이터를 '에러 콘솔'에 쓴다. 에러 콘솔과 '출력 콘솔'이 같을 때가 많다.
 clog: 버퍼를 사용하는 cerr

-GUI 애플리케이션은 콘솔을 잘 사용하지 않는다. 그래서 cout으로 출력한 내용을 볼 수 없다.

-라이브러리를 작성 시 cout, cin, cerr, clog가 없다고 가정하는 것이 좋다. 라이브러리를 사용 앱에 콘솔이 없을 수도 있기 때문.

* 입력 스트림은 항상 입력 장치와 연결. 출력 스트림은 항상 출력 장치와 연결.

-스트림에서 데이터는 현재 가리키는 위치(current position)와 함께 담겨 있다.

	13.1.2 스트림의 출발지와 목적지

-스트림 개념은 데이터를 입출력하는 객체라면 어떤 것에도 적용 가능

	13.1.3 스트림을 이용한 출력

1. 출력 스트림의 기초:

-출력 스트림은 <ostream> 헤더 파일에 정의. 

-<iostream> 헤더에는 입출력 스트림이 모두 정의.

-<< 연산자는 스트림 레퍼런스 리턴 -> << 연산자에 연달아 적용 가능

-'\n'는 단순히 새 줄 시작. endl은 버퍼를 비우기(flush)도 한다. 

-버퍼를 비우는 연산이 너무 많으면 성능 하락.

2. 출력 스트림에서 제공하는 메서드:

-put()과 write()는 저수준 출력 메서드. 데이터 포매팅, 가공하지 않고 출력.

-스트림 버퍼를 비우는 조건:
 -endl과 같은 경곗값에 도달
 -스트림이 스코프를 벗어나 소멸될 때
 -출력 스트림에 대응되는 입력 스트림으로부터 요청이 들어올 때
 -스트림 버퍼가 가득 찼을 때
 -명시적으로 flush() 호출

* 모든 출력 스트림이 버퍼를 사용하는 것은 아니다.

3. 출력 에러 처리하기:

-good()은 스트림이 사용 가능 상태인지 확인. // if (cout.good())

-bad() 리턴 값이 true -> 심각한 에러 발생

-fail()로 최근 수행 연산 오류 발생 여부 확인 가능. 

-good() == (!fail() && !eof())

-스트림 에러 상태 초기화: clear()

4. 출력 매니퓰레이터:

-매니퓰레이터(manipulator 객체로 스트림 동작을 변경 가능

-스트림마다 매니퓰레이터에 대응되는 메서드를 제공. ex) precision()

	13.1.4 스트림을 이용한 입력

1. 입력 스트림의 기초:

-cin을 사용하면 cout 버퍼를 즉시 비운다.

2. 입력 에러 처리하기:

-입력 스트림 에러는 대부분 읽을 데이터가 없을 때 발생. 가장 흔한 해결 방법은 조건문으로 스트림 상태를 확인:
 // while (cin >> ch) { ... }

-입력 스트림도 good(), fail(), eof() 호출 가능

-항상 스트림 상태를 검사하는 습관 들이기.

3. 입력 메서드:

-get() 메서드는 스트림 데이터를 저수준으로 읽는다. 

-unget() 호출 시 스트림이 한 칸 앞으로 거슬러 올라간다. 이전에 읽은 문자를 스트림으로 되돌린다.

-unget() 연산의 성공 여부는 fail()로 확인한다.

-putback()도 입력 스트림을 한 문자만큼 되돌린다. 차이는 putback()은 되돌릴 문자를 인수로 받는다.
 // cin.putback('e');

-peek()은 get()을 호출할 때 리턴될 값을 미리 보여준다.

-getline()은 입력 스트림에 새 EOL이 나올 때까지 문자 한 줄을 읽는다. EOL 문자는 스트링에 담기지 않는다.

	13.2 스트링 스트림

-스트링 스트림이란 string에 스트림 개념을 추가한 것.

-string에 데이터를 쓸 때는 std::ostringstream, 읽을 때는 std::istringstream. <sstream> 헤더 파일.

-ostringstream과 istringstream은 각각 ostream과 istream을 상속 -> 기존 입출력 스트림처럼 다룰 수 있다.

-ostringstream에 str() 메서드 호출, 스트림 전체를 string 객체로 변환한 뒤 콘솔에 쓴다.

* 객체를 스트링처럼 일렬로 나열하는 것을 마셜링(marshalling)이라 부른다.

-스트링 스트림은 매니퓰레이터와 로케일 지원 -> 포맷을 융통성 있게 다룬다.

	13.3 파일 스트림

-파일은 스트림 개념과 일치. 항상 현재 위치를 추적하기 때문.

-std::ofstream과 std::ifstream. <fstream> 헤더 파일.

-파일시스템을 다룰 때는 에러 처리가 특히 중요.

-파일 스트림 모드:
 -ios_base::app, ios_base::ate, ios_base::binary, ios_base::in, ios_base::out, ios_base::trunc

-ifstream는 ios_base::in 모드 디폴트. ofsteram은 ios_base::out 모드 디폴트.

-ifstream과 ofstream 소멸자는 자동으로 close() 호출.

	13.3.1 텍스트 모드와 바이너리 모드

-파일 스트림을 생성 시 ios_base::binary 플래그를 지정하면 파일을 바이너리 모드로 연다.

-바이너리 모드로 열면 지정 바이트 단위 만큼만 쓴다. 읽을 때는 읽은 바이트 수를 리턴.

	13.3.2 seek()과 tell() 메서드로 랜덤 엑세스하기

-seek(): 입력, 출력 스트림에서 현재 위치를 원하는 지점으로 옮긴다. 

-입력 스트림 seek(): seekg()
 출력 스트림 seek(): seekp()

-seekg()와 seekp() 두 가지 버전: 절대 위치를 받아서 이동, 오프셋과 지정 위치를 기준 으로 이동한다. 
 // 위치는 std::streampos로, 오프셋은 std::streamoff로 표현.

-tell()는 스트림의 현재 위치 반환. 마찬가지로 tellg()와 tellp().

	13.3.3 스트림끼리 서로 연결하기

-입력 스트림과 출력 스트림은 접근할 때 내보내기(flush-on-access) 방식으로 연결 가능. 입력 스트림에서 읽으면 즉시 출력 스트림으로 내보낸다.

-연결 작업은 tie()로 처리. 

-출력 스트림을 입력 스트림에 연결하려면 입력 스트림에 대해 tie()를 출력 스트림 주소를 인수 호출. 

-연결을 끊으려면 tie()에 nullptr를 전달해서 호출.

-cin과 cout, cerr와 cout 연결 가능.

	13.4 양방향 I/O

-입력과 출력을 모두 처리하는 스트림: 양방향 스트림(bidirectional stream)

-양방향 스트림은 iostream을 상속. 

-fstream 클래스는 양방향 파일시스템을 표현.

* 양방향 스트림은 읽기 위치와 쓰기 위치에 대한 포인터를 별도 사용. 모드 전환 시마다 seek() 메서드로 각각의 위치를 적절히 설정해야 한다.

	14.1.1 익셉션의 정체

-익셉션: '예외' 상황이나 에러가 정상적인 실행 흐름에 퍼지지 않도록 알려주는 메커니즘.

-익셉션 발생 -> 익셉션 핸들러(exception handler)로 제어권을 넘긴다..

	14.2 익셉션 처리 과정

->> 연산 에러 발생 -> ifstream 객체에 에러 플래그(fail hit) 설정 -> bool() 변환 연산자가 false를 리턴.

	14.2.1 익셉션 던지고 받기

* 작성한 함수에서 발생할 수 있는 익셉션을 모두 코드 문서에 기록한다 -> 익셉션 처리 용이

-throw 코드와 catch 코드는 나란히 작성하는 것이 좋다.

* 스트림 디폴트는 noexcept지만 exceptions() 메서드 호출 시 익셉션을 던지게 설정 가능. 컴파일러 에러 정보가 쓸모없을 땐 직접 다루는 편이 낫다.

	14.2.2 익셉션 타입

-던질 수 있는 익셉션 타입에는 제한이 없다.

-기본 타입보다는 새 익셉션 타입을 정의하는 것이 바람직

	14.2.3 익셉션 객체를 const 레퍼런스로 받기

* 익셉션 객체는 항상 const 레퍼런스로 받는 것이 좋다. 값으로 받으면 객체 슬라이싱.

	14.2.4 여러 가지 익셉션 던지고 받기

-runtime_error 익셉션 클래스는 <stdexcept> 헤더에 정의돼 있다.

-invalid_argument와 runtime_error에는 public 디폴트 생성자가 없고 string 인수를 받는 생성자만.

- catch(...) 문법은 모든 익셉션 타입에 매칭하라는 와일드카드.

	14.2.5 처리하지 못한 익셉션

-익셉션을 처리하는 곳이 하나도 없으면 프로그램 종료.

* 반드시 프로그램에서 발생할 수 있는 익셉션을 모두 잡아서 처리하도록 작성한다.

-프로그램이 잡지 못한 익셉션을 만나면 terminate()를 호출하게 만들 수 있다. 이 함수는 <cstdlib> 헤더에 정의된 abort() 함수를 호출해서 프로그램을 죽인다. 

-terminate(), set_terminate(), terminate_handler는 모두 <exception> 헤더에

-set_terminate()로 새로운 termiante_handler 지정 시 기존 핸들러 리턴. 처리할 일이 끝나면 이를 리셋하는 것이 바람직.

	14.2.6 noexcept

* noexcept 키워드가 지정된 함수는 익셉션을 던지지 않는다.

-noexcept 지정 함수에 익셉션을 던지는 코드가 있으면 C++ 런타임은 terminate() 호출.

-virtual 메서드가 noexcept지정이 아니라도 오버라이드 메서드는 noexcept 지정 가능.  반대로는 불가.

	14.2.7 throw 리스트(현재 지원 중단 및 삭제됨)

* C++11에서는 익셉션 명세 기능에 대한 지원이 폐기됐고 C++17부터는 완전히 삭제됐다. 단, noexcept와 throw()는 남아 있다. throw()는 실질적으로 noexcept와 같다.

	14.3.1 표준 익셉션 클래스의 계층 구조

-익셉션 클래스 대부분 what()가 리턴할 스트링을 생성자의 인수로 지정해야 한다. exception은 반드시 생성자에 이 값을 전달해야 한다.

	14.3.2 클래스 계층 구조에서 정확한 익셉션 타입 선택하기

-앞의 catch가 뒤의 catch 문보다 클래스 계층이 높으면 앞의 것을 먼저 선택. 구체적인 타입을 뒤에 적으면 실행되지 않는다.

	14.3.3 익셉션 클래스 직접 정의하기

-익셉션 직접 정의 시 반드시 표준 exception 클래스 직간접 상속.

* 익셉션 객체는 최소 한 번 이상 이동하거나 복제된다. // 동적 할당 사용시 special methods 직접 정의

	14.3.4 중첩된 익셉션

-C++는 먼저 잡은 익셉션을 새로 발생한 익셉션의 문맥 안에 포함시키는 중첩된 익셉션(nested exception) 기능 제공.

-catch 문에서 새로운 익셉션을 던지고 싶다면 std::throw_with_nested() 사용. 

-나중 발생 익셉션 처리 catch에서 먼저 발생했던 익셉션에 접근 시 dynamic_cast(). 이때 먼저 발생한 익셉션은 nested_exception으로 표현한다. // p.644

	14.4 익셉션 다시 던지기

-throw 키워드는 현재 발생한 익셉션을 다시 던질 때 사용.

* 익셉션을 다시 던질 때는 항상 throw;로 적어야 한다.

	14.5 스택 풀기와 청소

-익셉션 발생 시 핸들러의 스택 단계로 회귀. 이 과정에서 중간 스택 프레임을 모두 푼다: 스택 풀기(stack unwinding).

-스택 풀기 시 리소스 정리 작업 x.

* 익셉션 처리 구문을 작성할 때 메모리나 리소스 누수가 발생하지 않도록 주의한다.

	14.5.2 익셉션 잡고, 리소스 정리한 뒤, 익셉션 다시 던지기

-또다른 리소스 누수 방지 기법: 발생 가능 익셉션을 모두 잡아서 리소스를 제대로 정리 뒤 그 익셉션을 다시 스택의 상위 핸들러로 던지는 것.

* 익셉션을 잡고, 리소스를 정리한 뒤, 익셉션을 다시 던지기보다는 스마트 포인터나 RAII 클래스를 사용하는 방법이 더 좋다.

	14.6.1 메모리 할당 에러

-메모리 할당 불가 시 디폴트 수행 동작은 <new> 헤더 파일의 bad_alloc 익셉션을 던지는 것 -> 이 익셉션을 적절히 처리하는 catch 구문 작성.

1. 익셉션을 던지지 않는 new

-nothrow 버전의 new와 new[]도 제공. 메모리 할당 실패 시 nullptr 리턴. // new(nothrow)

2. 메모리 할당 에러 처리 방식 커스터마이즈하기

-C++는 new 핸들러 콜백 함수를 커스터마이즈하는 기능을 제공.

-new 핸들러 정의 시 메모리 할당 루틴에서 에러 발생 -> 정의된 new 핸들러 호출 -> 할당 다시 시도 -> 실패해도 다시 new 핸들러 호출 -> 무한 루프 발생 가능

-해결법:
 -메모리 추가하기
 -익셉션 던지기
 -다른 new 핸들러 설정

-메모리 할당 에러 시 new 핸들러를 원치 않으면 new 호출 전에 new 핸들러 값을 nullptr로.

-new 핸들러는 <new> 헤더 파일에 선언된 set_new_handler()를 호출해서 설정한다.

-new 핸들러에는 반드시 인수와 리턴값이 없어야 한다.

	14.6.2 생성자에서 발생하는 에러

* 익셉션이 발생해서 생성자를 벗어나면 그 객체에 대한 소멸자가 호출 x. // 리소스 정리 명심

-파생 클래스 생성자보다 베이스 클래스 생성자가 먼저 실행. 
 -파생 클래스 생성자에서 익셉션이 발생 -> 베이스 클래스 소멸자 호출.

* C++는 생성자 실행을 정상적으로 마친 객체에 대해 소멸자가 실행되도록 보장.

	14.6.3 생성자를 위한 함수 try 블록

-try 블록은 생성자에도 적용 가능 // p.680

-생성자에 대한 함수 try 블록 안 catch 문은 반드시 현재 익셉션을 다시 던지거나 새 익셉션을 생성해서 던져야 한다.

* 함수 try 블록은 주로 일반 포인터 타입 리소스(naked resource)가 있을 때만 유용. RAII 클래스를 이용하면 불필요.

	14.6.4 소멸자에서 익셉션을 처리하는 방법

-소멸자에서 발생하는 에러는 반드시 소멸자 안에서 처리. 이유:
 1. 소멸자를 명시적 noexcept(false) 지정하지 않으면 noexcept로 취급 -> 익셉션을 던지면  std::terminate() 호출
 2. 스택 풀기 중 소멸자 익셉션 ->  std::terminate() 호출
 3. 클라이언트는 소멸자를 delete로  간접 호출 -> 소멸자 익셉션 발생 시 클라이언트가 할 수 있는 일이 없다.
 4. 소멸자에서 리소스 해제 실패 시 기회 없음.

* 소멸자에서 호출한 함수나 메서드에서 발생한 익셉션을 잡아서 처리할 때 조심해야 한다.

	15.1.2 연산자 오버로딩의 한계

-., ::, sizeof, ?: 등의 일부 연산자는 오버로딩 불가.
-에리티(arity): 연산자의 인수 또는 피연산자(operand)의 개수. 에리티 변경은 함수 호출, new, delete 연산자만 가능.
-기본 타입 연산자의 의미는 바꿀 수 없다.

-오버로딩하는 함수나 메서드를 작성할 때 결정할 사항:

1. 메서드와 전역 함수:

-오버로딩 연산자를 메서드로 혹은 전역 함수(friend)로 정의할지 선택.

2. 인수 타입에 대한 결정

-변경할 일이 없다면 무조건 const로 지정.

3. 리턴 타입에 대한 결정사항:

-C++는 적합한 오버로딩 연산자를 찾을 때 리턴타입 고려 x.

-레퍼런스로 리턴할 수 있으면 레퍼런스로 리턴, 아니면 값 리턴.

	15.1.4 오버로딩하면 안 되는 연산자

-주소 연산자(operator&). 장점 x, 혼란 야기.

-operator&&와 operator||. C++의 단락 평가 규칙(short-circuit evaluation rule)을 적용 x

-콤마 연산자(operator,)도 오버로딩 불가. 한 문장에 나온 두 표현식을 분리하여 왼쪽에서 오른쪽 순으로 평가.

	15.1.5 오버로딩할 수 있는 연산자

-// p.696

	15.1.7 관계 연산자

-관계 연산자(relational operator)에 대한 함수 템플릿 std::rel_ops 네임 스페이스에서 제공. 

 #include <utility>과 using문 추가 시 사용 가능. // using namespace std::rel_ops;

-관계 연산 관련된 모든 클래스에 대해 위 연산자가 생성된다는 문제.  std::greater<T> 같은 유틸리티 템플릿과 작동 x. 암묵적 변환도 x

* 작성할 클래스에서 std::rel_ops를 그대로 사용하지 말고, 관계 연산자를 모두 구현하는 것이 좋다.

	15.2.1 단항 뺄셈과 단항 덧셈 연산자 오버로딩하기

-p.700

	15.4 스트림 입출력 연산자 오버로딩하기

-스트림 입출력 연산자 오버로딩 전에 스트림 입출력을 처리 방법부터 결정.

-// std::ostream& operator<< (std::ostream& ostr, const SpreadsheetCell& cell);
 // std::istream& operator<< (std::istream& ostr, SpreadsheetCell& cell);

	15.5 인덱스 연산자 오버로딩하기

-p.706

	15.5.1 읽기 전용 operator[] 만들기

-C++에서는 리턴 타입 기반 오버로딩 불가. 따라서 const 버전은 리턴 레퍼런스, 메서드 전체 const 지정.

-const operator[]는 const 객체에 대해서만 호출.

	15.2.2 배열의 인덱스가 정수가 아닐 때

-인덱스를 키 값으로 볼 수도 있다.

-operator[]의 인덱스를 정수가 아닌 다른 타입으로도 표현 가능.

	15.6 함수 호출 연산자 오버로딩하기

-함수 객체의 확실한 장점: 함수 객체를 함수 포인터로 표현해서 다른 함수에 콜백 함수로 전달할 수 있다는 것.

	15.7 역참조 연산자 오버로딩하기

-역참조 연산자 오버로딩 시 객체를 포인터처럼 다룰 수 있다. 스마트 포인터, 반복자 다룰 때 유용.

* 스마트 포인터를 직접 정의하는 것보다 표준 스마트 포인터 클래스를 활용하는 것이 바람직하다.

	15.7.1 operator* 구현방법

-operator*는 클래스 내부 raw pointer가 가리키던 객체나 변수에 대한 레퍼런스를 리턴한다.

-const와 non-const 버전을 모두 제공해서 const 레퍼런스 와 non-const 레퍼런스를 리턴하도록 정의하면 좋다.

	15.7.2 operator-> 구현방법

-화살표 연산자 적용 결과는 반드시 객체의 멤버나 메서드 > 
 이렇게 구현하려면 operator* 실행 뒤 바로 operator. 호출; 하지만 C++에서는 operator. 오버로딩 불가 > 
 operator->를 예외로 취급한다.
 // smartCell->set(5); == (smartCell.operator->())->set(5); C++는 오버로딩 operator-> 리턴 값에 다른 operator-> 적용. 그래서 반드시 포인터로 리턴하게 오버로딩.

	15.7.3 operator.*와 operator->*

-포인터를 통해 데이터 멤버에 접근, 메서드를 호출하려면 객체의 문맥 안에서 포인터 역참조.

	15.8 변환 연산자 구현하기

-변환 연산자는 리턴 타입 지정  불필요.

	15.8.1 명시적 변환 연산자로 모호한 문제 해결하기

-C++11 이전에는 변환 연산자 모호함은 생성자 앞 explicit 키워드 지정으로 해결.

-C++11부터는 변환 연산자를 explicit으로 선언하는 방식 해결.

-explicit 선언 시 반드시 명시적으로 캐스팅.

	15.8.2 부울 표현식으로 표현하기

-포인터 타입으로 변환하는 연산자 추가 시 nullptr와 비교 문장뿐만 아니라 그냥 객체만 적어도 자동으로 포인터 타입으로 변환. 주로 void* 타입 사용.

-operator void*() 대신 operator bool() 오버로딩으로도 가능. 

-bool 변환 연산자 추가 시 예상치 못한 모호함 발생 가능. 이런 경우 C++는 bool을 int로 자동 변환하는 프로모션 규칙을 적용. 때문에 대부분 operator void*()를 선호.

	15.9 메모리 할당과 해제 연산자 오버로딩하기

* 다양한 메모리 할당 전략을 잘 모른다면 힘들여 메모리 할당 루틴을 오버로딩해도 큰 효과를 보기 힘들다. 정말 필요하고 관련 지속도 갖추고 있을 때만 이 기법을 사용한다.

	15.9.1 new와 delete의 구체적인 작동 방식

-메모리 할당, 해제 과정은 커스터마이즈 가능. 생성자, 소멸자 호출 동작은 변경 불가..

2. delete-표현식과 operator delete:

-operator delete는 여섯 가지.

-C++ 표준에는 delete에서 익셉션을 던질 때의 동작 미정의 -> delete에서 익셉션을 던지면 안됨 -> nothrow 버전 불필요

	15.9.2 operator new와 operator delete 오버로딩하기

-절대 전역 operator new와 operator delete를 교체 x

* operator new을 오버로딩할 때 반드시 이에 대응되는 operator delete도 오버로딩. else 할당 로직 불일치.

* 일부만 오버로딩 시 미사용 버전에 명시적 delete 지정.

	15.9.4 operator new와 operator delete에 매개변수를 추가하도록 오버로딩하기

-operator new에 매개변수를 원하는 형태로 추가해서 오버로딩 가능.
 void* MemoryDemo::operator new(size_t size, int extra) { ... } // 호출: MemoryDemo* memp = new(5) MemoryDemo(); // p.731

-operator new에 매개변수를 추가해서 정의 시 대응되는 operator delete도 반드시 똑같이 매개변수 추가 재정의.

	15.9.5 operator delete에 메모리 크기를 매개변수로 전달하도록 오버로딩하기

-operator delete 오버로딩 시 해제 대상 포인터, 해제할 메모리 크기를 프로토 타입 매개변수로 전달 가능.

* 메모리 크기 매개변수를 받는 operator delete와 받지 않는 operator delete 중 매개변수가 없는 버전이 먼저 호출. 

	16. 표준 라이브러리 둘러보기

-표준 라이브러리는 바이너리 파일 하나가 아닌, 독립 컴포넌트들로 이루어져 있다.

* C++를 제대로 사용하려면 C 헤더에서 제공하는 기능은 사용하지 않는다.

	16.1.1 템플릿 활용

-템플릿으로 객체화 시 템플릿의 요구사항으로 명시된 연산자나 메서드를 반드시 구현.

	16.2.1 스트링

* std::string은 std::basic_string<char> 인스턴스화의 타입 앨리어스.

-<string_view>의 string_view는 스트링을 읽기 전용으로 표현한다.

-<locale>에 정의된 Locale 클래스로 숫자, 날짜를 특정 국가나 지역에 맞게 표현 가능.

	16.2.2 정규표현식

-정규표현식(regular expression)은 <regex> 헤더 파일에 정의.

	16.2.6 수학 연산 관련 유틸리티

-복소수 클래스: <complex> 헤더 파일.

-컴파일 시간 유리수 연산 라이브러리: ratio 클래스 템플릿. <ratio>헤더 파일. 

-valarray 클래스는 <valarray>헤더 파일에 정의돼 있다. vector와 비슷하지만 고성능 수치 연산용으로 최적화한 것.

-numeric_limits 클래스 템플릿 활용 시 현재 플랫폼의 경곗값에 대한 정보. <limits> 헤더 파일.

-min()과 lowest()의 결과는 다르다. 
 부동소수점수 최솟값: 시스템에서 표현할 수 있는 가장 작은 양숫값
 최젓값: 시스템에서 표현할 수 있는 음수 중 가장 큰 값(-max()).

	16.2.7 시간 관련 유틸리티

-시간에 관련된 chrono(크로노) 라이브러리도 제공. <chrono> 헤더 파일.

	16.2.8 무작위수

-<random>

	16.2.10 pair와 tuple

-<utility> 헤더 파일에서는 pair 템플릿 정의. 이러한 저장 방식을 이종(heterogeneous) 원소 저장.

-pair 템플릿 -> 서로 타입이 다른 두 원소를 객체 하나에 저장.

-<tuple> 헤더의 tuple(튜플)은 pair를 일반화한 것. 고정 크기 수열로서 서로 타입이 다른 원소를 저장. 

-tuple의 원소 개수와 타입은 컴파일 시간에 결정된다.

	16.2.11 optional, variant, any

-C++17부터 다음과 같은 클래스가 새로 추가됐다:
 optional: <optional>. 특정한 타입의 값을 가지거나 가지지 않거나.
 variant: <variant>. 지정 타입 중 하나의 값을 가지거나 가지지 않거나.
 any: <any>. 모든 타입의 값을 단 하나만

	16.2.12 함수 객체

-<functional> 헤더엔 다양한 사전 정의 함수 객체가 정의.

	16.2.13 파일시스템

-C++17부터 파일시스템을 지원 라이브러리 추가. <filesystem> 헤더 파일에 정의된 것들은 모두 std::filesystem 네임스페이스. 파일시스템 코드 포팅 용이.

	16.2.15 타입 트레이트

-타입 트레이트(type traits) 기능은 <type_traits> 헤더 파일. 컴파일 시간에 타입 정보 조회 가능.

	16.2.16. 표준 정수 타입

-<cstdint>에서는 다양한 표준 정수 타입(int8_t, int64_t)을 정의. 그 타입들의 최댓값. 최솟값 지정 매크로도 제공.

	16.2.17 컨테이너

-컨테이너 인스턴스마다 단 한 가지 타입의 객체만 저장 -> 동형(homogeneous) 컬렉션.

-C++ 표준은 컨테이너나 알고리즘에 대해 구현이 아닌 인터페이스만 정해두고 있다. -> 벤더마다 다르게 구현 가능.

1.vector:

-배열과 마찬가지로 vector의 원소도 메모리 공간에 연달아 저장. 경곗값 검사 기능 제공.

* C++의 vector는 동적 배열

-vector는 마지막 항목 추가, 삭제 연산을 빠르게 처리.

-vector에서 원소 조회 시간은 배열처럼 상수 시간으로 상당히 빠르다.

-컴퓨터는 연속된 공간에 저장된 데이터를 효율적으로 처리. 

-프로파일러로 성능 분석 후 vector보다 나을 때만 다른 데이터 구조 사용.

2. list

-표준 라이브러리 제공 양방향(이중) 연결 리스트. <list> 헤더 파일.

3. forward_list:

-forward_list(정방향 리스트)는 <forward_list>에 정의된 단방향 연결 리스트(single linked list). 

-forward_list는 정방향 반복만 지원 -> list보다 메모리를 적게 쓴다.

4. deque:

-deque은 상수 시간에 원소 접근. 양쪽 끝 원소 추가, 삭제 연산 상수 시간에 처리. 중간 추가, 삭제 연산은 다소 느리게(선형 시간에) 처리. 

-deque의 원소는 연속된 메모리 공간에 저장 x.

-양쪽 끝 원소 추가, 삭제 및 조회도 빠르게 처리하고 싶다면 deque 사용.

5. array:

-원소 개수를 알고, 동적 유연성 불필요 -> 크기 고정된 array. 

-vector에 비해 적은 오버헤드.

-array는 표준 C 스타일 배열을 단순히 감싼 래퍼.

* vector, list, forward_list, deque, array 컨테이너는 원소를 순차적으로 나열된 형태로 저장하기 때문에 순차 컨테이너라 부른다.

6. queue:
7. priority_queue:

-원소마다 우선순위가 정해진 큐를 제공.

-정렬 때문에 priority_queue의 추가, 삭제 연산은 queue보다 느림.

-priority_queue 이용 시 '예외가 있는 큐' 표현 가능.

8. stack:

* 엄밀히 말해 queue, priority_queue, stack은 컨테이너가 아닌 컨테이너 어댑터다. 즉, vector, list, queue와 같은 표준 순차 컨테이너 위에 인터페이스만 추가한 것이다.

9. set과 multiset:

-원소들의 집합을 표현한 것이다.

-set은 원소의 순서가 정해져 있다. 원소 나열 시 비교 연산자로 순서를 정해서 출력하기 위해서.

-이론적으로 set 원소 추가, 삭제 연산은 vector보다 빠르고 list보다 느리다. 조회 연산은 list보다 빠르고 vector보다 느리다.

-원소 순서를 정해야 하고, 추가/삭제/조회 연산량 비슷, 각 연산 성능도 서로 비슷한 수준으로 최적화하고 싶다면 set.

-set은 원소의 중복을 허용 x

10. map과 multimap:

-map은 모든 타입으로 인덱스를 표현할 수 있는 배열을 만들 수 있다.

* set과 map 같은 컨테이너를 연관 컨테이너라 부른다. 키와 값이 서로 연관되기 때문이다. set은 키가 곧 값이기 때문이다.
  set과 map은 모두 원소를 정렬한 상태로 유지한다. 그래서 정렬 연관 컨테이너 또는 순서 연관 컨테이너라 부르기도 한다.

11. 비정렬 연결 컨테이너와 해시 테이블:

-표준 라이브러리는 다음 네 가지 종류의 해시 테이블 제공:
 unordered_map, unordered_multimap, unordered_set, unordered_multiset
 // <unordered_map>                      // <unordered_set> 

-비정렬 연관 컨테이너 원소 추가, 삭제, 조회 연산 속도는 대체로 상수 시간.

-비정렬 연관 컨테이너 원소 조회 속도는 일반 map이나 set보다 훨씬 빠르다.

12. bitset:

-C++ 표준 라이브러리는 비트 단위로 다루는 작업을 추상화한 bitset 클래스를 제공한다.

-bitset 컨테이너는 <bitset> 헤더 파일. 원소 추가, 삭제 가능 구조 x. bitset의 크기는 고정, 반복자 제공x. 

-부울값을 읽고 쓸 수 있게 한 줄로 나열한 것과 같다. 

-bitset<N>이란 선언문에서 N비트만큼 공간을 할당한다.

* 반드시 vector를 기본 컨테이너로 사용해야 한다. 실전에서 vector로 구현이 추가 삭제 연산 빠름. 이유는 최신 CPU에서 메모리
  와 캐시를 처리하는 방식 때문, list나 forward_list는 추가, 삭제 지점 탐색 오버헤드 존재. 또 메모리 공간에 연속적으로 저장되지 않을 수 있다.

	16.2.18 알고리즘.

* 컨테이너 성격 따라 제네릭 알고리즘으로 처리하면 성능이 하락. 가능한 메서드 버전 사용.

-컨테이너마다 반복자 동작은 다르지만, 표준 인터페이스를 따르기에 반복자 구현 코드의 형태는 모두 같다.

* 반복자는 알고리즘과 컨테이너를 연결. 알고리즘과 컨테이너의 종류에 관계없이 똑같은 방식으로 코드 작성 가능.

-표준 라이브러리의 알고리즘은 특별히 명시하지 않는 한 모두 <algorithm> 헤더 파일.

	16.2.19 표준 라이브러리에서 제공하지 않는 기능

-컨테이너에 스레드 안전성 보장 x.

-표준 라이브러리는 제네릭 트리나 그래프 구조를 제공 x.

-표준 라이브러리는 확장 가능.

	17. 컨테이너와 반복자 살펴보기

-array와 bitset을 제외한 STL 컨테이너는 크기 조절 가능. 원소 추가, 삭제에 따라 크기 자동 조절ㄴ.

	17.1.1 원소에 대한 요구사항

-STL 컨테이너는 원소를 값으로 처리 -> STL 사용 클래스 작성 시 복제 가능해야 함. STL 컨테이너에 원소 요청 시 저장된 복제본 레퍼런스 리턴.

-원소를 레퍼런스로 처리하고 싶다면 원소에 대한 포인터를 저장.

-또는 컨테이너에 std::reference_wrapper 저장. std::ref()나 std::cref()로 생성, 결과로 나온 레퍼런스를 복제할 수 있게 만든다. <functional> 헤더

-이동 전용(move-only) 타입도 컨테이너에 저장 가능. 하지만 컴파일 에러 가능성.

* 컨테이너에 포인터를 저장하려면 unique_ptr나 shared_ptr를 사용한다.

-컨테이너는 할당자를 이용하여 원소에 대한 메모리를 할당, 해제.

-디폴트 할당자와 비교자를 사용하는 컨테이너의 원소가 만족해야 할 요구사항:
 복제 생성자, 이동 생성자(noexcept), 대입 연산자, 이동 대입 연산자(noexcept), 소멸자, 디폴트 생성자, operator==, operator<

	17.1.3 반복자

-표준 라이브러리는 원소 접근 기능의 범용적 제공을 위해 반복자 패턴 사용.

-반복자는 반드시 복제 생성자, 복제 대입 연산자, 소멸자 제공.

-반복자의 좌측값(lvalue)은 반드시 맞교환할 수 있어야 한다. 

-반복자의 다섯 가지 분류:
 입력, 출력, 정방향, 양방향, 임의 접근

-std::distant()를 이용하면 컨테이너의 두 반복자 사이의 거리(항목 수)를 구할 수 있다.

-반복자의 기본 연산은 일반 포인터와 비슷. 그래서 일반 포인터를 특정 컨테이너 반복자로 사용 가능.

* 반복자는 내부적으로 포인터로 구현됐을 수도 있고, 그렇지 않을 수도 있다.

* 순차, 정렬 연관, 비정렬 연관 컨테이너만 반복자 제공. 컨테이너 어댑터, bitset 클래스는 반복자 제공 x.

* const_iterator와 const_reverse_iterator는 컨테이너의 원소를 읽기 전용으로 접근한다.

-begin()과 end()는 첫 번째 원소는 포함하지만 마지막 원소는 포함하지 않는 반개방(half-open range)을 지원. 빈 구간을 지원하기 위해서다.

	17.2 순차 컨테이너

	17.2.1 vector

-vector는 원소를 연속된 메모리 공간에 한 자리씩 차지하게 저장.

-vector 원소 추가, 삭제 작업은 선형 시간. 끝에서 처리 시 분할 상환 상수 시간(amortized constant time).

-vector의 operator[]에서 범위를 벗어난 원소 접근 시 동작은 미정의.

* 기존 배열과 마찬가지로 vector에 operator[] 연산을 적용해도 경계 검사(bound checking) x.

* vector에서 operator[] 호출 시 레퍼런스 리턴 -> lvalue. 
  const vector에서 operator[] 호출 시 const 원소에 대한 레퍼런스 리턴 -> 대입 불가

-디폴트 원소값 미지정 시  모두 0으로 초기화.

-vector를 힙에 할당할 수도 있다.
 // auto elementVector = make_unique<vector<Element>>(10);

-vector는 객체의 복제본 저장. vector의 소멸자는 원소 객체의 소멸자를 호출하도록 정의돼 있다.

-vector 복제 생성자, 대입 연산자는 깊은 복제 수행 -> vector 전달 시 레퍼런스나 const 레퍼런스로

-현재 저장된 원소를 모두 삭제한 뒤 원소를 원하는 수만큼 추가하는 assign() 메서드도 제공한다.

-두 vector의 내용을 상수 시간에 맞바꾸는 swap().

-iterator -> const_iterator: 가능
 const_iterator -> iterator: 불가능

-일반적으로 반복자의 안정성(safety)은 포인터와 같다. 안전성이 상당히 떨어진다.

-다음 세 가지 경우에 반복자 사용이 유리:
 -원하는 지점 추가, 삭제
 -표준 라이브러리 알고리즘 사용
 -컨테이너 순차적 접근

* pop_back()는 삭제한 원소 리턴 x. 삭제 원소를 리턴받고 싶다면 back().

* push_back()과 insert()의 좌측값 버전은 원소의 복제본을 저장, 우측값 버전은 이동 의미론을 적용

-erase()로 원하는 원소 제거. 모두 삭제하려면 clear().

-표준 라이브러리 제공 컨테이너는 모두 이동 생성자, 이동 대입 연산자 제공.

-emplace 연산 지원. 복제, 이동 없이 컨테이너에 공간을 마련해서 객체를 그 자리에 바로 생성한다.

-vector 메모리 재할당 시 기존 반복자들 무효.

-현재 상태에서 재할당 없이 추가 가능 원소 수는 capacity() - size().

-data()로 vector에서 데이터가 있는 메모리 블록에 대한 포인터를 구할 수 있다.

-하나 이상의 템플릿 매개변수로 정의한 타입에 접근 시 typename 키워드 지정.

	17.2.2 vector<bool> 특수화

-bool 타입 vector 구현 시 공간 효율을 최적화하도록 부울값을 묶어서(패킹, packing) 처리. 

-C++의 기본 타입에는 비트 하나만 표현하는 것이 없다 -> vector<bool>은 한 비트짜리 bool들을 배열 저장으로 절약.

-flip(): 그 컨테이너에 담긴 원소를 모두 반전. operator[] 같은 메서드 리턴 레퍼런스에 대해 호출하면 해당 원소만 반전.

-vector<bool>은 내부적으로 bool 타입(비트)을 표현하는(bool에 대한 프록시인) reference란 클래스를 정의하는 방식으로 구현.

-vector<bool>의 조회, 수정 속도는 특정 타입에 대한 vector보다 느리다. vector<bool>보다는 bitset 권장.

	17.2.3 deque

-deque는 원소를 메모리에 연속적으로 저장하지 않는다.

-deque는 원소를 추가해도 반복자 무효화 x.

	17.2.4 list

-원소 추가, 삭제 속도는 상수 시간. 원소 조회는 선형 시간.

-list 접근 메서드는 front()와 back()뿐다.

* list는 랜덤 액세스 지원 x.

-list의 반복자는 양방향.

-clear()를 제외한 모든 추가, 삭제 메서드는 위치를 지정 가능 시 상수 시간.

-list는 연결 리스트이기 때문에 스플라이스(splice) 가능.

	17.2.5 forward_list

-<forward_list> 헤더 파일. 단방향 연결 리스트란 점을 제외, list와 유사.

-forward_list 변경 시 대상 원소 바로 전 원소에 접근 필요. 하지만 역방향 이동 불가 -> before_begin() 제공.

	17.2.6 array

-array는 크기가 고정된 점을 제외하면 vector와 같다. 크기를 고정시키는 이유는 원소를 스택에 할당하기 위해서다.

-array의 swap()은 선형 시간. vector는 상수 시간. array는 상수 시간 이동 불가.

-std::get<n>()을 이용하면 std::array의 n번 인덱스에 있는 원소.

	17.3 컨테이너 어댑터.

	17.3.1 queue

-queue에서 push_back()과 pop(), front()를 모두 지원하려면 순차 컨테이너. 기본 제공 컨테이너 중 deque나 list만 가능.

* queue의 pop()은 꺼낸 원소를 리턴 x.

-네트워크로 정보 교환 시 데이터를 패킷(packet)이라는 단위로 전송.

	17.3.2 priority_queue

-priority_queue 컨테이너 어댑터도 <queue> 헤더 파일.

-priority_queue는 디폴트 컨테이너로 vector 사용. priority_queue는 랜덤 액세스를 지원.

-non-const 객체에 대해 top()을 호출해도 const 레퍼런스 리턴. 원소 수정 시 순서가 바뀔 수 있기 때문.

	17.3.3 stack

-top() 메서드를 const 객체에 대해 호출 시 const 레퍼런스, non-const는 non-const 레퍼런스.

* pop()은 꺼낸 원소 리턴 x. 복제본이 필요하면 top() 메서드로 미리 받아둔다.

	17.4 정렬 연관 컨테이너

-정렬 연관 컨테이너는 원소를 키와 값의 쌍으로 저장.

	17.4.1 pair 유틸리티 클래스

-pair의 operator==과 operator<는 first와 second 원소 모두 비교.

-make_pair()는 함수에 pair를 전달하거나 변수에 pair를 대입할 때 유용.

	17.4.2 map

-추가, 삭제, 조회 연산 모두 키를 기준으로 수행한다.

-map은 정렬된 상태로 유지. 그래서 추가, 삭제, 조회 성능이 모두 로그 시간.

-insert()로 키 존재 여부 검사 가능. 키/값 쌍은 pair 객체나 initializer_list로 지정.

-insert() 기본 버전은 iterator와 bool 원소로 구성된 pair 리턴.

-insert_or_assign()의 리턴 타입은 insert()와 비슷하다. 키의 원소가 존재 시 기존 값을 새 값으로 덮어쓴다. 

-operator[]의 오버로딩 버전으로 map에 원소 추가 가능. 이미 존재한다면 기존 값을 새 값으로.

-operator[]는 값에 대한 객체를 항상 새로 만든다. 고로 디폴트 생성자가 반드시 있어야 하며, insert()보다 효율이 떨어진다.

-const 레퍼런스로 operator[] 조회 불가. find() 활용.

-map 반복자 키/값으로 구성된 pair를 가리킨다. map 반복자는 양방향.

-주어진 키에 대한 원소 존재 여부를 알려면 count() 활용.

-노드:

 -정렬 및 비정렬 연관 컨테이너를 노드 기반(node-based) 데이터 구조라 부른다.

 컨테이너마다 그 노드 핸들 타입을 가리키는 node_type 타입 앨리어스 존재. 노드 핸들 이동만 가능, 노드에 저장된 원소 소유. 키와 값 모두에 읽기/쓰기 권한이 있다.

 -extract()에 반복자 위치나 키를 지정, 호출하면 연관 컨테이너에서 노드를 노드 핸들로 가져올 수 있다. 
 
 -노드를 가져오면 그 노드는 컨테이너에서 삭제.

 -노드 핸들을 컨테이너에 추가할 수 있도록 insert()를 오버로딩한 메서드도 새로 추가.

 -merge() 이용 시 한쪽 연관 컨테이너에 있는 노드를 다른 쪽으로 이동 가능. 이동 불가 노드는 원본 컨테이너에 남는다.

	17.4.3 multimap

-multimap은 operator[]와 at() 제공 x.

-multimap에 원소 추가 연산은 항상 성공. multimap::insert()는 iterator 하나만 리턴.

-find()는 지정 키에 해당하는 모든 원소를 참조하는 iterator를 리턴 하기 때문에 조회에 도움 x.

-equal_range()는 lower_bound()와 upper_bound()가 리턴하는 iterator를 pair로 묶어서 리턴.

	17.4.4 set

-키가 곧 값이라는 점 제외 map과 유사. 

-set은 키를 따로 갖지 않고 정보를 중복되지 않게 정렬해서 저장하고, 추가, 조회, 삭제 연산도 빠르게 처리하고 싶을 때 적합하다.

	17.4.5 multiset

-multiset과 set의 관계는 multimap과 map의 관계와 같다.

	17.5 비정렬 연관 컨테이너(해시 테이블)

-표준 라이브러리는 해시 테이블이라 불리는 비정렬 연관 컨테이너도 제공(unordered_map, multimap, set, multiset).

	17.5.1 해시 함수

-해시 테이블은 버킷(bucket)이라 부르는 배열 형태로 원소를 저장한다. 해시 함수는 키 -> 해시값(hash value)으로 변환 -> 버킷 인덱스(bucket index)로 변환.

-해시 함수 결과 중복 가능. 두 개 이상의 키가 같은 버킷 인덱스를 가리키는 현상 -> 해시 충돌. 

-충돌 해결: 이차 함수 재해싱(quadratic re-hashing), 리니어 체이닝(linear chaining).

-충돌이 전혀 없는 해시 함수: '완전 해시(perfect hash)'라 부른다.

-C++ 표준에서는 기본 타입에 대해 해시 함수 제공.

	17.5.2 unordered_map

-템플릿 매개변수는 키, 값, 해시, 등호 비교, 할당자 타입 등 다섯 가지. 특별한 이유가 없다면 디폴트값 사용.

	17.5.3 unordered_multimap

-equal_range() 메서드로 조회.

	17.5.4 unordered_set과 unordered_multiset

-각각 키를 정렬하지 않고 해시 함수를 사용한다는 점만 빼면 set, multiset과 유사.

	17.6.1 표준 C 스타일 배열

-일반 포인터도 일종의 반복자다. 반복자와 관련된 연산을 제공하기 때문이다.

* std::begin()과 std::end() 같은 함수는 포인터로 접근하지 않는 정적 할당 C 스타일 배열에 대해서만 사용 가능.

	17.6.2 string

-string을 문자에 대한 순차 컨테이너로 볼 수 있다.

-string은 순차 컨테이너에서 기본적으로 제공하는 메서드를 모두 갖추고 있다.

	17.6.3 스트림

-입력과 출력 스트림은 컨테이너가 아니다. 원소를 저장하지 않기 때문이다.

	17.6.4 bitset

-bitset은 고정 크기 비트열을 추상화한 것.

-bitset은 셋(set, 설정)과 언셋(unset, 해제)이란 용어를 사용. 값 반전(토글 또는 플립)도 가능.

-bitset은 정식 표준 라이브러리 x -> 크기 고정, 원소 타입 템플릿화 x, 반복자 제공 x.

-bitset은 <bitset> 헤더 파일. 디폴트 생성자는모든 필드를 0으로 초기화.

-set(), unset(), flip() 메서드로 설정 가능. operator[] 연산으로 각 필드값 조회, 설정 가능.

-test()로 개별 필드에 접근 가능.

-추가 및 추출 연산으로 bitset을 스트림으로 처리 가능. bitset을 스트림으로 처리하면 0과 1이란 문자로 구성된 string으로 표현.

-bitset은 비트 조작 메서드, &, !, |, ^, ~, <<, >>, &=, |=, ^=, <<=, >>=와 같은 비트 연산자도 제공.

	18. 표준 라이브러리 알고리즘 마스터하기

	18.1 알고리즘 개요

-알고리즘에 전달할 반복자는 일정한 요건을 갖춰야 한다.

-표준 라이브러리 알고리즘은 대부분 <algorithm> 헤더 파일에 정의. 일부 수치 연산 관련 알고리즘은 <numeric>에 정의.

	18.1.1 find()와 find_if() 알고리즘

* find()에서 원소를 찾지 못하면 함수를 호출할 때 지정한 끝 반복자를 리턴.

	18.1.2 accumulate() 알고리즘

-컨테이너 원소를 모두 더하는 산술 연산을 적용해야 할 때 -> accumulate(). <numeric>에 정의.

-accumulate()의 두 번째 형태는 다른 연산 지정 가능. 이때 연산을 이진(인수가 두 개인) 콜백(binary callback)으로 표현.

	18.1.3 알고리즘과 이동 의미론

-표준 라이브러리 알고리즘도 이동 의미론 최적화 가능 -> 가능하면 이동 의미론을 구현.

	18.2 std::function

-<funtional> 헤더 파일에 정의된 std::function 템플릿을 이용 시 호출 가능한 모든 대상을 가리키는 타입을 생성 가능.

	18.3 람다 표현식

-람다 표현식(lambda expression)이란 함수나 함수 객체를 별도로 정의하지 않고, 필요 지점에서 곧바로 함수를 직접 만들어 쓸 수 있는 일종의 익명 함수다.

	18.3.1 문법

-[](parameters) { ... }

-람다 표현식은 값을 리턴한다. auto returningLambda = [](int a, int b) -> int { return a + b; };

-리턴 타입 생략 가능. 그러면 컴파일러는 일반 함수의 리턴 타입 추론 규칙에 따라 람다 표현식의 리턴 타입을 추론.

-람다 표현식은 자신이 속한 스코프에 있는 변수에 접근 가능.  // auto capturingLambda = [data]{ cout << "Data = " << data << endl; }; // 변수 캡쳐

-컴파일러는 람다 표현식을 이름 없는 펑터(함수 객체)로 변환. 캡처한 변수는 이 펑터의 데이터 멤버가 된다.

-람다 표현식의 경우 operator()는 기본적으로 const로 설정. 람다 표현식에서 값 복제본 수정 불가. 

-mutable 지정하면 함수 호출 연산자를 non-const로 만들 수 있다.
 // auto capturingLambda = [data] () mutable { data *= 2; cout << "Data = " << data << endl; };

-mutable을 지정 시 매개변수가 없더라도 소괄호를 반드시 기입.

-캡처 리스트(capture list)를 지정하면 캡처할 변수를 골라서 지정할 수 있다. 이때 캡처 디폴트도 함께 지정할 수 있다.:
 [=]: 스코프에 있는 변수를 모두 값으로 캡처한다.
 [&]: 스코프에 있는 변수를 모두 레퍼런스로 캡처한다.
 [=, &x, &y], [&, x, y], [this], [*this]

* 가능하면 캡처할 변수를 직접 지정.

	18.3.3 람다 캡처 표현식

-람다 캡쳐 표현식(Lambda capture expression)은 표현식에 사용할 캡처 변수를 초기화한다.

-비레퍼런스 캡처 변수를 캡처 이니셜라이저로 초기화할 때는 복제 방식으로 생성된다. 그래서 const 지정자가 사라진다.

-move-only 데이터는 람다 표현식에 값으로 캡처 불가.

	18.3.4 람다 표현식을 리턴 타입으로 사용하기

-std::function을 이용하면 함수가 람다 표현식을 리턴하게 만들 수 있다.

	18.3.5 람다 표현식을 매개변수로 사용하기

-std::function 타입의 함수 매개변수는 람다 표현식을 인수로 받을 수 있다.

	18.4 함수 객체

-C++ 버전에 따라 <functional> 헤더 파일에 bind1st(), bind2nd, mem_fun(), mem_fun_ref(), ptr_fun()과 같은 함수도 정의. 이들은 C++17부터 공식적으로 삭제.

* 가능하면 함수 객체보다는 람다 표현식을 사용. 코드 작성과 이해가 더 쉽다.

	18.4.1 산술 함수 객체

-C++는 다섯 가지 이항 산술 연산자(plus, minus, multiplies, divides, modulus)에 대한 펑터 클래스 템플릿을 제공. 단항 negate도 제공.

-산술 함수 객체 사용 시 알고리즘으로 콜백을 전달 용이.

* 산술 함수 객체는 산술 연산자에 대한 래퍼. 알고리즘에서 함수 객체를 콜백으로 사용하려면 반드시 컨테이너에 담긴 객체가 해당 연산을 구현해야 한다.

1. 투명 연산자 펑터:

-C++는 투명 연산자(transparent operator)형태의 펑터도 제공. 이 펑터를 이용하면 템플릿 타입 인수 생략 가능. // multiplies<int>() -> multiplies<>()

* 항상 투명 연산자 펑터를 사용하는 것이 좋다.

	18.4.2 비교 함수 객체

-C++는 표준 비교 연산 함수 객체(equal_to, not_equal_to, less, greater, less_equal, greater_equal)도 제공.

-priority_queue가 greater를 기준으로 원소를 오름차순 정렬하려면:
 priority_queue<int, vector<int>, greater<>>

-투명 연산자가 대체로 비투명 연산자보다 성능이 좋다.

	18.4.3 논리 함수 객체

-logical_not(operator!), logical_and(operator&&), logical_or(operator||); 논리 비교 연산자 함수 객체 클래스 제공.

* 표준 라이브러리는 std::all_of()와 any_of()란 알고리즘으로 allTrue()와 anyTrue()와 같은 연산을 제공하고 있다.

	18.4.4 비트 연산 함수 객체

-C++는 bit_and(operator&), bit_or(operator|), bit_xor(operator^), bit_not(operator~) 등 비트 연산자 함수 객체 제공.

	18.4.5 어댑터 함수 객체

-제공 함수 객체가 요구사항에 맞지 않는 경우를 위해 어댑터 함수 객체(adaptor function object) 제공. 

1. 바인더:

-바인더 이용 시 호출 가능 개체의 매개변수를 일정한 값으로 묶어둘 수 있다. <functional> 헤더 파일의 std::bind().

-C++ 표준에 bind()의 리턴 타입이 명확히 정의돼 있지 않기 때문에 auto 키워드를 사용하는 것이 좋다.

-특정한 값에 바인딩되지 않은 인수는 반드시 std::placeholders 네임스페이스에 정의된 _1, _2, _3 등으로 지정.
 string myString = "abc";
 auto f1 = bind(func, placeholders::_1, myString);
 f1(16);

-bind()로 인수의 순서를 바꿀 수도 있다.
 auto f2 = bind(func, placeholders::_2, placeholders::_1);
 f2("Test", 32);

-<functional>의 std::ref()와 cref()로 레퍼런스나 const 레퍼런스 바인딩 가능.
 int index = 0;
 auto incr = bind(increment, ref(index));
 incr();

* C++11 이전 bind2nd()와 bind1st()는 C++11부터 폐기, C++17부터는 표준에서 완전히 삭제. 대신 람다나 bind() 사용.

2. 부정 연산자:

-부정 연산자는 바인더와 비슷하지만 호출 가능 개체의 결과를 반전시킨다는 점이 다르다.
 //auto it = find_if(begin(myVector), endIter, not_fn(perfectScore));

-펑터와 어댑터 사용 시 코드가 복잡해짐 -> 가능하면 람다 사용.

-std::not_fn() 어댑터는 C++17부터.이전 버전에서는 std::not1()(단항 함수)과 std::not2()(이항 함수) 어댑터.

-직접 정의 펑터에 not1()을 사용하려면 argument_type과 result_type 두 가지 typedef를 반드시 정의. not2()는  first_argument_type, second_argument_type, result_type.

-쉬운 방법은 인수가 하나면 unary_function, 두 개면 binary_function을 상속해서 함수 객체 클래스 정의. //p.881

* not1()과 not2()는 C++17부터 폐기됐다. unary_function과 binary_function도 C++11부터 폐기됐으며, C++17부터는 공식적으로 삭제됐다. 

-객체 문맥없이 메서드를 알고리즘에 활용하려면 mem_fn() 변환 함수. 알고리즘의 콜백으로 메서드 포인터 전달 시 반환값을 알고리즘의 콜백으로 전달.
 // auto it = find_if(begin(strings), end(strings), mem_fn(&string::empty));

-컨테이너에 객체를 직접 넣지 않고 객체에 대한 포인터를 지정해도 mem_fn()은 똑같이 작동한다.

	18.4.6 invoke()

-C++17부터 std::invoke()(헤더 파일은 <functional>). 모든 호출 가능 개체에 매개변수를 지정해서 호출 가능.
 // invoke(printMessage, "Hello invoke.");

	18.5.1 반복자

-랜덤 액세스 -> 양방향 -> 정방향 -> 입력

-출력 반복자의 요건을 충족하는 반복자를 가변 반복자라 부르고, 그렇지 않은 반복자를 상수 반복자라 부른다.

	18.5.2 불변형 순차 알고리즘

-불변형 순차 알고리즘(non-modifying sequence algorithm): 주어진 범위에서 원소를 검색 혹은 두 범위를 서로 비교하는 함수.

2. 특수 탐색 알고리즘:

-C++17부터 search() 알고리즘에 원하는 탐색 알고리즘 지정 가능. 옵션은 크게 세 가지:
 (default_searcher, boyer_moore_searcher, boyer_moore_horspool_searcher). 모두 <functional>

3. 비교 알고리즘:

-주어진 범위의 원소 비교: equal(), mismatch(), lexicographical_compare(). 비교할 범위가 속한 컨테이너가 달라도 적용 가능.

-mismatch()는 주어진 범위에서 불일치 범위를 가리키는 반복자 리턴.

-lexicographical_compare()는 첫 불일치 원소 중 첫 범위의 원소 < 두 번째 범위의 원소, 첫 범위의 원소 수 < 두 번째 범위의 원소 수면서 일치하면 true.

* 같은 타입 컨테이너 원소 두 개 비교 시 equal(), lexcographical_copare()보다 operator==, operator<.

4. 집계 알고리즘:

-불변형 집계(카운팅) 알고리즘에는 all_of(), any_of(), none_of(), count(), count_if()가 있다.

	18.5.3 가변형 순차 알고리즘

-가변형 알고리즘 중 일부는 원본(source)과 대상(destination)을 모두 지정. 나머지는 즉시 수정.

* 가변형 알고리즘은 대상 범위에 원소 추가 작업 불가. 수정 및 덮어쓰기만 가능. 반복자 어댑터를 이용하면 추가 가능.

* 가변형 알고리즘 대상 범위를 map과 multimap의 범위로 지정 불가. 키를 const로 지정하기 때문에 다른 값을 대입 불가. set과 multiset도 마찬가지다. 
  -> map, set류의 컨테이너에 가변형 알고리즘을 적용하려면 추가 반복자로 처리.

1. transform:

-transform()의 첫 버전은 주어진 범위의 원소마다 콜백을 적용해서 새 원소 생성. 생성된 원소는 인수로 지정한 대상 범위에 저장.

-transform()의 다른 버전은 주어진 범위의 원소 쌍에 대해 이항 함수 호출.

* 가변형 알고리즘 중에는 대상 범위의 마지막 바로 다음 번째 항목을 가리키는 반복자를 리턴하는 것이 많다.

1.copy:

-copy()은 한 범위의 원소를 다른 범위로 복제.

-원본과 대상 범위는 반드시 달라야 하지만 일정 제약사항을 만족한다면 중첩 가능. 

-copy()도 대상 범위에 원소 추가 불가. 덮어쓰기만.

-copy_backward()는 원본의 마지막 원소부터 시작 원소 순으로 복제.

-copy_backward()도 원본과 대상 범위가 서로 달라야 함. 일정 제약 조건 만족 시 중첩 가능.

-copy_if()는 지정 조건을 만족하는 원소를 대상 범위로 복제. 대상 범위는 충분히 커야 한다.

-copy_n()은 원본에서 n개의 원소를 대상으로 복제. 

-copy_n()은 경계값 검사x. 고로 직접 검사

3. move:

-표준 라이브러리는 move()와 move_backward() 알고리즘 제공. 둘다 이동 의미론 적용 -> 이동 대입 연산자 구현 필요.

-인수를 하나만 받는 버전의 move()로 좌측값을 우측값으로 변환. <utility> 헤더 파일.

-인수를 세 개 받는 move()는 컨테이너 사이에 원소 이동.

* move 연산 동안 원본 개체 중 일부는 유효한 상태, 나머지는 불확실한 상태.  move 연산 뒤 원소를 확실한 상태로 만들지 않았다면 그 원소를 사용 x.

4. replace:

-replace()와 replcae_if(): 원소를 새 값으로 교체.

-replace_copy()와 replace_copy_if(). 교체 결과를 복제. 새 원소를 충분히 담을 정도로 대상 범위가 커야 한다.

5. remove:

-주어진 범위에서 특정 조건 만족 원소를 삭제: 반복문을 통해 조건 일치 원소에 erase() 호출하는 것은 메모리 연산량 때문에 비효율적 -> remove-erase 패턴. 그러면 선형 시간에 처리.

-remove()은 원소를 이동 대입 연산으로 교체. remove()는 삭제 범위의 첫 원소를 가리키는 반복자 리턴. 실제 삭제는 remove()부터 적용 뒤 리턴 반복자를 erase()로 삭제 -> remove-erase 패턴.

* remove-erase 패턴으로 구현할 때 반드시 erase()의 두 번째 인수를 지정.

* remove() 계열 함수는 남아 있는 원소의 순서를 유지 -> 안정적인 알고리즘.

6. unique:

-unique()은 remove()의 특수 버전. 같은 원소 연달아 나오는 부분 삭제.

-unique_copy()도 존재.

7. sample:

-sample()은 원본 범위에서 무작위로 n개의 원소를 골라서 리턴, 대상 범위에 저장.

8. reverse:
-reverse()은 주어진 범위에 있는 원소의 순서를 반대로.

9. shuffle:

-shuffle() 알고리즘은 주어진 범위의 원소를 무작위 순으로 재정렬. 성능은 선형 시간이다.

	18.5.4 연산 알고리즘

-표준 라이브러리 제공 연산 알고리즘은 for_each()와 for_each_n() 뿐.

-for_each()은 주어진 범위의 원소마다 콜백 실행, for_each_n()은 주어진 범위의 원소 중 첫 번째부터 n번째 원소까지 콜백 실행.

-for_each()로 펑터의 복제본이 전달됐다가 호출이 끝나면 그 복제본 리턴. 제대로 작동하게 하려면 반드시 리턴값을 캡쳐.

-람다 표현식이나 콜백에서 매개변수를 레퍼런스로 받아서 내용 수정 가능.

	18.5.5 swap()과 exchange() 알고리즘

1. swap():

-std::swap()은 두 값을 효율적으로 맞바꾼다. 이때 가능하다면 이동 의미론 적용.

2. exchange():

-std::exchange()는 <utility> 헤더 파일. 기존 값을 새 값으로 교체한 후 기존 값 리턴.

-exchange()는 이동 대입 연산자 구현에 유용 // mPtr = exchange(rhs.mPtr, nullptr);

	18.5.6 분할 알고리즘

-partition_copy()는 원본에 있는 원소를 복제, 다른 두 대상으로 분할. 어느 대상에 원소를 보낼지는 프레디케이트의 실행 결과에 따라 달라진다.

-partition_copy()는 반복자 쌍 리턴. 첫 범위 마지막 복제 원소 바로 다음 지점, 두 번째 범위 마지막 복제 원소의 바로 다음 지점을 가리키는 반복자.

-partition()은 프레디케이트에서 true인 원소가 false인 원소보다 앞에 나오도록 정렬. 분할된 범위 내에서는 원래 순서가 유지x.

	18.5.7 정렬 알고리즘

-순차 컨테이너에만 정렬 알고리즘 적용 가능.

-sort()은 주어진 범위에 있는 원소를 O(NlogN) 시간에 정렬.

-stable_sort()는 주어진 범위에서 같은 원소에 대해서는 원본 순서 유지 -> sort()보다 성능 좀 떨어짐.

	18.5.8 이진 탐색 알고리즘

-탐색 알고리즘 중 정렬된 시퀀스, 검색 대상을 기준으로 분할된 시퀀스에 대해서만 적용하는 이진 탐색 알고리즘이 있다: 
 binary_search(), lower_bound(), upper_bound(), equal_range()

-lower_bound()은 정렬된 범위에서 주어진 값보다 작지 않은(크거나 같은) 원소 중 첫 번째 원소.

-binary_search()은 로그 시간에 원소 검색. 주어진 범위에서 값을 찾으면 true 리턴, 그렇지 않으면 false.

	18.5.9 집합 알고리즘

-집합 알고리즘(set algorithm)은 정렬된 범위라면 어떤 것에도 적용 가능.

-includes()은 부분집합 판별 표준 함수. 정렬된 범위 중 한쪽의 원소가 다른 쪽 범위에 포함되는지 검사. 포함 관계 판단 시 순서 고려x.

-set_union(), set_intersection(), set_difference(), set_symmetric_difference()은 각각 합집합(union), 교집합(intersection), 차집합(difference), 대칭 차집합(symmetric difference).

* 집합 연산 결과를 담을 범위는 충분히 크게 지정.

* 연관 컨테이너에서 구한 반복자 범위에는 결과 저장 불가. 키를 변경할 수 없기 때문.

-merge()을 사용하면 정렬된 두 범위를 하나로 합친다. 정렬 순서는 그대로 유지된다. 선형 시간에 처리. 

-두 범위를 합친 결과를 sort()해도 merge()와 같은 효과. 대신 merge()에 비해 성능이 떨어진다.

	18.5.10 최대/최소 알고리즘

-min()과 max()은 각각 최소 원소와 최대 원소의 const 레퍼런스 리턴다. minmax()은 최솟값과 최댓값 쌍 리턴. 이 알고리즘들은 반복자를 매개변수로 리턴받지 않는다. 

-min_element(), max_element(), minmax_element()는 반복자로 지정한 범위에 대해 주어진 작업을 처리한다.

-std::clamp()는 <algorithm>에 정의.

	18.5.11 병렬 알고리즘

-C++17부터 병렬 처리 알고리즘이 표준 라이브러리에 추가. 병렬 실행 알고리즘은 실행 정책(execution policy) 옵션을 첫 번째 매개변수로 받는다.

-실행 정책 세 가지. 모두 <execution>의 std::execution 네임스페이스 아래에 정의.
 seq, par, par_unseq // sort(std::execution::par, begin(myVector), end(myVector));

	18.5.12 수치 처리 알고리즘

1. inner_product:

-inner_product()는 <numeric>에 정의. 두 시퀀스(벡터)의 내적(inner product)를 구한다.

2. iota:

-<numeric>에 정의. 주어진 범위에서 주어진 값으로 시작해서 operator++로 값을 순차적 생성 방식으로 시퀀스를 만든다.

3. gcd()과 lcm():

-최대공약수와 최소공배수 리턴. <numeric>.

4. reduce():

-std::accumulate()은 병렬 실행 지원x. std::reduce()은 병렬 실행 옵션 지정 가능.
 // reduce(std::execition::par_unseq, cbegin(vec), cend(vec));

5. transform_reduce:

-std::inner_product()은 병렬 실행 지원x.

6. 스캔 알고리즘:

-C++17부터 네 가지 스캔 알고리즘(exclusive_scan(), inclusive_scan(), transform_exclusive_scan(), transform_inclusive_scan()) 제공.

-transform_exclusive_scan()과 transform_inclusive_scan()은 합을 구하기 전 원소에 단항 함수를 적용.

	19.1 현지화

-아스키 코드는 7비트로 구성됐으며 주로 8비트 char 타입으로 표현한다.

	19.1.1 스트링 리터럴 현지화하기

-현지화 원칙: 소스 코드에 특정 언어로 된 스트링을 절대로 x. 단, 개발 과정에서 임시로 사용하는 디버그 스트링은 예외다.

-윈도우 앱 개발 환경은 현지화 관련 스트링을 STRINGTABLE란 리소스로 분리. 현지화 시 리소스에 담긴 내용만 번역.

	19.1.2 와이드 문자

-C++는 wchar_t 확장 문자 타입 기본 제공. C++ 표준은 wchar_t 크기 명확히 정의x. wchar_t의 크기가 일정하다고 가정하면 위험.

-비영어권 사용자 대상 프로그램을 작성 시 wchar_t 타입으로 작성이 유리. L을 붙이면 wchar_t 리터럴 -> 와이드 문자 인코딩 적용.

-흔히 사용하는 타입, 클래스마다 와이드 문자 버전 존재. ex) wstring, wofstream, wifstream, wcout, wcin, wcerr, wclog

	19.1.3 서구권이 아닌 문자 집합

-와이드 문자 도입만으로도 현지화 큰 도움. 문자가 차지하는 공간을 결정 -> 아스키 코드처럼 각 문자를 코드 포인트라 부르는 숫자 형태로 표현 가능.

-유니버설 문자 집합은 ISO 10646이라는 국제 표준이고, 유니코드도 국제 표준 문자 집합. 두 표준 인코딩 방식을 따로.

-앱마다 인코딩 방식 다를 수 있음.

-크로스 플랫폼 지원 시 wchar_t의 크기의 비명확성 인지. char16_t와 char32_t 이용 시 문제 대처 용이.

-wchar_t에 비해 char16_t나 char32_t가 좋은 점: 문자 크기 16비트 또는 32비트로 보장.

-스트링 리터럴 앞에 특정한 접두어를 붙여서 타입을 지정할 수 있다:
 u8: UTF-8 인코딩을 적용한 char 스트링
 u: char16_t 스트링 리터럴, 컴파일러에 __STDC_UTF_16__이 정의돼 있으면 UTF-16.
 U: char32_t 스트링 리터럴, 컴파일러에 __STDC_UTF_32__이 정의돼 있으면 UTF-32.
 L: wchar_t 스트링 리터럴, 인코딩 방식은 컴파일러 의존.

-std::string 외에 wstring, u16string, u32string도 제공.

-멀티바이트 문자(multibyte character)란 여러 바이트로 구성된 문자. 인코딩 방식은 컴파일러 의존.

-cout이나 cin에 대해 char16_t, char32_t 지원 버전 x -> char16_t, char32_t 타입 스트링 콘솔 입출력 난해 -> 서드파티 라이브러리를 찾아보자

	19.1.4 변환

-다양한 방식으로 인코딩된 문제를 쉽게 변환하도록 codecvt 클래스 템플릿 제공. <locale> 헤더 파일.
 // codecvt<char32_t, char, mbstate_t>, codecvt<char16_t, char, mbstate_t>

	19.1.5 로케일과 패싯

-특정 데이터를 문화에 따라 묶는 방식을 C++에서는 로케일이라 부른다. 로케일은 날짜 포맷, 시간 포맷 등으로 구성. 이러한 요소를 패싯이라 부른다. //U.S.English, 날짜 포맷

-로케일을 쉽게 다루게 해주는 서드파티 라이브러리도 많다.

1. 로케일 사용법:

-I/O 스트림 사용 시 데이터 포맷을 특정한 로케일에 맞춘다. 로케일은 스트림에 붙일 수 있는 객체로서 <locale> 헤더 파일에 정의돼 있다. 로케일 이름은 구현마다 다르다.

-대부분의 OS는 로케일 지정 메커니즘 제공. std::locale 생성자에 공백 스트링을 전달 시 사용자 환경에 정의된 locale로 생성.

-디폴트 로케일은 사용자 로케일이 아니라 클래식/뉴트럴 로케일. 클래식 로케일은 ANSI 관례를 따르며 C로 표기.

-locale 객체로부터 로케일 정보 조회가능.

* 나중에 다시 읽을 데이터 파일에 쓸 때는 클래식 로케일 "C"를 지정. 반면 사용자 인터페이스에 데이터를 출력 시 사용자 로케일 ""를 지정.

2. 문자 분류:

-<locale>에 std::isspace(), isdigit(). 이들 함수는 두 개의 매개변수(분류할 문자와 분류에 적용할 로케일)를 받는다.

3. 문자 변환:

-<locale>에 std::toupper()와 std::tolower() 함수. 이들 함수는 두 개의 매개변수(변환할 문자와 변환에 적용할 로케일)를 받는다.

4. 패싯 사용법:

-특정한 로케일에서 패싯을 구하려면 std::use_facet() 호출. // use_facet<moneypunct<wchar_t>>(locale("en-GB"));
 문장 가장 안쪽의 템플릿 타입은 사용할 문자 타입 지정. 주로 wchar_t나 char.

	19.2 정규표현식

-<regex> 헤더 파일에 정의돼 있다.

-정규표현식은 스트링을 표현하는 패턴.

-정규 표현식에 대한 문법은 다양. C++는 ECMAScript를 정규표현식의 기본 문법으로 사용.

* 정규표현식을 처음 접한다면 기본 문법은 ECMAScript를 사용.

	19.2.1 ECMAScript 문법

-정규표현식 패턴은 매치하려는 문자들을 표현한 것이다.

-다음 특수 문자를 제외, 나머지 문자는 표현식 그대로 매치:
 ^ $ \ . * + ? ( ) [ ] { } |

-특수 문자 매치 시 이스케이프시킨다.

1. 앵커:

-^와 $를 앵커(Anchor)라 부른다. ^는 줄끝 표현 문자 바로 다음 지점고, $는 줄끝 표현 바로 그 지점을 표현. ^와 $는 스트링의 시작과 끝 표현.

2. 와일드카드:

-와일드카드 문자인 .은 개행 문자를 제외한 모든 문자 매치.

3. 선택 매치:

-수직선 | 은 '또는' 관계 표현. a|b는 a나 b를 매치다.

4. 그룹:

-소괄호 ()는 부분 표현식(subexpression) 또는 캡처 그룹(capture group)을 표현. 사용 목적:
 -캡쳐 그룹은 원본 스트링에서 부분 시퀀스를 찾을 때 사용.
 -매치하는 동안 역참조(back reference)를 위해.
 -치환 작업에서 특정한 항목을 찾을 때.

5. 반복:

-*는  패턴을 0번 이상 매치.
-+는  패턴을 한 번 이상 매치.
-?는  패턴을 0번 또는 한 번만 매치.
-{...}는 반복 횟수 제한 표현. a{n}은 a를 정확히 n번 반복한 것 매치. a{n, }는 n번 이상 반복한 것 매치. a{n, m}은 n번 이상, m번 이하 반복한 것 매치.

-반복 문자는 문장에서 매치된 항목 중 가장 긴 것을 찾는 그리디(greedy) 방식 적용. 

-논-그리디(non-greedy) 방식을 적용하려면 반복 문자 뒤에 ?를 붙인다. 논-그리디 방식은 반복 횟수를 최소화하는 방식으로 매치.

6. 연산 우선순위:

-수학 연산처럼 정규표현식의 연산도 우선순위가 정해져 있다:
 -원소(element): a와 같은 기본 구성 요소를 말한다.
 -한정자(quantifier): +, *, ?, {...} 등은 왼쪽에 나온 원소에 우선 적용된다.
 -연결(concatenation): 한정자보다 우선순위가 낮다
 -선택(alternation): 우선순위가 가장 낮다.

-소괄호에 따라 우선순위 변경 가능. 소괄호로 묶으면 캡처 그룹이 돼버린다. 캡처 그룹을 생성하지 않으려면 (?:...). // ab+(?:c|d)

7. 문자 집합 매치:

-문자 집합(character set)은 대괄호로 묶어서 지정. [abc]라고 적으면 a, b 또는 c와 매치하는 것을 찾는다. 맨 앞에 ^ -> 부정 연산. ^뒤에 나온 문자를 제외한 나머지를 찾는다.

-대괄호를 이용한 범위 지정 표기법 [a-zA-Z]. a부터 z, 그리고 A부터 Z 사이에 나오는 문자를 모두 매치. (-)을 매치하려면 반드시 이스케이프.

-문자 클래스로 문자 집합 지정 가능. 문법은 [:name:] // [[:alpha:]]* == [a-zA-Z]*

-숫자를 비롯한 몇몇 매치 작업은 자주 수행하기 때문에 축약 표현을 제공한다:
 -[0-9]+ == [[:digit:]]+ == [[:d:]]+ == \d+

8. 단어 경계:

-단어 경계를 매치하려면 \b를 지정한다. 반대로 단어 경계를 제외한 나머지를 매치하려면 \B를 지정한다.

9. 역참조:

-역참조(back reference)로 정규표현식 안 캡처 그룹 참조 가능. \n은 n번째 캡처 그룹. 이때 n > 0 // (\d+)-.*-\1

10. 미리보기:

-정규표현식은 ?=인 positive lookahead와 ?!인 negative lookahead 지원. 

-양의 미리보기 -> 지정 패턴이 반드시 나와야 함. 음의 미리보기 -> 나오지 않아야 함. 미리보기 패턴에 매치된 문자는 정규 표현식 매치 결과에 포함 x.

11. 정규표현식과 로 스트링 리터럴:

-\는 정규표현식 문법 안에서도 특수 문자이기 때문에 \\와 같이 이스케이프. \는 C++에서도 특수 문자 -> \\\\.

-로(raw) 스트링 리터럴로 쉽게 표현 가능.

	19.2.2 regex 라이브러리

-정규표현식 라이브러리 관련 내용은 모두 <regex>의 std 네임스페이스 아래. 

-정규 표현식 라이브러리에서 기본 제공 템플릿 타입:
 -basic_regex: 특정한 정규표현식을 표현하는 객체
 -match_results: 정규표현식에 매치된 서브스트링으로서 캡처 그룹을 모두 포함. sub_match의 묶음.
 -sub_match: 반복자와 입력 시퀀스에 대한 쌍을 담은 객체. 반복자는 매치된 캡쳐 그룹을 표현. 

-regex_search(), regex_match(), regex_replace() 세 가지 알고리즘을 제공.

-regex 라이브러리는 다음과 같이 정규표현식 반복자에 대해 두 가지 타입을 정의하고 있다:
 regex_iterator: 원본 스트링에서 패턴에 매치되는 모든 항목에 대해 반복.
 regex_token_iterator: 매치되는 모든 캡처 그룹에 대해 반복.

	19.2.3 regex_match()

-regex_match()은 주어진 원본 스트링을 주어진 정규 표현식 패턴으로 비교.

-match_results 객체를 regex_match()를 호출 때 지정 시 매치 결과들이 match_results 객체에 채워진다. 

	19.2.4 regex_search()

-regex_match()은 원본 스트링 전체가 정규표현식에 매치될 때만 true. 만약 서브스트링도 찾고 싶다면 regex_search() 사용.

* 원본 스트링에 매치되는 결과를 모두 찾기 위해 루프 안에서 regex_search() 호출하는 방식 x. 그 대신 regex_iterator나 regex_token_iterator를 사용.

-match_results 객체는 prefix()와 suffix() 메서드도 제공. 각각 매치 결과의 앞뒤 스트링 리턴.

	19.2.5 regex_iterator

-원본 스트링에서 패턴에 매치하는 모든 항목을 추출하기 위해 루프 안에서 regex_search()를 호출하면 안 된다. 그 대신 regex_iterator나 regex_token_iterator를 사용해야 한다.

	19.2.6 regex_token_iterator

-regex_token_iterator를 이용하면 매치된 결과 중 캡처 그룹 전체 또는 선택한 캡처 그룹에 대해서만 루프를 돌 수 있다.

-생성자 네 버전 모두 입력 시퀀스를 시작과 끝 반복자로 지정한다. 옵션으로 SubMatches 매개변수를 지정할 수 있다. 이 값은 반복의 기준이 되는 캡처 그룹을 지정한다. SubMatches는 다음
 네 가지 방식 중 하나로 지정한다:
 -반복하려는 캡쳐 그룹의 인덱스를 나타내는 정숫값 하나로 지정한다.
 -반복하려는 캡쳐 그룹의 인덱스를 나타내는 정숫값을 vector에 담아 지정한다.
 -캡처 그룹 인덱스에 대한 initializer_list로 지정한다.
 -캡처 그룹 인덱스에 대한 C 스타일 배열로 지정한다.

-SubMatches 매개변수를 지정하지 않거나 그 값을 0으로 지정하면 인덱스가 0인 캡처 그룹을 모두 반복하는 반복자를 받게 된다. 다시 말해 정규표현식 전체에 매치되는 서브스트링에 대해 
 반복하게 된다.

-regex_token_iterator는 소위 필드 분할(field splitting, 또는 토큰화) 작업에도 활용된다. regex_token_iterator 생성자에서 반복할 캡처 그룹 인덱스를 -1로 지정하면 토큰화 모드로 작동한다.

-토큰화 모드로 실행될 때는 시퀀스에서 주어진 정규표현식에 매치되지 않은 모든 서브르트링에 대해 반복한다.

	19.2.7 regex_replace()

-regex_replace() 알고리즘은 정규표현식과 매치된 서브스트링을 대체할 포맷 스트링(formatting string)을 인수로 받는다.

-regex_replace() 알고리즘 중 두 가지 버전은 지정한 출력 반복자에 교체한 결과를 쓴 다음 그 출력 반복자를 리턴한다. 그리고 입력 시퀀스는 시작과 끝 반복자로 지정한다.

-regex_replace() 알고리즘에 다양한 플래그를 인수로 지정해서 구체적인 작동 방식을 변경할 수 있다:
 regex_constants::format_default, regex_constants::format_no_copy, regex_constants::format_first_only

	20. 여러 가지 유틸리티 라이브러리

	20.1 ratio 라이브러리

-ratio 라이브러리를 이용하면 유한 유리수를 컴파일 시간에 정확히 표현할 수 있다.

-유리수를 구성하는 분자와 분모는 std::intmax_t 타입의 컴파일 시간 상수로 표현한다. 이 타입은 부호 있는 정수 타입으로 최댓값은 컴파일러마다 다르다.

-ratio 객체를 정의하는 방식은 일반 객체와 다르다. 메서드를 호출할 수 없으며 타입 앨리어스처럼 사용.
 // using r1 = ratio<1, 60>;

-r1 유리수의 분자와 분모는 컴파일 시간 상수이며, 다음과 같이 접근한다:
 intmax_t num = r1::num; intmax_t den = r1::den;

-ratio는 컴파일 시간 상수(compile-time constant)라서 분자와 분모가 컴파일 시간에 결정된다.

-ratio는 유리수의 덧셈, 뺄셈, 곱셈, 나눗셈을 지원. 이 연산도 모두 컴파일 시간 처리 -> 타입 앨리어스를 이용한 특수 템플릿 으로 처리. 
 산술 ratio 템플릿: ratio_add, ratio_subtract, ratio_multiply, ratio_divide가 있다.

-C++ 표준은 ratio 비교 연산 템플릿(ratio_equal, ratio_not_equal, ratio_less, ratio_less_equal 등)도 제공. 

-비교 연산 템플릿은 결과를 표현하는 std::bool_constant란 타입을 새로 정의한다. bool_constant는 타입과 컴파일 시간 상숫값을 저장하는 struct 템플릿인 std::integral_constant 중 하나다.
 ratio 비교 연산 템플릿의 결과는 bool_constant<true>나 bool_constant<false> 중 하나가 된다.

-bool_constant나 integral_constant에 대한 값은 value라는 데이터 멤버로 접근할 수 있다.

	20.2 chrono 라이브러리

-chrono 라이브러리는 시간을 다루는 클래스로서 다음과 같은 요소로 구성돼 있다:
 duration, clock, time_point

-std::chrono 네임스페이스에 정의된 것을 사용하려면 반드시 <chrono> 헤더 파일을 인클루드해야 한다.

	20.2.1 duration

-duration(기간)은 두 지점 사이의 시간 간격(interval)을 표현하는 클래스 템플릿으로서, 틱(tick)과 틱 주기(tick period)에 대한 값을 저장한다. 틱 주기란 두 틱 사이의 초 단위 간격으로서
 컴파일 시간 상수인 ratio로 표현한다.

-duration 템플릿은 두 가지 매개변수를 받도록 정의돼 있다:
 template<class Rep, class Period = ratio<1>> class duration {...}
 Rep은 틱 수를 저장하는 변수 타입이며, 반드시 산술 타입으로 표현한다. 두 번째 템플릿 매개변수인 Period는 유리수 상수로서 틱의 주기를 표현한다.

-생성자에는 세 가지 버전이 있다. 디폴트 생성자와 틱 수에 대한 값 하나를 인수로 받는 버전, 그리고 다른 duration을 인수로 받는 생성자가 있다.

-duration은 산술 연산과 비교 연산을 제공한다.

-분 단위를 초 단위로 변환할 때는 원본 타입이 정수라면 부동소수점 타입으로 지정하지 않아도 된다. 정수로 표현된 분 단위 값을 초 단위로 변환할 때는 항상 결과가 정수이기 때문이다.

-duration 라이브러리는 std::chrono 네임스페이스 아래에 다음과 같은 표준 duration 타입도 제공한다:
 nanoseconds, microseconds, miliseconds, seconds, minutes, hours

-기본 제공되는 duration이 정수 타입을 사용하기 때문에 변환된 결과를 정수로 표현할 수 없으면 컴파일 에러가 발생할 수 있다. 정수 나눗셈의 결과로 발생한 나머지는 대부분 버리지만 
 ratio 타입으로 구현된 duration에 대해서는 0이 아닌 나머지가 나올 여지가 조금이라도 있는 연산을 컴파일 에러로 처리한다.

-duration을 생성할 때 표준 사용자 정의 리터럴인 'h', 'min', 's', 'ms', 'us', 'ns' 등을 붙일 수 있다. 이러한 리터럴은 엄밀히 말해 std::literals::chrono_literals 네임스페이스에 정의돼 있지만, 
 using namespace std::chrono로도 접근할 수 있다.

	20.2.2 clock

-clock은 time_point와 duration으로 구성된 클래스다.

-C++ 표준은 clock을 세 가지 버전으로 정의한다:
 -system_clock으로서 시스템 관점의 실시간 클럭을 표현한다.
 -steady_clock으로서 time_point가 절대로 감소하지 않도록 보장해준다.
 -high_resolution_clock으로서 최소 틱 주기를 가진다.

-현재 사용하는 컴파일러의 종류에 따라 high_resolution_clock이 steady_clock이나 system_clock과 같을 수 있다.

-각 버전의 clock마다 now()란 static 메서드가 있다. 이 메서드는 현재 시각을 time_point로 리턴한다.

-system_clock은 time_point와 time_t 타입의 C 스타일 시간을 상호 변환하는 static 헬퍼 함수도 두 개 제공한다. // to_time_t(), from_time_t() time_t 타입은 <ctime> 헤더 파일에 정의돼 
 있다.

-localtime() 함수는 time_t 값을 현지 시각(tm)으로 변환한다. 이 함수는 <ctime> 헤더 파일에 정의돼 있다.

-put_time() 스트림 매니퓰레이터는 <iomanip> 헤더에 정의돼 있다.

-시간을 스트링으로 변환하려면 <ctime>에 정의된 C 스타일 strftime() 함수나 std::stringstream을 사용한다. strftime() 함수를 사용하려면 주어진 시간을 사람이 읽기 좋은 포맷으로 변환한
 결과를 충분히 담을 정도로 큰 버퍼를 지정해야 한다.

-실행 시간을 chrono를 통해 측정할 때 ms(밀리초) 단위의 시간차가 너무 작으면 정확도가 떨어진다. 이럴 때는 실행 시간이 길어지도록 루프의 반복 횟수를 늘려야 한다. 시간 간격이 짧을 때
 정확도가 떨어지는 이유는 대다수의 OS가 밀리초 단위를 지원하기는 하지만 갱신 주기가 10ms나 15ms 정도로 다소 길기 때문이다. 그래서 타이머의 한 틱보다 짧은 단위로 발생한 이벤트가
 0 단위 시간으로 보이고, 1에서 2틱 사이에 발생한 이벤트가 1 단위 시간으로 보이는 게이팅 에러(gating error)가 발생한다. 이런 타이머로 시간을 측정할 때는 반드시 대상 연산의 실행 시간
 을 타이머의 최소 틱 단위보다 크게 구성해야 오차를 최소화할 수 있다.

	20.2.3 time_point

-time_point는 특정한 시점을 표현하는 클래스로서 에포크(epoch, 기준 시간)를 기준으로 측정한 duration으로 저장한다. time_point는 항상 특정한 clock을 기준으로 표현하는데, 이 clock의 
 의 시작 시간이 에포크가 된다. 에포크와 duration은 OS마다 다를 수 있다.

-time_point 클래스는 time_since_epoch()란 함수를 제공한다. 이 함수는 clock의 에포크와 저장된 시점 사이의 duration을 리턴한다.

-두 시점을 비교하는 비교 연산자도 제공한다. 이를 위해 최소 시점을 리턴하는 min()과 최대 시점을 리턴하는 max()라는 static 메서드가 정의돼 있다.

-time_point 클래스의 생성자에는 세 가지 버전이 있다:
 time_point()
 time_point(const duration& d)
 template<class Duration2> time_point(const time_point<clock, Duration2>& t);

-각 time_point는 clock에 연계돼 있다. time_point를 생성하려면 템플릿 매개변수에 clock을 지정해야 한다.

-time_point를 변환하는 작업은 duration과 마찬가지로 명시적으로 할 수도 있고, 자동으로 할 수도 있다.

-자동 변환으로 인해 데이터 손실이 발생한다면 time_point_cast()로 명시적으로 변환한다.

	20.3 무작위수 생성

-C++11 이전에는 C 스타일 함수인 srand()와 rand()만으로 무작위수를 생성할 수밖에 없었다. 애플리케이션에서 srand() 함수를 한 번 호출한 뒤 무작위수 생성기를 시드(seed)로 초기화해야 
 했다(이를 시딩seeding이라 부른다). 시드값을 주로 현시 시스템 시각을 사용한다.

* 소프트웨어로 무작위수를 생성하려면 시드값을 잘 정해야 한다. 무작위수 생성기를 초기화할 때마다 같은 시드를 사용하면 매번 동일한 무작위수가 생성된다. 그래서 현재 시스템 시각을
  시드값으로 많이 사용하는 것이다.

-기존 C 스타일 rand() 함수는 0과 RAND_MAX 사이의 무작위수를 생성한다. RAND_MAX는 표준에서 최소 32767 이상이라고 정의했다.

-아쉽게도 rand()의 낮은 자리 비트의 무작위성은 그리 높지 않다.

* 소프트웨어 기반 무작위수 생성기는 진정한 의미의 무작위수를 생성할 수 없다. 그래서 의사(pseudo) 무작위수 생성기라고도 부른다. 무작위인 것처럼 보이게 만드는 수학 공식에 따라 
  생성하기 때문이다.

-C++11부터 다양한 알고리즘과 분포로 무작위수를 생성하는 라이브러리가 추가됐다. 이 라이브러리는 <random> 헤더 파일에 정의돼 있으며, 크게 세 가지 요소(엔진, 엔진 어댑터, 분포)로
 구성된다. 무작위수 엔진은 실제로 무작위수를 생성하고, 그 뒤에 생성될 무작위수의 상태를 저장한다. 무작위수 분포는 생성된 무작위수의 범위와 그 범위 안에서 무작위수가 수학적으로 
 분포되는 방식을 결정한다. 무작위수 엔진 어댑터는 무작위수 엔진의 결과를 수정한다.

	20.3.1 무작위수 엔진

-<random>은 다음과 같은 무작위수 엔진은 제공한다:
 random_device, linear_congruential_engine, mersenne_twister_engine, subtract_with_carry_engine

-random_device 엔진은 소프트웨어 기반이 아니다. 컴퓨터에 특수 하드웨어가 장착돼 있어야 쓸 수 있는 진정한 비결정적(non-deterministic) 무작위수 발생기다

-현재 사용하는 컴퓨터에 특수 하드웨어가 없을 때는 소프트웨어 알고리즘 중 아무거나 적용하도록 정의돼 있다. 어떤 알고리즘을 적용할지는 라이브러리 디자이너가 결정한다.

-무작위수 발생기의 성능은 엔트로피(entropy, 무질서도)로 측정한다. random_device 클래스에서 제공하는 entropy() 메서드는 소프트웨어 기반 의사 무작위수 생성기를 사용할 때는 0.0을
 리턴하고, 하드웨어 장치를 사용할 때는 0이 아닌 값을 리턴한다. 이 때 리턴하는 0이 아닌 값은 장착된 디바이스의 엔트로피에 대한 측정치로 결정된다.

-random_device는 대체로 의사 무작위수 생성 엔진보다 느리다. 그래서 생성해야 할 무작위수가 아주 많다면 의사 무작위수 생성 엔진을 사용하고, random_device는 이 엔진의 시드를 생성
 하는 데만 사용하는 것이 좋다.

-random_device이외의 엔진의 인스턴스를 생성하려면 수학 매개변수를 지정해야 하는데, 이 값을 정하는 방법이 쉽지 않다. 그래서 표준에서는 몇 가지 엔진을 미리 정의해서 제공한다.
 그중 하나가 mt19937이라는 mersenne_twister_engine이다.

-일반적으로 의사 무작위수 생성 기법을 전공한 수학자가 아니라면 매개변숫값을 변경할 일은 없기에 C++에서 제공하는 타입 앨리어스를 사용하는 것이 낫다.


	20.3.2 무작위수 엔진 어댑터

-무작위수 엔진 어댑터(random number engine adaptor)는 무작위수 생성에 사용하는 엔진(베이스 엔진)의 결과를 수정할 때 사용한다.

-discard_block_engine 어댑터는 베이스 엔진에서 생성된 값 중에서 일부를 제거하는 방식으로 무작위수를 생성한다. 이 어댑터는 세 가지 매개변수를 받는다. 첫 번째는 연결할 엔진에 대한
 것이고, 두 번째는 블록 크기인 p이고, 세 번째는 사용된 블록 크기인 r이다. 베이스 엔진은 p개의 무작위수를 생성하는 데 사용된다. 그러면 어댑터는 p-r개의 무작위수를 제거하고, 나머지
 r개의 무작위수만 리턴한다.

-independent_bits_engine 어댑터는 매개변수 w로 지정된 비트 수로부터 베이스 엔진이 생성한 여러가지 무작위수를 조합하는 방식으로 무작위수를 생성한다.

-shuffle_order_engine 어댑터는 베이스 엔진과 똑같은 무작위수를 생성하지만 리턴 순서는 다르다.

	20.3.3 기본으로 제공하는 엔진과 엔진 어댑터

-의사 무작위수 엔진과 엔진 어댑터의 매개변수를 건드리는 것보다 표준에서 정의해둔 엔진과 엔진 어댑터를 사용하는 것이 바람직하다. // p.983

-소프트웨어 기반 엔진으로 무작위수를 생성하기 위해서는 항상 엔진과 분포를 지정해야 한다. std::bind() 유틸리티를 사용하면 엔진과 분포를 지정하지 않고도 무작위수를 생성할 수 있다.

-auto gen = bind(dist, eng);에서 gen()의 타입을 정확히 몰라도 gen()을 무작위수 생성기를 사용하려는 다른 함수에 인수로 전달할 수 있다. 하나는 std::function<int()> 타입으로 매개변수를
 지정하는 것이고, 다른 하나는 함수 템플릿으로 지정하는 것이다.

	20.3.5 무작위수 분포

-분포란 일정한 범위에서 숫자가 분포된 방식을 표현하는 수학 공식이다.

	20.4 optional

-std::optional은 <optional>에 정의돼 있으며, 어떤 타입의 값이 있거나 없을 수 있는 것을 표현한다. optional은 함수의 매개변수를 옵션으로 지정할 때 사용한다. 또한 함수의 리턴
 타입으로도 지정해서 그 함수가 값을 리턴할 수도 있고 리턴하지 않을 수도 있다는 것을 표현하기도 한다(nullopt).

-optional을 이용하면 리턴값이 없다는 것을 nullptr, end(), -1, EOF 등과 같은 특수한 값으로 표현하지 않아도 된다.

-optional에 값이 실제로 있는지 확인하려면 has_value() 메서드를 호출하거나 optional을 곧바로 if 문의 조건으로 사용하면 된다.

-optional에 값이 있다면 value() 메서드나 역참조 연산자로 값을 가져올 수 있다.

-값이 없는 optional에 value() 메서드를 호출하면 bad_optional_access 익셉션이 발생한다.

-value_or()을 호출하면 optional에 값이 있으면 그 값을 리턴하고, 값이 없으면 다른 값을 리턴한다.

-optional에 레퍼런스를 직접 저장할 수는 없다. 그래서 optional<T&>와 같이 적으면 작동하지 않는다. 레퍼런스를 담고 싶다면 optional<T*>, optional<reference_wrapper<T>>또는 
 optional<reference_wrapper<const T>>로 표현한다.

-std::reference_wrapper<T>는 std::ref(), reference_wrapper<const T>는 cref()로 생성할 수 있다.

	20.5 variant

-std::variant는 주어진 타입 집합 중에서 어느 한 타입의 값을 가지며, <variant>에 정의돼있다. variant를 정의하려면 여기에 담길 수 있는 타입들을 반드시 지정해야 한다.
 // variant<int, string, float> v;
 이렇게 별도로 초기화하지 않고 선언된 variant는 디폴트값을 첫 번째 타입인 int로 설정한다. 이렇게 variant를 디폴트로 생성하려면 반드시 여기에 지정한 첫 번째 타입이 디폴트 생성을
 지원해야 한다.

-variant는 언제나 값을 하나만 가질 수 있다.

-variant에 현재 저장된 값의 타입에 대한 인덱스를 알고 싶다면 index()를 호출하면 된다.

-std::holds_alternative() 함수 템플릿을 이용하면 variant가 인수로 지정한 타입의 값을 담고 있는지 확인할 수 있다.

-std::get<index>()나 std::get<T>()를 이용하면 variant에 담긴 값을 가져올 수 있다. 이 함수를 호출할 때 가져오려는 값의 타입이나 인덱스를 잘못 지정하면 bad_variant_access 예외가
 발생한다.

-익셉션이 발생하지 않게 하려면 std::get_if<index>()나 std::get_if<T>() 헬퍼 함수를 사용한다. 이 함수는 variant에 대한 포인터를 인수로 받아서 요청한 값에 대한 포인터를 리턴한다.
 에러가 발생하면 nullptr를 리턴한다.

-std::visit() 헬퍼 함수도 있는데, variant에 대한 비지터(visitor) 패턴을 적용할 때 사용한다.
 // visit(MyVisitor(), v);
 이렇게 하면 오버로딩된 함수 호출 연산자 중에서 현재 variant에 저장된 값에 적합한 것이 호출된다.

-optional과 마찬가지로 variant에도 레퍼런스를 직접 저장할 수 없다. 포인터를 저장하거나 reference_wrapper<T> 또는 reference_wrapper<const T>의 인스턴스로 저장해야 한다.

	20.6 any

-std::any는 모든 타입의 값을 저장하는 클래스로서 <any> 헤더 파일에 정의돼 있다. any 인스턴스를 생성했다면, 이 인스턴에 대해 값이 있는지, 있다면 타입은 뭔지 조회할 수 있다.

-any에 담긴 값을 구하려면 any_cast()를 사용해야 한다. 오류가 발생하면 bad_any_cast 익셉션이 발생한다.

-any의 인스턴스를 표준 라이브러리 컨테이너에 저장할 수도 있다. 이렇게 하면 한 컨테이너에 다양한 타입의 데이터를 저장할 수 있다. 한 가지 단점은 값을 가져올 때마다 명시적으로
 any_cast를 적용해야 한다는 것이다.

-any 인스턴스에도 레퍼런스를 직접 담을 수 없다. 포인터로 저장하거나 reference_wrapper<T>나 reference_wrapper<const T>의 인스턴스로 저장해야 한다.

	20.7 tuple

-std::tuple은 pair를 일반화한 클래스로서 <tuple> 헤더 파일에 정의돼 있다. tuple은 여러 수를 하나로 묶어서 저장할 수 있고, 각각의 타입도 따로 지정할 수 있다. pair와 마찬가지로 tuple도
 크기와 값의 타입이 고정돼 있으며 컴파일 시간에 결정된다.

-tuple은 tuple 생성자로 만든다. 이 때 템플릿 타입과 실젯값을 모두 지정한다.

-std::get<i>()는 tuple의 i번째 원소를 가져온다.

-get<i>()가 정확한 타입을 리턴했는지 확인하려면 <typeinfo>에 정의된 typeid()를 호출하면 된다.

* typeid()가 리턴하는 스트링은 컴파일러마다 다를 수 있다.

-tuple에 담긴 값에 대해 반복하기는 쉽지 않다. 루프문 안에서 get<i>(myTuple)만 호출하는 식으로 간단히 구현할 수 없다. i의 값이 컴파일 시간에 확정돼야 하기 때문이다. 이럴때는 템플릿
 메타프로그래밍으로 구현하면 된다.

-tuple의 크기는 std::tuple_size 템플릿으로 알아낼 수 있다. tuple_size를 이용하려면 원하는 tuple의 인스턴스(t1)가 아닌 타입을 구체적으로 지정해야 한다. tuple의 타입을 정확히 모르면
 decltype()로 알아낼 수 있다.

-C++17부터 생성자에서 템플릿 인수를 추론하는 기능이 추가됐다. 그래서 tuple을 생성할 때 템플릿 타입 매개변수를 생략하면 생성자에 전달된 인수의 타입을 컴파일러가 알아낸다.

-레퍼런스나 const 레퍼런스를 담은 tuple을 템플릿 인수 추론 기능을 적용해서 생성하려면 ref()나 cref()를 사용해야 한다(<functional> 헤더 파일에 정의).

-C++17에서 제공하는 생성자에 대한 템플릿 인수 추론 기능을 사용하지 않고도 std::make_tuple()이란 유틸리티 함수로 tuple을 생성할 수 있다. 이 헬퍼 함수 템플릿도 실젯값을 지정하는
 방식으로 tuple을 생성할 수 있다.

	20.7.1 tuple 분리하기

-tuple을 개별 원소로 분리하는 방법은 두 가지다. 하나는 C++17부터 추가된 구조적 바인딩을 사용하는 것이고, 다른 하나는 std::tie()를 이용하는 것이다.

1. 구조적 바인딩:

-구조적 바인딩으로 tuple을 분리할 때는 개별 원소로 생략할 수 없다. tuple에 담긴 원소가 세 개라면 바인딩에 지정하는 변수도 세 개여야 한다.

2. tie:

-구조적 바인딩을 적용하지 않고 tuple을 분리하려면 std::tie()라는 유틸리티 함수를 활용하면 된다. 이 함수는 레퍼런스로 구성된 tuple을 생성한다.
 //tie(a, b, c) = t1;

-std::ignore 플래그로 생략 가능
 //tie(a, std::ignore, c);

	20.7.2 연결

-std::tuple_cat()
 //std::tuple_cat(t1, t2);

	20.7.3 비교

-튜플은 비교 연산자 제공

-tie()를 활용하면 구조체도 쉽게 비교 가능
 // tie(f1.a, f1.b, f1.c) < tie(f2.a, f2.b, f2.c);

	20.7.4 make_from_tuple

-std::make_from_tuple<T>(tuple):
 tuple을 인수로 T의 생성자를 호출해서 객체 생성

-std::get<T>()과 std::tuple_size()를 지원하면 tuple아니어도 사용 가능 ex) std::pair, std::array

	20.7.5 apply

-std::apply()는 호출 가능한 객체를 tuple을 인수로 호출할 때 사용
 std::apply(add, make_tuple(3, 4));

	20.8 파일시스템 지원 라이브러리 - C++17

-<filesystem> 헤더 파일의 filesystem namespace

-filesystem 코드를 이식성 있게 작성 가능

	20.8.1 path

-절대 경로와 상대 경로

-로 스트링 리터럴로 이스케이프하는 번거로움 피할 수 있음

-append()나 operator/=를 이용하면 path에 다른 항목 추가 가능. 구분자 자동 추가.

-concat()나 operator+=를 이용하면 다른 스트링 연결 가능. 구분자 자동 추가되지 않음.

-반복문을 수행할 수 있도록 반복자도 제공.

	20.8.2 directory_entry

-디렉토리 및 파일 존재 여부 확인은 directory_entry를 통해서.

-다양한 인터페이스 제공

	20.8.3 헬퍼 함수

-다양한 헬퍼 함수 제공

	20.8.4 directory_iterator와 recursive_directory_iterator

-directory_iterator와 recursive_directory_iterator를 사용하면 디렉토리의 파일이나 하위 디렉토리를 재귀적으로 처리할 수 있다.

	21. 표준 라이브러리 커스터마이즈 및 확장

	21.1 할당자

-Allocator 객체.

-할당 시 allocate(), 해제 시 deallocate() 호출. 각각 new, delete에 대한 래퍼

-컨테이너 메모리 할당 방식 커스터마이징 -> Allocator 클래스 작성

-커스터 마이징의 이유: 성능, 메모리 파편화

-할당 커스터 마이징은 복잡하고 위험해서 주의를 요한다.

-allocate, deallocate같은 필수 메서드와 타입 앨리어스를 제공시 allocator 대신 사용 가능.

-C++17 부터 다형 메모리 할당자 제공. 할당자 템플릿 타입 매개변수가 달라서 생기는 문제 해결 가능.

-<memory_resource> 헤더 파일의 std::pmr::polymorphic_allocator클래스로 위 문제 해결 가능. polymorphic_allocator는 타입 매개변수가 아닌 memory_resource에 따라 할당 방식이 다름.

	21.2 스트림 반복자

-표준 라이브러리는 네 가지 스트림 반복자를 제공:
 ostream_iterator, istream_iterator, ostreambuf_iterator, istreambuf_iterator

-스트림 반복자는 반복자처럼 생긴 클래스 템플릿으로 입출력 스트림을 입출력 반복자처럼 처리 가능하게 함. 표준 라이브러리 알고리즘의 입출력으로 활용가능.

	21.2.1 출력 스트림 반복자

-ostream_iterator는 출력 스트림과 string 구분자를 생성자 매개변수로 받음

-스트림에 원소를 쓸 때 operator<<

-copy()와 같이 활용하면 쉽게 컨테이너 원소 출력 가능.

	21.2.2 입력 스트림 반복자

-입력 스트림 반복자를 활용하면 입력을 반복자 사용하듯이 할 수 있음.

-operator>>로 값을 읽는다.

-디폴트 생성자는 끝 반복자를 생성.

	21.3 반복자 어댑터

-세 가지 반복자 어댑터

-다른 반복자를 기반으로 한 특수 반복자

-<iterator> 헤더 파일에 정의

	21.3.1 역방향 반복자

-양방향, 임의 접근 반복자에 대해 역방향 탐색을 제공하는 std::reverse_iterator 반복자.

-타입 앨리어스 reverse_iterator -> std::reverse_iterator<T> -> T는 컨테이너의 iterator 타입 앨리어스

-operator++는 --로 작용. --는 ++.

-알고리즘을 reverse_iterator로 호출하면 리턴값도 reverse_iterator

-base()를 통해 iterator로 구할 수 있음.

-구현상의 문제로 iterator는 reverse_iterator가 가리키던 값의 다음 값을 가리킴. -1 필수.

	21.3.2 추가 반복자

-추가 반복자는 추가할 컨테이너의 레퍼런스를 생성자 매개변수로 받는다.

-copy() 같은 알고리즘의 사용 조건을 만족하는 인터페이스 제공.

-이 반복자들은 원소 추가 메서드를 호출:
 insert_iterator: insert()
 back_insert_iterator: push_back()
 front_insert_iterator: push_front()

-back_inserter()로 쉽게 back_insert_iterator 생성 가능.

-insert_iterator는 초기 삽입 위치를 생성자 인자로 받는 점이 다르다.

-반복문 수행 중 원소 수정이 안되는 연관 컨테이너도 추가 반복자를 통해 원소 추가 가능.

-back_inserter()와 같이 inserter()로 쉽게 insert_iterator 생성 가능.

	21.3.3 이동 반복자

-반복자 어댑터의 이동 의미론 버전 move_iterator

-대상이 이동 의미론을 지원해야 적용 가능.

-move_iterator의 역참조 연산자는 우측값 레퍼런스로 변환.

-C++ 표준에는 vector의 초기 용량와 증가 방식이 정의돼 있지 않다.

-복제가 일어나는 호출에 move_iterator를 대신 사용하면 이동 의미론이 적용된다.

-make_move_iterator() 활용.

	21.4 표준 라이브러리 확장하기

-좋은 라이브러리는 확장 기능을 제공.

-직접 정의한 컨테이너가 표준 라이브러리에 맞는 반복자를 제공하면 라이브러리 알고리즘 적용 가능. 반대로 반복자 조건에 맞게 알고리즘을 정의하면 표준 컨테이너에 적용 가능

	21.4.1 표준 라이브러리를 확장하는 이유

-사용 빈도 수가 높다면 직접 정의 알고리즘이나 컨테이너도 표준 라이브러리 인터페이스 기준을 따르는 것이 좋음. 코드의 이해력, 견고함, 재사용성 상승.

	21.4.2 표준 라이브러리 알고리즘 만들기

-적당한 표준 라이브러리 알고리즘이 없을 시 직접 만들 수 있음.

1.find_all():

-p.1023

2. iterator_traits:

-반복자의 특성에 대한 정보를 담고 있다:
 value_type, difference_type, pointer, reference, iterator_category

-한 개 이상의 템플릿 매개변수에 기반한 타입에 접근 시 typename 키워드를 명시적으로 지정해줘야 한다.

	21.4.3 표준 라이브러리 컨테이너 만들기

-C++는 커스텀 컨테이너가 표준 라이브러리 컨테이너로 쓰이기 위한 조건을 명시한다.

-규칙 세부사항을 먼저 신경쓰기 보단 기본적인 규칙을 먼저 지키고 세부사항을 추가하는 방식이 좋다.

1. 기본 해시맵:

-map과 set은 추가, 조회, 삭제가 로그 시간. 해시 테이블은 버킷과 원소 수가 차이가 크지 않다면 상수 시간 처리 가능.

-잘 만든 hash map 인터페이스는 해시 수와 해시 함수를 지정해서 원하는 작업을 할 수 있도록 한다.

-hash_map은 키의 동등 여부를 반드시 확인해야 한다.

2. hash_map을 표준 라이브러리 컨테이너로 만들기:

-C++는 표준 라이브러리 알고리즘 사용을 위해 컨테이너가 만족해야할 타입 앨리어스와 메서드 조건을 명시.

-타입 앨리어스:
 value_type
 reference
 const_reference
 iterator
 const_iterator
 size_type: 대부분 <cstddef>헤더에 정의된 size_t를 사용.
 difference_type: 대부분 <cstddef>헤더에 정의된 ptrdiff_t를 사용.

-메소드 조건:
 디폴트, 이동, 복제 생성자, 이동, 복제 대입자, 소멸자
 iterator begin();
 const_iterator cbegin() const;
 iterator end();
 const_iterator cend() const;
 size_type size() const;
 size_type max_size() const;
 operator==
 operator!=
 bool empty() const;
 void swap(Container&) noexcept;

-empty(), size()는 mSize로 쉽게 구현.

-max_size()는 한 버켓에 모든 원소가 들어가는 경우에 대비해 버켓의 max_size()로 구현.

-반복자 구현:

 -표준 라이브러리 컨테이너의 제시 조건 중 반복자가 가장 중요.

 -operator*, operator->는 반드시 구현하고 동작에 따라 그 외 추가 연산 제공.

 -결정사항1: 반복자의 종류(정방향, 양방향, 임의 접근)
  결정사항2: 컨테이너 원소의 정렬 방법
  결정사항3: 반복자의 내부 구현 방식. 컨테이너의 내부 구현 방식에 크게 영향 받는다.
  결정사항4: 끝 반복자를 일관성 있게 표현하는 방식 결정(마지막 원소 바로 다음).

 -컨테이너는 반드시 const, non-const 반복자 모두 제공해야 한다.

 -non-const 반복자는 const로 변환 가능해야 한다.

 -제네릭 알고리즘 함수에 사용할 반복자는 iterator_traits를 반드시 지정해야 한다.
  -방법1: iterator_traits 클래스 템플릿을 새로운 반복자 타입으로 부분 특수화
  -방법2: iterator_traits의 디폴트 구현을 이용하여 반복자에 있는 다섯 가지 타입 앨리어스를 그냥 가져오기

 -iterator_category: bidirectional_iterator_tag, forward_iterator_tag etc.

 -양방향 반복자는 반드시 기본 생성자를 제공해야 한다.

 -operator*는 원소에 대한 레퍼런스를, operator->는 ->를 다시 적용할 수 있는 대상을 리턴.

-역방향 컨테이너는 추가 타입 앨리어스와 메서드 요구. reverse_iterator, cbegin() 등 

-기본 컨테이너 요건을 제외한 정렬 연관, 비정렬 연관, 순차 컨테이너 요건도 만족해야 한다.

-...은 가변 인수 템플릿이다.

	22. 고급 템플릿

	22.1 템플릿 매개변수에 대한 심화 학습

-템플릿 매개변수 종류: 타입, 비타입, 템플릿 템플릿

	22.1.1 템플리 타입 매개변수에 대한 심화 학습

-첫 번째 템플릿 매개변수를 두 번째 템플릿 매개변수 기본값 설정에 활용 가능. 함수 템플릿 정의 헤더에서는 기본값 반복 불가능.

	22.1.2 템플릿 템플릿 매개변수

-템플릿 매개변수로 템플릿을 받으려면 템플릿 템플릿 매개변수를 활용.

-템플릿 템플릿 매개변수를 지정할 땐 그 템플릿의 전체 항목을 지정해야 한다.

-<template ...> class myClass(클래스 선언부)을 모두 매개변수로 지정하고 myClass를 원하는 매개변수 이름으로 변경.

* C++17부터 템플릿 템플릿 매개변수 지정 시 class 대신 typename 키워드를 사용할 수 있다.

-메서드 정의에서는 템플릿 표현말고는 바뀌는 것이 없다.

	22.1.3 비타입 템플릿 매개변수에 대한 고급 기능

-template<typename T, const T DEFAULT = T()>

* 비타입 매개변수에는 객체를 전달할 수 없고, double이나 float로 지정하면 안 된다. 반드시 정수 계열의 타입과 enum, 포인터, 레퍼런스로만 지정해야 한다.

-또 다른 비타입 매개변수 지정 방법: 레퍼런스 타입 활용
 template<typename T, const T& DEFAULT> -> 모든 타입으로 인스턴스화 가능

-C++17부터는 위와 같은 레퍼런스를 매개변수 타입에 대한 상수 표현식으로 표현해야 한다.

-C++17 이전 버전은 레퍼런스 비타입 매개변수에 임시값 사용 불가 및 내부, 외부 링크 없는 좌측값도 사용 불가. 이름 없는 네임 스페이스를 활용하여 내부링크를 만든 후 활용.

	22.2 클래스 템플릿 부분 특수화

-클래스 템플릿 부분 특수화(partial class template specialization): 템플릿 매개변수 중 일부만 특수화

-template<T, size_t WIDTH, size_t HEIGHT>
 class Grid
 template<size_t WIDTH, size_t HEIGHT>
 class Grid<const char*, WIDTH, HEIGHT>

-부분 특수화 템플릿 인스턴스화 시 특수화된 템플릿 매개변수도 반드시 명시.

-메서드 정의:
 template<size_t WIDTH, size_t HEIGHT>
 const std::optional<std::string>& Grid<const char*, WIDTH, HEIGHT>::at(size_t x, size_t y) const

-특수화 대상 타입들의 집합에 대해 특수화 가능 ex)
 template<typename T>
 class Grid<T*> {}

	22.3 오버로딩으로 함수 템플릿 부분 특수화 흉내내기

-함수 템플릿에 대해서는 부분 특수화 불가능

-다양한 템플릿 버전을 한 프로그램 안에 작성 가능. 

* 컴파일러는 오버로딩 버전, 함수 템플릿 특수화 버전, 함수 템플릿을 특정한 타입으로 인스턴스화한 버전 중에서 '가장 구체적인' 버전을 선택해서 호출한다. 비템플릿 버전도 함수 템플릿을 
  인스턴스화한 버전만큼 구체적이면 그 버전을 선택한다.

	22.4 템플릿 재귀, Template Recurrsion

-OneGrid<OneGrid<OneGrid<int>>> threeGrid; // 그러나 코드가 지저분하다.

-재귀적 구성엔 베이스 케이스 필수.

-p.1094

	22.5 가변 인수 템플릿

-가변 인수 템플릿은 고정된 매개변수 개수가 아닌 매개변수 팩을 갖는다.

-template<typename... Types>
 class MyClass {}

 template<typename T, typename... Types>
 class MyClass2 {}

	22.5.1 타입에 안전한 가변 길이 인수 리스트

-template<typename T1, typename... Tn>
 void processValues(T1 arg1, Tn... args)
 (...)연산자는 매개변수 팩 표현과 팩 풀기(팩을 개별 인수로 풀어서 콤마로 구분) 두 가지 용도로 쓰인다.

-가변 길이 인수 리스트는 타입 세이프하다.

-재귀적 호출로 가변 인수 템플릿을 활용 가능
 template<typename T1, typename... Tn>
 void processValues(T1&& arg1, Tn&&... args)
 {
     handleValue(std::forward<T1>(arg1))
     processValues(std::forward<Tn>(args));
 }

-재귀 호출시 매개변수 복제 오버헤드 증가 해결을 위해 레퍼런스를 받아야 하는데 non-const 레퍼런스가 리터럴을 못 받는 문제 해결을 위해 T&& 포워드 레퍼런스 활용.

-퍼펙트 포워딩 적용을 위해 std::forward() 사용. 페펙트 포워딩이란 우측값이면 우측값 레퍼런스, 좌측값 및 좌측값 레퍼런스면 좌측값 레퍼런스로 포워드 되는 것.

-processValues(std::forward<Tn>(args));는 각 인수에 forward를 호출하고 콤마로 구분.

	22.5.2 가변 개수의 믹스인 클래스

-매개변수 팩으로 가변 개수의 믹스인 클래스 정의 가능.
 template<typename... Mixins>
 class MyClass : public Mixins...
 {
     MyClass(const Mixins&... mixins) : Mixins(mixins)... {}
 }

	22.5.3 폴딩 표현식; C++17

-폴딩을 사용하면 매개변수 팩을 더 쉽게 풀 수 있다:
 단항 우측 폴드: pack @ ...
 단항 좌측 폴드: ... @ pack
 이항 우측 폴드: pack @ ... @ init
 이항 좌측 폴드: init @ ... @ pack

-매개변수 팩을 재귀적으로 풀 필요가 없어진다:
 template<typename... Tn>
 void processValues(const Tn&... args)
 {
     handleValues((args), ...);
 }

-거의 모든 연산자를 폴드에 활용 가능

-이항 폴드는 초깃값 지정
 template<typename T, typename... Values>
 double sumValues(const T& init, const Value&... values)
 {
     return (init + ... + values);
 }

	22.6 메타프로그래밍

-템플릿 메타프로그래밍은 컴파일 시간 연산 수행을 목적으로 한다.

-constexpr를 사용하면 컴파일 시간에 계산

-변수 선언 시에도 constexpr를 사용해야 컴파일 시간 계산
 // constexpr auto f1 = factorial(6);

	22.6.2 루프 언롤링

-템플릿 메타프로그래밍에서 반복문을 컴파일 시간에 일렬로 펼쳐놓는 방식을 루프 언롤링이라 한다.

-꼭 필요할 때만 활용한다. 컴파일러가 판단에 따라 자동으로 언롤링하기 때문.

-p.1107

	22.6.3 tuple 출력하기

-p.1109

-호출 코드가 복잡하면 그 호출을 대신해주는 템플릿 혹은 함수를 정의할 수 있다.

1. constexpr if; C++17:

-constexpr if는 컴파일 시간에 실행된다. if 조건을 만족하지 않으면 컴파일되지 않는다.

-if constexpr(n > 1) { ... }

-재귀 베이스 케이스를 생략하는데 활용할 수 있다.

2. 폴딩으로 컴파일 시간 정수 시퀀스 사용하기:

-<utility>에서 std::integer_sequence를 이용한 컴파일 시간 정수 시퀀스 제공.

-주로 인덱스 시퀀스를 생성하는데 사용.

-고로 std::index_sequence도 제공.

-주어진 매개변수 팩과 같은 길이의 인덱스 시퀀스를 생성할 경우는 index_sequence_for 사용

-p.1113

	22.6.4 타입 트레이트

-타입 트레이트를 이용하면 타입에 따른 분기 동작을 컴파일 시간에 처리 가능

-관련 기능은 모두 <type_traits> 헤더에

1. 타입 범주에 속한 타입 트레이트:

-is_integral 등

-특정 타입 속성을 기준으로 코드를 생성하기 위해 템플릿과 활용할 때 유용

-integral_constant -> bool에 대해 특수화(bool_constant 앨리어스) -> is_integral bool특수화 버전에 상속.

2. 타입 관계 활용 방법:

-is_same, is_base_of 등
 // bool areTypesTheSame = is_same_v<T1, T2>

3. enable_if 사용법:

-enable_if는 SFINAE에 기반(Substitution Failure Is Not An Error)

-리턴 타입에 따른 분기에 주로 사용.

-두 개의 타입 매개변수. 부울값, 타입.

-부울값이 true이면 ::type 중첩 타입(두 번째 타입 매개변수)을 가진다.
 ex) typename enable_if<..., bool>::type == enable_if_t<..., bool>

-부울값이 true이면 두 번째 매개변수를 리턴 타입으로 정한다. false이면 타입을 표현하지 않고, 리턴 타입 지정도 하지 않는다.

-위 에러는 SFINAE 적용으로 컴파일 에러를 발생시키지 않고, 다른 버전의 함수를 찾는다.

-생성자에 적용시엔 디폴트 값을 가진 매개변수를 하나 더 추가해서 활용.

-enable_if 사용에 주의한다. 다른 기법으로 적합한 오버로딩 버전을 찾을 수 없을 때에만.

* SFINAE를 적용하는 방법은 상당히 까다롭고 복잡하다. SFINAE와 enable_if를 적용할 때 여러 가지 오버로딩 버전 중 엉뚱한 버전을 비활성화하게 되면 알 수 없는 컴파일 에러가 발생하는데,
  에러 메시지만 보고서 문제의 원인을 찾기 굉장히 힘들다.

4. constexpr if로 enable_if 간결하게 표현하기; C++17

-if는 모든 분기문에 컴파일 돼야 하기 때문에 constexpr if 대신 사용할 수 없다.

-is_invocable는 주어진 함수가 주어진 인수에 대해 호출되는지 검사한다.

5. 논리 연산자 트레이트; C++17:

-세 가지 논리 연사자 트레이트도 제공한다: conjuction, disjunction, negation.

-타입 트레이트 논리 연산 수행에 활용
 // conjuction_v<is_integral<int>, is_integral<short>> << " ";

	22.6.5 템플릿 메타프로그래밍 맺음말

-템플릿 메타프로그래밍은 강력하지만 문법의 난해와 디버깅의 어려움이 단점.

-그 목적과 진행과정을 주석에 담는다.

	23. C++ 멀티스레드 프로그래밍

-여러 개의 프로세서 -> 멀티코어 프로세서.

-병렬처리 가능해짐.

-OS제공 API 의존도가 높아 플랫폼 독립 멀티스레드 코드를 작성하기 힘드나 C++제공 라이브러리로 어느정도 해결가능(boost같은 서드파티 라이브러리도)

-C++98/03은 OS API 및 서드파티 라이브러리에 의존. C++11 이후부터는 표준 라이브러리 제공으로 CPU대상 플랫폼 독립 멀티스레드 코드 짜기 용이.

-멀티스레드 프로그래밍 필요 이유: 성능, 연산을 다른 관점에서 모듈화.

-난점은 병렬 알고리즘 고안

* 멀티스레드 관련 문제를 방지하려면 여러 스레드가 공유 메모리를 동시에 읽거나 쓰지 않도록 디자인해야 한다. 아니면 동기화 기법이나 아토믹 연산을 적용한다.

	23.1.1 경쟁 상태

-여러 스레드가 공유 리소스에 동시 접근이 가능할 때 경쟁 상태

-그 중 공유 메모리에 대한 경쟁 상태를 데이터 경쟁

	23.1.2 테어링

-테어링(tearing): 읽기 테어링(torn read), 쓰기 테어링(torn write)

-한 메모리에 쓰는 와중에 읽으면 읽기 테어링, 여러 스레드가 동시에 쓰면 쓰기 테어링

	23.1.3 데드락(교착 상태)

-여러 스레드가 리소스 접근 권한을 동시에 무한히 기다리는 상태

-리소스 접근을 일정한 순서로 실행하는 것은 한가지 발생 방지 방법

-발생 시 빠져나오는 메커니즘도 구현하면 좋다: 일정 시간 후 확보 리소스 해제 후 나중에 다시 시도 방법 등

-데드락 상황 발생 자체를 막는 것이 이상적: std::lock(), std::try_lock()활용 -> 여러 리소스 권한 확보를 동시에

	23.1.4 잘못된 공유

-캐시(cache)는 캐시 라인(cache line) 단위로 처리된다.

-캐시 라인에 데이터를 쓰려면 반드시 락을 걸어야 한다.

-두 스레드가 두 가지 데이터 영역을 사용하는데 캐시 라인이 걸쳐있다면 락을 걸면서 한쪽이 기다리는 성능 저하 발생 가능.

-데이터 구조 명시적 정렬로 해결가능: <new> 헤더의 hardware_destructive_interference_size 상수, alignas 키워드 적절히 활용

	23.2 스레드

-<thread>로 쉽게 스레드 생성 가능

	23.2.1 함수 포인터로 스레드 만들기

-std::threads에서 활용하는 함수는 원하는 개수만큼 매개변수를 받을 수 있다.
 //thread t1(Counter, 1, 6);

-thread 객체가 실행 가능한 상태 -> 조인 가능(joinable); 
                       불가능한 상태 -> 조인 불가능(unjoinable)

-조인 가능한 thread 객체를 제거하려면 join() 혹은 detach()부터 호출해야 한다.

-join()은 그 스레드가 작업을 끝낼때까지 기다린다.

-detach()는 스레드 객체를 OS내부 스레드와 분리.

-두 메서드 모두 스레드를 조인 불가능 상태로 전환.

-조인 가능 thread 객체 제거하면 std::terminate()가 호출됨.

-cout 접근 작업은 스레드에 안전. 그러나 데이터 경쟁 없이도 출력 결과가 섞일 수 있다. 동기화 기법 필요.

* 스레드 함수에 전달한 인수는 스레드의 내부 저장소에 복제된다. 인수를 레퍼런스로 전달하고 싶다면 <functional>에 정의된 std::ref()나 cref()를 사용한다.

	23.2.2 함수 객체로 스레드 만들기

-펑터 클래스에 원하는 데이터 멤버로 초기화를 더 용이하게 가능

* 함수 객체는 항상 스레드의 내부 저장소에 복제된다. 함수 객체의 인스턴스를 복제하지 않고 그 인스턴스에 대해 operator()를 호출하려면 <functional> 헤더에 정의된 std::ref()나 cref()를 사용
  해서 인스턴스를 레퍼런스로 전달해야 한다.

	23.2.3 람다 표현식으로 스레드 만들기

-방식은 같다.

	23.2.4 멤버 함수로 스레드 만들기

-thread t1(&Request::Process, &req);

-같은 객체에 접근할 때 데이터 경쟁이 벌어지지 않도록 주의.

-뮤텍스를 이용한 동기화 기법 활용

	23.2.5 스레드 로컬 저장소(thread local storage)

-thread_local 키워드로 변수를 선언하면 각 스레드가 그 변수의 복제본을 스레드 제거시까지 유지.

-함수 스코프에 trhead_local 변수 선언 시 각 스레드에서는 한 번만 초기화 된다는 점이 static과 유사

	23.2.6 스레드 취소하기

-C++는 한 스레드에서 다른 스레드를 종료하는 메커니즘을 제공하지 않는다.

-스레드 사이의 통신 메커니즘 제공으로 해결 ex) 공유 변수

-통신 메커니즘 활용시 데이터 경쟁 주의

	23.2.7 스레드로 실행한 결과 얻기

-결과를 담는 변수의 포인터나 레퍼런스를 전달

-함수 객체 변수에 저장

-future를 활용

	23.2.8 익셉션 복제와 다시 던지기

-스레드에서 던진 익셉션은 그 스레드에서 처리해야 한다.

-익셉션 처리가 안되면 std::terminate()를 호출한다.

-표준 스레드 라이브러리 익셉션 관련 제공 함수:
 exception_ptr current_exception() noexcept: 현재 처리할 익셉션을 가리키는 exception_ptr 객체나 복사본 리턴. 없으면 널 exception_ptr 객체
 [[noreturn]] void rethrow_exception(exception_ptr p): 매개변수가 참조하는 익셉션 처리. 참조한 익셉션을 최초 발생 스레드 안에서는 다시 던져야 하는 법은 없다.
 template<class E> exception_ptr make_exception_ptr(E e) noexcept: 주어진 익셉션 객체 복사본을 참조하는 exception_ptr 객체 생성.

-exception_ptr는 nullable 포인터로 if문 검사 가능.

-호출할 함수 > 에러를 exception_ptr 레퍼런스에 저장할 스레드 호출 함수(current_exception) -> 스레드를 실행할 함수(rethrow)

	23.3 아토믹 연산 라이브러리

-아토믹 타입을 쓰면 동기화 기법없이 읽, 쓰기를 동시에 할 수 있는 아토믹 접근(atomic access) 가능 -> 스레드 안전

-컴파일러는 메모리에서 값을 읽기 -> 레지스터에서 데이터 처리 -> 메모리에 다시 저장

-<atomic> 헤더 필요

-표준은 모든 기본 타입마다 네임드 정수형 아토믹 타입을 정의 ex) atomic_bool == atomic<bool>

-타킷 하드웨어에서 아토믹 연산 미지원시 is_lock_free()로 동기화하지 않아도 되는지 확인

-std::atomic 클래스 템플릿은 어느 타입에나 적용 가능. 그러나 쉽게 복제 가능해야 한다 -> is_trivially_copyable

-아토믹 사용시 경쟁 상태의 메모리 순서, 컴파일러 최적화 문제 등 해결 가능.

-this_thread::sleep_for(1ms); 로 루프문 실행시 일정 시간 지연.

-atomic은 작업을 하나의 아토믹 트랜잭션으로 처리해 다른 스레드의 개입을 막는다.

-아토믹, 동기화 기법을 사용 -> 동기화 작업에 성능 하락. 처리 시간 최소화 필요.

-로컬 변수인 리턴 값을 아토믹 변수에 대입 등 방법

	23.3.2 아토믹 연산

-정수형 아토믹 타입은 fetch_add(), fetch_sub()등 지원. 지정값 계산 후 계산 전 값 리턴.

-포인터형 아토믹 타입은 fetch_add(), fetch_sub() 등

-아토믹 연산은 메모리 순서 매개변수를 받지만 디폴트 값이 안전.

	23.4 상호 배제

-멀티스레드 프로그램 작성시 연산 순서 주의.

-경쟁 관계 예방: 데이터 공유를 원천 차단 혹은 동기화 메커니즘

-스칼라값은 아토믹으로 쉽게. 복잡한 데이터 구조는 동기화 메커니즘

-표준 라이브러리는 mutex와 lock클래스로 상호 배제 메커니즘 제공 -> 동기화 구현 가능.

	23.4.1 mutex

-mutual exclusion; 상호 배제

-C++ 표준은 non-timed mutex와 timed mutex 클래스 제공.

-사용법:
 -공유 데이터 접근 시 뮤택스 객체에 락을 걸어야 한다. 다른 스레드가 걸었다면 해제되거나 시간 경과해야 가능.
 -락을 걸면 공유 데이터 사용 가능. 걸고 해체 구현 정확하게
 -작업이 끝나면 확실하게 해제.

1. 시간 제약이 없는 뮤텍스 클래스:
 -std::mutex, recurssive_mutex, shared_mutex // <mutex>, <shared_mutex> 헤더

 -lock(): 락을 걸 때까지 대기(블록된다).
 -try_lock(): 락 시도. 다른 스레드가 걸었으면 즉시 리턴. 걸리면 true 아니면 false
 -unlock(): 락 해제.

 -std::mutex는 소유권 독점의 가장 표준 mutex. 한 스레드만 가진다.
 
 -다른 스레드가 소유하려면 lock() 호출하고 대기.

 -mutex를 소유한 스레드가 같은 mutex에 lock()을 호출하면 데드락.

 -recurssive_mutex는 이미 recurssive_mutex를 확보한 스레드가 lock(), try_lock() 호출 가능.

 -recurssive_mutex는 lock()을 호출한 수만큼 unlock() 호출 필수.

 -shared_mutex는 공유 락 소유권(shared lock ownership) 또는 읽기-쓰기 락(reader-writer lock) 개념 구현.

 -다른 스레드가 공유, 독점 소유권 없을 때 -> 독점 소유권, 쓰기 락; 다른 스레드가 공유 소유권만 있을 때 -> 공유 소유권, 읽기 락.

 -lock_shared, try_lock_shared, unlock_shared 제공 -> 획득 해제 대상 공유 소유권.

 -같은 shared_mutex에 lock 시 데드락

2. 시간 제약이 있는 뮤텍스 클래스:

 -std::timed_mutex, recursive_timed_mutex, shared_timed_mutex // <mutex> <shared_mutex> 헤더

 -동작은 일반 버전과 유사

 -try_lock_for()과 try_lock_until() 제공 // 상대 시간과 절대 시간 경과시 false return

 -timed_mutex와 shared_timed_mutex는 중복 락을 걸면 데드락 발생.

* 뮤텍스 클래스에 대한 락/언락 메서드를 직접 호출하면 안 된다. 뮤텍스 락은 일종의 리소스라서 거의 대부분 RAII 원칙에 따라 독점적으로 획득한다. C++ 표준은 RAII 락 클래스를 다양하게
  제공한다. 데드락을 방지하려면 반드시 락 클래스를 사용하는 것이 좋다. 락 객체가 스코프를 벗어나면 자동으로 뮤텍스를 언락해주기도 한다.

	23.4.2 lock

-lock 클래스는 락을 걸거나 해제하는 작업을 쉽게 해줌. // RAII

-std::lock_guard, unique_lock, shared_lock, scoped_lock // scoped_lock은 C++17

1. lock_guard:

-<mutex>에 정의된 간단한 락

2. unique_lock:

-락을 선언하고 시간이 지나서 락을 걸도록 하는 기능 제공.

-owns_lock()이나 bool 변환 연산자로 락 걸렸는지 확인

-lock(), try_lock_for(), try_lock_until(), unlock() 제공

3. shared_lock:

-unique_lock과 같은 인터페이스 제공.

-독점 락 대신 공유 락

4. 한 번에 여러 개의 락을 동시에 걸기:

-lock 함수를 통해 가능.

-어느 하나의 락에 익셉션 발생시 이미 확보한 락에 unlock() 호출.

-try_lock()도 비슷하지만 락을 걸 때 try_lock()을 순차 호출.
 -하나라도 실패하면 unlock() 호출
 -성공하면 -1 리턴.

5. scoped_lock:

-scoped_lock을 활용하면 여러 락을 한번에 거는 코드를 더 간결하게 작성 가능.

	23.4.3 std::call_once

-call_once()와 std::once_flag -> 여러 스레드가 호출해도 한 번만 호출되게 가능.

-지정 함수가 익셉션을 던지지 않을 때 이런 호출을 이펙티브 call_once() 호출이라 한다.

-익셉션 발생시 호출 측으로 전달되고 다른 호출자로 함수 실행.

	23.4.4 뮤텍스 객체 사용 방법

1. 스레드에 안전한 스트림 출력 기능 구현하기:

-함수 객체 멤버로 static mutex를 추가하고 출력 구문 전 lock

-락이 걸린 시간을 최소화하도록 지정.

2. 시간 제약이 있는 락 사용하기:

-timed_mutex와 unique_lock 활용

-lock이 안되도 시간 지나면 리턴

-if 문에서 락이 됐는지 차후에 확인

3. 이중 검사 락:

-상호 배제 객체 사용을 최소화하는 목적

-성능은 낮추고 문제는 더 일으키는 안티패턴.

-락을 걸기 전과 후에 두 번 검사해서 이중 검사 락 패턴이라 불린다.

* 이중 검사 락 패턴은 사용하지 마라. 대신 기본 락, 아토믹 변수, call_once(), 매직 스태틱을 사용하라

	23.5 조건 변수

-다른 스레드에서 조건을 설정하거나 지정 시간 경과 전까지 스레드 실행 정지 가능

-<condition_variable> 헤더

-std::condition_variable -> unique_lock<mutex>만 기다리는 조건 변수
 std::condition_variable_any -> 모든 종류의 객체

-condition_variable 제공 메서드:
 notify_one(), notify_all(), wait, wait_for, wait_until

-wait() 호출 스레드는 인자 mutex에 대한 락 필수.

-다른 스레드에서 notify_one(), notify_all() 호출되면 다시 락 걸고 리턴.

	23.5.1 비정상적으로 깨어나기

-스레드가 비정상적으로 깨어날 수도 있다.

	23.5.2 조건 변수 사용하기

-std::notify_all_at_thread_exit(cond, 1k)도 제공. 스레드 종료시 1k.unlock(), cond.notify_all() 자동 호출.

	23.6 promise와 future

-스레드가 던진 익셉션을 그 스레드가 안받으면 std:terminate() 호출.

-future와 promise로 스레드 리턴 값과 익셉션 처리 용이하게 가능.

-같은 스레드나 다른 스레드에서 promise에 실행 결과를 담으면 future로 가져옴 // 입력 포트와 출력 포트. 스레드 통신 채널

-future<T> myFuture = ...; T res = myFuture.get();

-get()은 future당 한번만 호출 가능. 호출시 블록된다.

	23.6.1 std::promise와 std::future

-std::promise 하나에 set_value(), set_exception은 한 번만 호출 가능.

-std::promise는 복제될 수 없고, 이동만 가능.

-promise 객체 인수로 전달 및 다른 스레드에서 이동 전 promise에 대해 get_future() 호출.

-<future> 헤더

	23.6.2 std::packaged_task

-비명시적 promise 구현 가능.

-std::packaged_task 선언 -> get_future -> task에 대해 스레드 구동 -> get()

	23.6.3 std::async

-스레드로 계산하는 작업에 런타임 제어를 하고 싶다면 std::async()

-함수를 인자로 받고 결과 값 future를 리턴.

-두 가지 실행 방법:
 -스레드를 만들어 비동기식 구동: launch::async
 -future대해 get() 호출시 현재 스레드와 동기 구동:launch::deferred

-async에 인수가 없으면 두 방법 중 적절한 방법으로 실행.

-동기식 -> 현재 스레드; 비동기식 -> 다른 스레드

* async()를 호출해서 리턴된 future는 실제 결과 담길 때까지 소멸자에서 블록된다. 다시 말해 async()를 호출한 뒤 리턴된 future를 가져가지(캡처하지) 않으면 async()가 블록되는 효과가
  발생한다.

	23.6.4 익셉션 처리

-future를 이용하면 쉽게 익셉션 처리.

-get을 호출시 익셉션을 다시 던질 수도 있음

-packaged_task, async활용하면 익셉션 promise에 자동 저장

	23.6.5 std::shared_future

-future<T>의 T는 이동 생성 가능해야 한다.

-get()을 호출하면 값이 이동 리턴 되기에 get을 두 번 호출할 수 없다.

-get()을 중복 호출하려면 shared_future

-std::future::share()나 shared_future 생성자에 future를 전달해서 생성(이때 future는 이동).

-shared_future는 여러 스레드를 동시에 깨울 때 사용.

	23.7 멀티스레드 Logger 클래스 예제

-스레드에 안전하지 않다면 동기화 메커니즘 제공.

* 현재 C++ 표준은 스레드, 아토믹, 뮤텍스 객체, 조건 변수, 퓨처만 제공한다. C++17까지는 동시성을 지원하는 데이터 구조가 하나도 없다. 실전에서는 데이터 구조를 직접 구현하지 말고, 서드
  파티에서 제공하는 동시성 지원 데이터 구조를 활용하는 것이 좋다. ex) 부스트 라이브러리

-소멸자에 대해서 조인할 여지가 남았을 때에도 std::terminate()가 호출된다.

-백그라운드 스레드가 완전히 종료되도록 구현해야 한다.

	23.8 스레드 풀

-스레드를 생성했다 삭제하는게 아닌 스레드 풀을 필요 수만큼 구성해도 된다.

-프로세스 코어 수와 스레드 수가 일치하는 것이 이상적이다(스레드가 기다릴 필요 없으므로).

-스레드 풀은 이미 생성된 상태이므로 OS 입장에서 효율적 스케쥴링 가능.

-스레드 풀 라이브러리를 사용하는 것이 좋다.

	23.9 바람직한 스레드 디자인과 구현을 위한 가이드라인

-표준 라이브러리에서 제공하는 병렬 알고리즘 활용
 -대부분 직접 구현 보단 라이브러리 활용이 효율적

-애플리케이션 종료 전에 조인해야 할 thread 객체가 하나도 남지 않게 한다.
 -모든 thread 객체에 대해 join()이나 detach를 호출했는지 확인.

-동기화 메커니즘 없는 동기화 방식이 제일

-가능하다면 싱글 스레드 소유권 패턴 적용.

-아토믹 타입과 연산을 최대한 활용.

-변경될 수 있는 공유 데이터는 락으로 보호.

-락을 거는 시간은 짧을수록 좋다.

-여러 개의 락을 걸 때는 std::lock(), try_lock()

-RAII 락 객체 활용: lock_guard, unique_lock, shared_lock, scoped_lock

-멀티스레드를 지원하는 프로파일러를 활용

-멀티스레드 지원 디버거 활용

-스레드가 많을 때는 생성 삭제보단 스레드 풀 활용
 -생성, 삭제 수가 많을수록 성능 저하.

-하이레벨 멀티스레딩 라이브러리 활용

	24. 소프트웨어 공학 기법

-소스 코드 관리 소프트웨어 특화 용어:
 브랜치(branch): 다양한 버전 병렬 개발
 체크아웃(checkout): 개발자 머신에 로컬 복제본 생성
 체크인, 커밋, 머지(merge): 로컬 복제본에 작업 내용 반영 후 중앙서버로 체크인
 컨플릭트: 같은 파일을 여러 개발자가 변경 후 동시에 커밋하면 발생.
 레이블, 태그: 파일이나 특정 커밋마다 붙은 표시
 repository: 소스 코드 관리 소프트웨어에서 관리하는 모든 파일을 저장해둔 곳
 리졸브(resolve): 충돌이 발생할 때 이를 해결해야 커밋 가능.
 리비전(revision), 버전(version): 특정한 시점에서 본 파일 내용에 대한 스냅샷
 업데이트, 동기화(sync): 로컬 내용을 중앙과 동기화
 워킹 카피(working copy): 개발자 머신마다 저장된 복사본

	25. 효율적인 C++ 코드 작성법

	25.1 성능과 효율성에 대하여

-성능(performance)은 속도, 메모리 사용량, 디스크 접근 횟수, 네트워크 사용량 등 문맥에 따라 가리키는 대상 다름 // 주로 속도

-효율성(efficiency)은 낭비 없이 실행된다는 것

	25.1.1 효율성을 확보하기 위한 두 가지 접근 방법

-언어 차원의 효율성; language-level efficiency
 디자인 차원의 효율성; design-level efficiency // 적절한 알고리즘, 불필요한 단계 제거, 데이터 구조 선택 등

	25.1.3 C++는 비효율적인 언어인가?

-효율성을 따질 때는 컴파일러의 최적화 효율성도 고려해야 한다.

-C#이나 자바는 가상 머신에서 구동하지만 C++는 CPU에서 곧바로 구동된다. // 거의 하드웨어 수준에서 구동

	25.2 언어 차원의 효율성

-디자인과 알고리즘이 성능에 미치는 영향이 더 크다.

-언어 차원 최적화는 컴파일러 기본 제공도 있다.

-프로파일링에서 찾은 문제가 아니라면 과도한 신경 불필요

* 간결하고 체계적인 디자인을 바탕으로 구현하고 언어 차원의 효율성을 적용한다. 프로파일러를 이용하여 반드시 짚고 넘어갈 부분만 시간을 투자한다.

	25.2.1 객체를 효율적으로 다루는 방법

1. 레퍼런스로 전달하기:

* 함수나 메서드로 객체를 전달할 때 값으로 전달할 일은 거의 없다.

-베이스 클래스 타입으로 파생 클래스 객체를 값으로 인수 전달하면 슬라이싱 발생.

* 함수 안에서 객체를 수정해야 한다면 레퍼런스로 전달한다. 그렇지 않으면 const 레퍼런스로 전달

2. 레퍼런스로 리턴하기:

-함수의 로컬 객체는 레퍼런스나 포인터로 리턴하면 안 된다.

3. 익셉션을 레퍼런스로 받기:

4. 이동 의미론 적용하기:

-컴파일러가 생성한 복제 및 이동 생성자와 복제 및 이동 대엽 연산자만으로도 충분하도록 디자인해야 한다.

5. 임시 객체 생성 피하기:

-컴파일러의 임시 객체 생성을 최소화하는 것이 좋다.

6. 리턴값 최적화:

-릴리스 모드로 빌드할 시 컴파일러 최적화 과정에서 불필요한 임시 변수를 제거한다.

-위를 이름 있는 변수 리턴 시 NRVO(Named Return Value Optimization), 이름 없는 임시값 전달 시엔 RVO이라 한다.

-NRVO을 활용하려면 이름 있는 로컬 변수를 하나만 지정해야 한다.

	25.2.2 미리 할당된 메모리

-컨테이너의 크기를 조절하면서 성능 저하가 발생한다.

-원소 수를 예측할 수 있다면 미리 공간을 할당한 뒤 추가한다.

	25.2.3 inline 메서드와 inline 함수 활용하기

-inline 메서드, 함수는 호출 코드에 그대로 들어가서 오버헤드가 발생하지 않는다.

-때로는 컴파일러가 최적화 중 inline 비지정 함수를 inline으로 만들기도 한다.

-컴파일러 메뉴얼에서 최적화 기능 확인

	25.3 디자인 차원의 효율성

-알고리즘 선택 등 현명하게

	25.3.1 최대한 캐싱하기

-캐싱이란 자주 사용하는 항목을 저장해두는 것.

-처리 시간이 긴 작업 결과를 캐싱 해둔다:
 디스크 접근
 네트워크 통신: 네트워크 통신 오버헤드는 예측 불가
 수학 연산: 간단하면 불필요
 객체 할당: 객체 풀 활용
 스레드 생성: 스레드 풀에 캐싱

-프로그램 구동 동안 설정 파일을 변경하면 캐시 내용이 무효화 된다.

-캐시 내용 무효화 시 캐시 무효화(cache invalidation) 메커니즘을 적용해야 한다. // 캐시 사용을 멈추거나 내용 업데이트

-캐시 데이터 변경 사실을 콜백으로 등록해서 알려주거나 캐시를 주기적 업데이트 하는 이벤트 등

* 캐시 관리엔 오버헤드가 발생. 프로파일러에서 성능 병목점이라 지적한 부분만 캐시에 담는다. 코드를 간결, 정확하게 짠 뒤 프로라일러 분석 후 필요한 부분만.

	25.3.2 객체 풀 활용하기

-풀의 종류는 다양.

-하나는 큰 메모리 할당 후 조그만 객체를 담는 것

1. 객체 풀 구현 방법:

	25.4 프로파일링

-디자인과 구현 때 성능에 집착하지 말 것

-차후에 프로파일러에서 병목점으로 지적한 부분만 최적화

-80/20 법칙

-프로파일러는 함수를 기준으로 성능 분석.

-함수와 그 함수로부터 실행된 부분 처리 시간을 요약한 정보를 콜 그래프라 한다.

	25.4.2 비주얼 C++를 이용한 프로파일링

-디버그 > 성능 프로파일러 실행

	25.5 요약

-디자인 및 구현 과정에서 성능에 집착하지 않는다.

-디자인, 구현을 바람직하게 하고 병목점 최적화

-디자인 차원 최적화가 언어 차원 최적화보다 중요.

	26. 테스트 숙달하기

-두 종류의 테스트:
 화이트박스 테스트: 코드 내부를 알고 하는 테스트
 블랙박스 테스트: 모르고 하는 테스트

-테스트 커버리지(test coverage): 프로그램에서 테스트로 검사한 범위

	26.1 품질 관리

	26.1.2 버그의 라이프사이클

-공식 버그 프로세스를 갖고 있는 것이 좋다.

	26.1.3 버그 트래킹 도구

-스프레드 시트나 이메일 같은 단순 정리 혹은 버그 트래킹 소프트웨어  EX) Bugzilla

	26.2 단위 테스트

-버그는 테스트로 찾는다.

-단위 테스트는 클래스나 서브 시스템을 세부 단위로 검사하는 것

	26.2.1 단위 테스트 방법

-코드가 많을수록 커버리지(적용 범위)가 넓다.

-테스트 코드를 먼저 짜는 방법

-테스트 코드의 디자인만 먼저 짜놓는 방법

-테스트 코드는 다른 사람이 작성하는 방법

-테스트 커버리지를 극단적으로 넓히는 방법

	26.2.2 단위 테스트 프로세스

-단위 테스트는 프로젝트 시작 단계부터 적용(대략적으로라도) > 디자인에 좋은 영향

-ex) 데이터 추가 기능 > 테스트 > 삭제 기능 > 테스트

-맞는 방법론 선정 및 사용

1. 테스트 구체화 수준 정하기:

-테스트를 미루면 버그의 대가는 커진다.

-구체화 수준은 재량

-개략적인 수준에서 클래스 활용도가 높아지면 더 구체적으로도 가능

-단위 테스트를 기능의 일부로도 볼 수 있다.

-기능이 바뀌면 새 테스트 코드를 짜서 기존 테스트 코드 결과와 비교

* 단위 테스트는 테스트 대상이 되는 서브시스템의 일부다. 서브시스템을 점진적으로 개선하듯이 단위 테스트도 점진적으로 개선해야 한다.

2. 개별 테스트에 대한 브레인스토밍:

-테스트에 구성에 대해 브레인스토밍 접근
 목적, 호출 방식, 가정, 잘못된 사용 등

-대략적인 테스트 항목 정하기 > 각각 세분화

* 간단한 테스트만 나열하지 말고 복잡한 케이스도 주의한다.

3. 샘플 데이터와 결과 마련하기:

-결과를 예상하고 테스트 코드를 끼워 맞추면 안된다.

-테스트하기 전에 결과를 예상한다.

-리턴 값만 확인하는 테스트가 아닌 하는 작업을 실제로 테스트해야 한다.

* 실제로 테스트를 수행하기 전에 정확한 출력값을 미리 정해둔다.

4. 테스트 코드 작성하기:

-작성 방식은 테스트 프레임워크에 따라 달라진다.

-가이드라인:
 -테스트마다 하나씩 테스트
 -테스트 코드는 구체적으로
 -로그는 최대한 많이
 -테스트끼리는 얽히면 안된다. 독립적으로
 -다른 서브시스템을 쓸 때는 동작을 흉내내는 목업을 사용. 그 서브 시스템으로 인한 테스트 결과 오염 방지
 -코드 리뷰어의 검토

5. 테스트 코드 실행하기:

-테스트 코드는 구현 즉시 실행한다.

-단위 테스트는 반드시 자동화해야 한다.
 -통합 빌드의 일부분으로 수행
 -일정 시각에 정기적으로 실행
 -컴파일 때마다 수행하도록 로컬 개발 환경 설정.

	26.2.3 단위 테스트 실습하기

-마이크로소프트 비주얼 C++는 테스트 프레임워크 기본 제공.

-테스트 프레임워크는 테스트 작성에만 신경쓸 수 있게 해준다.

* 사용 가능 오픈소스 테스트 프레임워크: Google Test, Boost Test Library

-솔루션 노드 우클릭 > 추가 > 검색어 test.

-테스트 헤더 파일, cpp 파일 추가

-단위 테스트 .cpp 파일에서 테스트할 형식과 함수를 선언하는 모든 헤더 파일에 대해 #include 지시문을 추가

-각 include 문에 상대 경로를 입력 하려면 프로젝트>속성>C/C++>일반>추가 포함 디렉터리에 필요한 폴더를 추가

-단위 테스트 코드를 테스트 클래스라는 논리 그룹으로 나눈다.

-TEST_CLASS(ObjectPoolTest)

-테스트 수행 전 처리 작업: TEST_CLASS_INITIALIZE(setUp);
 테스트 수행 후 처리 작업: TEST_CLASS_CLEANUP(tearDown);

-setUP과 tearDown 메서드가 필요하다면 cpp 파일에:
 void ObjectPoolTest::setUp() {}

* 실전에서는 테스트 코드와 테스트할 코드를 별도의 프로젝트로 구성한다.

-단위 테스트 하나는 테스트 클래스 메서드 하나로 표현.
 TEST_METHOD();

-실제 테스트 수행은 Microsoft::VisualStudio::CppUnitTestFramework namespace에 정의된 Assert:: 함수들로

-빌드 후 테스트 탐색기에서 실행

4. 네거티브 테스트:

-테스트가 반드시 실패하도록 네거티브 테스트 실행 가능

-Assert:ExpectException<Exception-type>()

6. 테스트 코드 디버깅하기:

-테스트 코드 탐색기에서 제공된 스택 트레이스 확인

-브레이크 포인트로 직접 구동해서 디버그

7. 단위 테스트 결과를 최대한 활용하기:

	26.3 하이레벨 테스트

	26.3.1 통합 테스트

-통합 테스트(integration test)는 각 컴포넌트가 맞물리는 영역을 테스트한다.

-통합 테스트 작성에 정해진 규칙은 없다.

-통합 테스트를 자신이 작성한 모듈끼리만 할 필요는 없다.

2. 통합 테스트 방법:

-통합 테스트와 단위 테스트는 테스트에 대한 접근 방식 차이

-분류에 얽매이지 마라

-그러나 별개의 취급을 하면 테스트 결과 가치를 높일 수 있다.

	26.3.2 시스템 테스트

-프로그램 전체를 테스트

-유저 행동을 흉내내는 가상 사용자 스크립트를 활용하는 것이 많다.

-정해진 규칙은 없음

	26.3.3 회귀 테스트

-회귀 테스트(regression test)는 프로그램에 변경이 있을 때 새 버전에서도 이전 기능들이 작동하는지 테스트.

-인력이 많으면 수동, 자동으로도 작성 가능.

-스모크 테스트(smoke testing)는 가장 핵심 기능만 테스트한다.

-버그 픽스 테스트 코드 작성 시 버그 해결 증명 코드와 재발생 시 경고 메시지 출력 코드도 작성해야 한다.

	26.4 성공적인 테스트를 위한 팁

-테스트 자동화 시스템을 제대로 디자인한다.

-스트레스 테스트(stress testing) 반드시 수행. 가장 극한 상황 재현 후 검사

-다양한 플랫폼에서 테스트. 가상 머신을 활용

-의도적으로 문제 주입하고 테스트

-버그 픽스는 반드시 회귀 테스트로 검증

-실패한 테스트 코드 삭제하지 않기

	27. 디버깅 완전 정복

	27.1 디버깅 기본 원칙

-버그가 발생할거라고 인정하는 자세 구비

* 디버깅 기본 원칙은 버그가 발생하지 않도록 코드 작성에서 최선을 다하고 동시에 버그에 대비

	27.2 버그 분류

-치명적 버그(catastrophic bug) : 프로그램, OS 사망 및 데이터 손상
 비치명적 버그(noncatastrophic bug) : 프로그램 동작으로 잘 드러나지 않는 문제

-미관상 버그(cosmetic bug): 프로그램 작동이 아닌 시각적 문제

	27.3 버그 방지

-요령:
 -코드 작성전에 디자인
 -코드 컴토
 -테스트
 -자동화 단위 테스트
 -에러 발생 상황을 예측해서 적절히 대비
 -스마트 포인터 사용
 -컴파일 경고 메세지 확인
 -정적 코드 분석 도구(static code analyzer) 활용
 -바람직한 코딩 스타일
 
	27.4 버그 대비

	27.4.1 에러 로깅

-에러 로깅은 앱이나 시스템이 실행 중 발생한 에러 메세지를 영속 저장 장치에 저장하는 것.

-에러 로깅 기능 구현은 필수

-C++는 표준 로깅 메커니즘 제공 x

-플랫폼 개발 관련 문서 참조 및 크로스 플랫폼 로깅 프레임워크 사용

-트레이스(trace): 버그 발생 당시 실행 경로 추적 로그 메세지

-트레이스는 로그 파일 저장에 부적절:
 -저장의 오버헤드
 -사용자에게 혼란

-로그 파일 저장 적절 정보:
 -복구할 수 없는 에러
 -관리자 대응 필요 에러 ex) 메모리 부족, 네트워크 연결 문제, 디스크 쓰기 에러
 -의도하지 않은 경로 실행 및 변수에 비정상값 저장으로 인한 에러
 -보안 위험

	27.4.2 디버그 트레이스

-프로그램 출력 에러 메시지론 불충분할 경우 용이한 추가 정보:
 -멀티스레드면 스레드 ID
 -트레이스 생성 함수 이름
 -트레이스 생성 코드 파일 이름

-멀티스레드 프로그램에서 로깅 시 스레드에 안전하게

* 트레이스 파일은 텍스트 파일로 작성해도 괜찮. 너무 상세히 적어 지적재산을 유출 주의

1. 디버그 모드:

-디버그 트레이스 방법 중 하나는 디버그 모드 제공

-시작 시간 디버그 모드:

 -커맨드 라인 인수로 디버그 모드 On/Off

 -새로 시작해야 하기에 버그 정보 놓칠 수 있음

 -정확성은 성능보다 중요하다.

 -C++ 표준에는 커맨드 라인 인수 파싱 방법이 미정

* 디버그의 어려움 때문에 C++에서는 매크로 사용을 최소화한다. 그러나 로깅할 때 활용하면 코드가 간결해진다.

-컴파일 시간 디버그 모드:

 -DEBUG_MODE나 #ifdef 전처리 기호로 디버그 코드 포함 결정

 -비주얼 C++에서 디버그 모드 빌드를 실행하면 _DEBUG 기로 자동 정의

 -고객 사이트에서 On/Off 못하는 단점

* 프로그램의 정상 실행 코드를 log() 호출문 안에 넣지 않는다. DEBUG_MODE가 정의돼 있지 않다면 제거해버리기 때문

-실행 시간 디버그 모드:

 -제일 유연

2. 링 버퍼:

-디버그 모드로 실행하지 않거나 디버그 모드 실행이 버그를 일으키면 정보 취득 불가

-한 가지 방법은 항상 트레이스 기록

-최근 트레이스만으로도 충분

-성능을 위해 디스크가 아닌 메모리에 저장. 필요할 때만 로그 파일에

-메세지 수나 일정 메모리 공간에 저장. 다차면 시작점에서 덮어써서 기록

-프로그램에 로그를 내보내는 인터페이스 필요

	27.4.3 어서션

-<cassert> 헤더의 assert 매크로로 호출

-bool 표현식을 받아서 false면 프로그램 종료. true면 아무것도 하지 않음

* 일반적으로 프로그램을 종료시키는 함수나 매크로는 사용하지 않는 것이 좋다. 그러나 assert는 예외. 치명적인 오류가 발생했다는 의미.

-assert를 사용하면 버그 조기 발견 가능

* 표준 assert 매크로는 전처리 기호인 NDEBUG를 기반으로 작동. 기호가 정의돼 있지 않으면 assert 적용. 반대면 무시. 컴파일러는 릴리스 버전 빌드시 NDEBUG 자동 정의. 남기고 싶다면 
  컴파일러 설정이나 NDEBUG에 관계없이 작동하는 assert 직접 정의

-변수 상태에 대해 암묵적 가정을 한 부분에 사용

-그러나 암묵적 가정은 최소화하기 > 변수값 확인이 먼저

-심각한 문제 발생 가능성이 있을 때만 assert.

-assert 발생시 즉시 해결

-프로그램의 정상 동작을 assert에 넣지 않는다.

	27.4.4 크래시 덤프

-크래시 덤프(crash dump)를 반드시 생성하도록 코딩

-메모리 덤프, 코어 덤프로도 불린다.

-크래시 발생시 여러 정보를 담는 파일 ex)스레드 정보

-생성 방식은 플랫폼 문서나 서드 파티 라이브러리에

-심벌 서버(symbol server)와 소스 코드 서버 반드시 구축

-심벌 서버는 디버그 기호 저장에 사용

-소스 코드 서버는 소스 코드 수정 내역 저장.

	27.5 정적 어서션

-static_assert()는 컴파일 시간 실행. assert()는 실행 시간

-매개변수는 bool 표현식과, string 에러 출력 메세지.

-C++17부터 출력 메세지는 옵션

-타입 트레이트와 함께 쓸 때 좋은 효과.

	27.6 디버깅 테크닉

-제일 먼저 할 일은 버그 재현

	27.6.1 버그 재현

-가장 먼저 할 일은 같은 입력으로 프로그램을 구동하는 것

-버그가 발생할 때까지 빠짐없이 입력

-완벽 재현이 안돼도 최선을 다한다.

-관련 테크닉:
 -버그 발생시와 같은 환경에서 비슷한 입력값으로 시도
 -버그 관련 코드 짧게 검토
 -자동화 테스트로 검사
 -하드웨어가 충분하면 병렬로 검사
 -스트레스 테스트

-재현이 가능해지면 버그 유발 동작 최소화

-버그 발생까지 동작을 나열하는 것이 도움된다.

	27.6.2 재현 가능한 버그 디버깅

-버그를 재현하면 원인을 찾는다.

-위 단계에서 버그 발생 코드의 위치를 정확히 찾는다:
 디버그 메세지 로깅
 디버거

	27.6.3 재현 불가능한 디버깅

-정보가 부족해 해결이 더 난해

-도움되는 접근:
 -최대한 재현 노력
 -에러 로그 분석
 -트레이스 정보 분석
 -크래시 덤프 파일 분석
 -코드 검토
 -메모리 와치 도구 활용
 -버그 리포트 기록 및 업데이트
 -트레이스를 남기는 코드 추가

-재현 가능 여부는 중요.

	27.6.4 회귀 버그 디버깅

-회귀 버그(regression bug)는 정상 작동 기능이 제대로 작동하지 않게 하는 버그

-코드 변경 로그 확인

-예전 버전들을 이진 탐색해 문제 발생 이전과 이후 찾기

	27.6.5 메모리 문제 디버깅

-프로그램이 뻗을 만큼의 치명적 버그의 원인은 대부분 메모리 에러

* 대부분의 메모리 문제는 스마트 포인터 사용으로 회피 가능

1. 메모리 에러 분류:

-증상과 버그 구분

-증상(symptom)은 버그로 인해 발생하는 동작

-메모리 해제 에러:
 메모리 누수: 프로세서 메모리 사용량 증가, 실행 속도 저하
 할당, 해제 연산자 불일치: 바로 크래쉬는 아닌 경우 다분, 메모리 누수
 이중 해제: 크래시 가능성 높음
 미할당 메모리 해제: 크래쉬
 스택 메모리 해제: 크래쉬

-메모리 접근 에러:
 엉뚱한 메모리 접근: 크래쉬
 해제된 메모리 접근: 엉뚱한 값
 다른 곳에서 할당된 메모리 접근: 크래쉬는 아니나 차후에 심각한 에러
 미초기화 메모리 접근: 크래쉬x

2. 메모리 에러 디버깅 관련 팁:

-버그가 재현 가능이지만 위치가 불규칙할 때는 메모리 에러 의심

-C++용 메모리 검사 도구 활용

-마이크로소프트의 Application Verifier: 릴리스 모드 빌드 후 찾기 어려운 에러를 찾아준다.

-최후의 수단으로 소스 코드 분석.

-객체와 클래스 관련 에러:
 -메모리 동적 할당시 해제는 정확한 양만
 -복제 생성자, 대입 연산자, 이동 생성자, 연산자 구동 확인.
 -형변환 확인

* 리소스 소유권은 최대한 스마트 포인터 활용. 영의 규칙을 따를 수 있도록

-일반 메모리 에러:
 -맞는 new와 delete 짝 사용
 -버퍼 오버런 주의
 -엉뚱한 포인터 역참조 조심
 -스택에 포인터 선언시 초기화 필수
 -클래스 멤버 포인터도 초기화 필수

	27.6.6 멀티스레드 프로그램 디버깅

-멀티스레드 프로그램 버그는 OS 스케줄링 타이밍 변화에서 기인할 때가 많다.

-위의 이유로 재현이 힘듬

-디버깅 기법:
 -디버거 활용
 -로그 기반 디버깅
 -강제로 잠재우거나 문맥을 전환하는 문장 추가:
  std::this_thread::sleep_for(), sleep_until();
 -코드 리뷰

-디버거 콜스택에서 직접 작성한 코드 첫 줄 > 변수 목록 확인

	27.7 요약

-버그가 발생하지 않게 최선을 다하되, 발생에 대비하는 것이 디버깅 원칙

-레거시 C++ 코드의 버그는 대부분 메모리에서

	28. 디자인 기법과 프레임워크

-디자인 기법(디자인 테크닉)은 문제 해결 방법론

-목적은 C++에서 불편한 점이나 없는 점을 극복하는 것

	28.1 흔히 사용하지만 까먹기 쉬운 문법

-클래스를 final로 선언해서 상속 방지

-static 멤버 초기화 기억

-C++17부터 inline으로 선언하면 정적 멤버 변수를 클래스 정의에서 초기화 가능

-자식 클래스 생성자에서 부모 클래스 초기화 잊지 않기

	28.1.3 복제 후 맞바꾸기 패턴

-대입 연산자에서 쓰인다.

-복제본 생성 > 복제본 수정 > 원본과 교체

	28.2 고급 기법

-이미 있는 것을 다시 만드는데 시간 허비 x

-재사용의 효과를 극대화하자.

	28.2.1 RAII

-자원의 할당과 해제를 생성자와 소멸자에서 자동화

* RAII 클래스에 절대로 디폴트 생성자를 두지 않는다.

	28.2.2 더블 디스패치

-더블 디스패치(double dispatch, 이중 패치)는 다형성에 다른 기준을 추가하는 기법

-객체가 두 개 이상일 때 실행 시간 타입에 따라 메서드를 결정하는 기능을 멀티 메서드(multi-method)라 부른다.

* 더블 디스패치는 다중 디스패치의 특수한 경우

1. 첫 번째 시도: 무작위 구현;

-가장 간단한 방법은 한 객체를 기준으로 if/else로 나머지 타입 검사

-지양 이유:
 -타입 직접 조회는 디자인 오류 시사
 -코드가 지저분해짐
 -새 타입 추가의 난점

2. 두 번째 시도: 오버로딩을 이용한 단방향 다형성;

-컴파일 시간에 매개변수의 타입을 알아야 한다.

-부모 타입으로 자식 객체를 만들었을 때 그 객체는 매개변수로 전달될 수 없는 단방향 다형성

-호출할 클래스 결정이 아닌 메서드 버전 결정에 다형성 활용

3. 세 번째 시도: 더블 디스패치;

-수퍼클래스 객체를 인자로 받고 this를 매개변수로 그 객체의 메서드를 호출하는 식

-다형성이 두 번 작동

-호출 메서드로 한 번, this로 호출할 때 한 번.

-bool Bear::eats(const Animal& prey) const {
     return prey.eatenBy(*this);
 }

	28.2.3 믹스인 클래스

-클래스 계층은 유지하고 동작만 추가하는 클래스

1. 믹스인 클래스 디자인:

-재사용이 가능한 코드를 담고 있다.

-계층에 넣을지 별도의 클래스로 만들지 숙고한다.

-계층 구성 기준이 여러 가지일 때 특히 효과적이다.

2. 믹스인 클래스 구현:

-일반 클래스와 같다.

3. 믹스인 클래스 사용:

-다중 상속과 같다. 부모 클래스 뿐만 아니라 믹스인 클래스도 상속.

	28.3 객체지향 프레임워크

-프레임워크란 객체지향 인터페이스로 내부 기능 제공 클래스를 모아둔 것.

	28.3.1 프레임워크 다루기

-프레임워크는 자체적인 접근 방식과 패턴이 있다는 것

-기본 모델과 구현 방식도 다양하다.

-프레임워크 다루는 방법을 익히는 것이 먼저
 -프레임워크의 디자인, 모델, 언어 특성을 제대로 이해해야 한다.

-프레임워크를 이해했다면 확장도 가능.

-프레임워크 자체 제공 데이터 타입도 존재

	28.3.2 MVC 패러다임

-MVC는 데이터를 표현하고 다루는 방식을 표현한 것.

-MVC에서 데이터의 집합을 모델이라 부른다.

-뷰(view)는 모델의 특정 부분을 시각화한 것

-컨트롤러는 특정 이벤트에 따라 모델을 변경하는 코드

	29. 디자인 패턴

-디자인 패턴이란 프로그램을 구성하는 방식에 대한 표준 접근 방식

-디자인 기법과의 차이는 애매

-디자인 패턴은 언어 의존성이 적다.

-주어진 패턴을 더 발전시킬 수도 있다는 자세 필요

	29.1 반복자 패턴

-반복자 패턴은 알고리즘과 데이터를 분리하는 메커니즘

-두 가지 문제 해결:
 -제네릭 알고리즘을 적용할 수 없다는 것
 -사용 객체 소스 코드 접근이 안돼서 동작 추가가 어려운 상황

-데이터 객체 -> 반복자  <- 연산

	29.2 싱글턴 패턴

-싱글턴 패턴은 프로그램에 클래스의 인스턴스가 단 하나인 것을 표현.

-싱글턴 패턴으로 구현한 클래스를 싱글턴 클래스라 부른다.

-주의할 점:
 -싱글턴이 여러 개면 초기화 순서 보장 힘듬
 -프로그램 종료시 싱글턴이 반드시 있도록 하기 힘듬
 -의존성을 가려서 타이트 커플링이 발생하고 단위 테스트 복잡해짐

-싱글턴 패턴은 유틸리티 클래스 구현에 적합

-로거에 많이 사용된다.

-싱글턴으로 구현이 좋을 때:
 -어디에서나 사용 가능해야 한다.
 -인스턴스가 하나
 -사용하기 쉬워햐 한다.

	29.2.2 싱글턴 구현 방법

-첫 번째 방법은 static 메서드로만 구성하는 것.
 -생성과 삭제 기능 미달
 -따지면 싱글턴이 아닌 static 클래스 
 -인스턴스 생성 불가

-다른 방법은 접근 제어 메커니즘을 활용하는 것

-C++는 로컬 static instance의 스레드 세이프 초기화를 보장. -> 매직 스태틱
 -초기화할 때만 안전

-복사, 이동 생성, 대입을 모두 delete

-생성자, 소멸자는 private으로 내부적으로만

-매직 스태틱으로만 인스턴스 접근

	29.3 추상 팩토리 패턴

-팩토리 패턴은 객체 생성을 생성자 호출이 아닌 팩토리에 요청하는 것

-장점:
 객체 생성 코드 결집
 타입을 잘 몰라도 계층에 맞게 생성
 팩토리 관리 정보로 객체 구성 가능
 객체 생성 과정 추상화

	29.4 프록시 패턴

-프록시(proxy)는 클래스 추상화를 내부 표현과 분리하는 패턴

-프록시는 실제 객체의 대리

-객체를 직접 다룰 수 없거나 오버헤드가 클 때 사용

	29.4.2 프록시 구현 방법

-pimpl

-같은 인터페이스를 가진 proxy 클래스에서 본 객체에 대한 소유권을 가지고 객체를 통해 메서드 호출.

	29.4.3 프록시 사용 방법

-제대로 정의했다면 다른 객체와 사용 방법이 같다.

	29.5 어댑터 패턴

-내부 추상화가 현재 디자인과 맞지 않지만 변경 불가일 때 어댑터 혹은 래퍼 클래스로 해결

	29.5.2 어댑터 구현 방법

-원하는 추상화에 맞게 인터페이스 정의 후 어댑터 클래스에서 상속

-어댑터 클래스는 원래 클래스와 composition으로 합성

-사용은 쉽고 다양한 용도에 맞을 수 있도록

	29.6 데코레이터 패턴

-객체를 꾸미는 역할

-래퍼라고도 부른다.

-객체의 동작을 실행 시간에 추가 및 변경.

-파생클래스와 비슷하지만 효과가 일시적이다.

	29.6.2 데코레이터 구현 방법

-공유 인터페이스 정의

-정의한 인터페이스를 상속하는 기본 클래스

-데코레이터도 같은 인터페이스 상속 및 인터페이스 타입을 매개변수로 받는 생성자 정의 및 인터페이스 타입 데이터 멤버 초기화.

-동작을 변형하고자 하는 인터페이스 구현.

	29.7 책임 사슬(chain of reponsibility) 패턴

-특정 동작을 여러 객체가 엮여서 처리할 때 사용

-가장 구체적인 클래스가 호출돼서 직접 처리하거나 부모에게 전달.

-계층에 맞게 구성하지만 필수는 아니다.

-이벤트 핸들러 구현에 주로 사용

	29.7.1 예제: 이벤트 처리

-이벤트 발생시 말단에서 처리 > 안되면 사슬의 다음 핸들러 > 처리까지 반복: 책임 사슬

	29.7.2 책임 사슬 구현 방법

-이벤트 처리가 안되면 받은 매개변수로 다음 핸들러(수퍼클래스) 함수를 호출

	29.7.3 책임 사슬 사용 방법

-적절한 객체에 이벤트를 전달하는 클래스가 따로 있어야 한다.

-책임 사슬 사용시 계층 구조에 맞으면서 유연한 코드 구성 가능.

-단점:
 -대신 프로그래머의 할 일이 증가
 -전달 사슬이 끊기면 이벤트 증발
 -엉뚱한 이벤트 전달 시 무한 루프

	29.7.4 책임 사슬이 계층 구조와 다른 경우

-핸들러 클래스를 따로 둔다.

-핸들러 클래스는 mNextHandler 핸들러 타입 멤버와 핸들을 맡아 mNextHandler의 핸들 함수를 호출하는 virtual 함수를 가진다.

-상속 및 오버라이딩하여 여러 핸들러 계층 구성.

	29.8 옵저버 패턴

-옵저버 객체가 옵저버블(observable) 객체로부터 알림을 받도록 구현

-옵저버블 객체에 옵저버를 등록해야 한다.

-옵저버블 객체 상태 변화시 알림

-옵저버 패턴은 결합도를 낮춘다는 장점

-옵저버블 객체는 옵저버의 타입의 기본 인터페이스 타입만 알면 된다.

	29.8.1 옵저버 구현 방법

-옵저버 인터페이스(notify 함수 포함)를 상속하는 옵저버 클래스 정의

-옵저버 객체 벡터를 멤버와 추가 및 삭제 메서드를 가지는 옵저버블 클래스 정의

-믹스인 클래스로서 활용

	29.9 요약

-많은 디자인 패턴 숙지보다 몇몇 패턴의 핵심 원리를 터득하는데 집중.

	30. 크로스 플랫폼과 크로스 언어 애플리케이션 개발 방법

-플랫폼이란 개발 시스템 및 런타임 시스템 구성 요소를 한데 묶은 것.

	30.1 크로스 플랫폼 개발

-C++ 플랫폼 이슈 발생 원인:
 -객체의 메모리 나열 방식 표준 부재
 -표준 구현 방식 부재 상태로 표준 언어와 라이브러리 제공
 -컴파일러 및 라이브버리마다 표준 해석 방식 상이
 -기능을 표준에 포함하는데 보수적

	30.1.1 아키텍쳐 이슈

-아키텍쳐(architecture)는 주로 프로그램이 실행될 프로세서를 말한다.

-윈도우나 리눅스 구동 표준 pc는 대부분 x86 x64를 따른다.

-하이레벨 언어는 컴파일러에서 프로세서에 맞는 어셈블리 코드로 변환해준다.

-그러나 간혹 문제가 드러난다.

1. 정수 크기:

-C++는 정수 타입의 크기를 명확히 정의하지 않는다.

-<cstdint>의 타입에서는 크기를 구체적 명시 ex)int8_t, int_fast8_t, int_least8_t, intmax_t, intptr_t
 // 표준에선 선택이지만 대다수 컴파일러가 지원.

-크로스 플랫폼 지원 -> <cstdint> 정의 타입 활용

2. 바이너리 호환성:

-C++ 컴파일시 바이너리 인스트럭션으로 변환되는데, 이때 바이너리 포멧은 플랫폼에 따라 다르다.

-호환성 보장 방법:
 플랫폼마다 바이너리 파일 따로 생성
 크로스컴파일(cross-compile)
 사용자 컴파일 하도록 오픈소스

3. 주소 크기:

-아키텍쳐가 32비트(4바이트)이다 -> 주소 크기가 32비트이다.

-주소 크기가 크면 연산이 더 빠르다. 다룰 수 있는 메모리 단위가 커져서.

-포인터의 크기는 제각각이다.

-포인터 크기는 반드시 정수 크기와 같을 필요가 없다.

-64비트 포인터를 32비트 포인터로 형변환시 32비트가 사라진다.

-<cstdint>헤더에 intptr_t은 포인터를 담는데 충분해야 한다.

* 포인터가 항상 4바이트라고 단정하면 안 된다. std::intptr_t 사용 시 외엔 포인터를 정수로 형변환하면 절대 안 된다.

4. 바이트 순서:

-숫자는 바이너리로 저장. 플랫폼마다 표현이 다를 수 있다.

-바이너리 수를 바이트로 나눴을 때 높은 자리 쪽을 상위 바이트(high-order byte) 낮은 쪽을 하위 바이트(low-order byte)라 한다.

-상위와 하위 바이트 나열 순서는 아키텍쳐마다 다르다.

-상위 바이트를 먼저 쓰면 빅엔디안(big-endian)
 하위 바이트를 먼저 쓰면 리틀엔디안(little-endian)

-어느 쪽이든 프로그램에 나오는 수는 일정하게 표현

-순서가 다른 플랫폼 포팅 시에만 주의

-한 가지 방법은 표준 네트워크 바이트 순서인 빅엔디안 채용

-바이너리 데이터 파일 입력 시 바이트 순서가 다른 시스템에서 열 경우 고려

	30.1.3 구현 이슈

-C++ 컴파일러는 표준을 따르도록 디자인 된다.

1. 컴파일러마다 특이한 점과 확장한 부분:

-컴파일러 업데이트 자주

-컴파일러의 최신 정보 습득

-컴파일러에 버그가 있다면 웹에서 해결 방법 서칭

-C++ 표준에서는 #pragma를 통해 컴파일러 자체적으로 언어 기능 확장하도록 허용

-#pragma 동작은 컴파일러 재량

2. 라이브러리 구현:

-반드시 컴파일러 기본 제공 표준 라이브러리를 사용할 필요는 없다. // 서드파티 버전도 존재

-표준 라이브러리마다 표준 해석 방식에 차이가 있다.

-표준 라이브러리 사용 시 라이브러리 개발자가 정한 디자인 타협점 이해

	30.1.3 플랫폼 종속적인 기능

-플랫폼이나 서드파티 라이브러리 제공 기능 중 중요한 것: // 언어 차원 제공 x
 GUI, 네트워킹, OS 이벤트와 애플리케이션 상호작용, 로우레벨 파일, 스레드

* 크로스 플랫폼 개발에 C++언어나 표준 라이브러리 미제공 기능이 필요하면 서드파티 크로스 플랫폼 라이브러리를 찾아야 한다. 플랫폼 종속 API를 사용하면 후에 크로스 플랫폼 지원이 
  힘들어진다. 각 기능을 플랫폼마다 구현해야 하기 때문에

	30.2 크로스 언어 개발

-다른 언어의 뛰어난 점과 C++의 장점을 조합할 수 있다

	30.2.1 C와 C++ 섞어 쓰기

-대부분의 C코드는 C++컴파일러로 컴파일 가능

-예외도 있다. ex) VLA

-C 코드 -> C++코드 변환: 포팅(porting)

-C와 C++ 연동은 어렵지 않다.

	30.2.2 패러다임 전환하기

-C와 C++를 섞을 때 문제는 객체 지향 특성이 사라질 수 있다는 것

-패러다임 충돌

-절차형에 대해 객체지향 방식의 래퍼를 구현하는 것이 좋다.

-이때 파사드 디자인 패턴 주로 적용

	30.2.3 C 코드와 링크하기

-라이브러리 형태의 컴파일된 C 코드는 C++에서 활용 가능. 그러나 추가 작업 필요

-C++는 오버로딩 구현을 위해 네임 맹글링 연산을 실행해 함수 이름을 재생성한다.

-네임 맹글링으로 생성된 이름은 링커에 맞는 이름으로 재생성된다.

-C 언어에서는 오버로딩을 지원하지 않는다.

-컴파일하면 네임 맹글링으로 생성된 이름과 링크하는 요청이 생성.

-함수가 하나여도 마찬가지

-하지만 C 라이브러리와 링크하면 링크 에러

-네임 맹글링 대상 비지정을 컴파일러에서 설정:
 extern "language" {}
 ex) extern "C" { void doCFunction(int i); }

-C++ 표준은 모든 언어 사용이 가능하다하나 대부분 C만 지원

-extern은 링크된 바이너리 파일에 어떤 언어인지 알려준다

-extern은 헤더에서 주로 사용

-다른 방법은 컴파일러에 따라 언어를 결정하도록 작성하는 것
 -C++ 컴파일러는 자동으로 _cplusplus 기호 정의 > #ifdef, #endif와 활용

	30.2.4 C#에서 C++코드 호출하기

-C# 인터롭 서비스(interop service)를 활용하면 쉽게 C++ 코드 호출 가능

-C++를 라이브러리화해야 인터롭 이용 가능

-윈도우는 라이브러리를 .DLL 파일로 만든다.

-함수를 프로그램이 아닌 라이브러리로 제공해야 한다.

-프로젝트 속성 지정 메뉴에서 구성 타입을 DLL으로
 혹은 _declspec(dllexport)

-C#에서 인터롭 네임스페이스 지정
 using System.Runtime.InteropServices;

-함수 프로토타입 정의
 [DllImport("HelloCpp.dll", CharSet = CharSet.Unicode)] // 반드시 유니코드 스트링으로 지정
 public static extern int FunctionInDLL(String s);

	30.2.5 JNI로 자바에서 C++ 코드 호출하기

-JNI(Java Native Interface) 사용 시 다른 언어 라이브러리 활용 가능

	30.2.8 C++에서 어셈블리 코드 호출하기

-근래는 컴파일러 코드 생성기보다 효율적인 어셈블리 작성이 힘들다.

-굳이 어셈블리 코드를 추가하려면 C++ 컴파일러 제공 asm 키워드 사용

-asm은 표준에 정의돼 있지만 구현 방식은 컴파일러 의존

-asm 키워드 지원 방식이 아키텍쳐에 따라 달라질 수 있다.

-어셈블리 코드 사용 지양 이유:
 -낮은 이식성
 -유지보수의 어려움
 -가독성 하락
 -낮은 필요성

* 성능에 문제가 있다면 최후의 방법으로만 어셈블리 코드를 사용한다. 프로파일러 사용 후 언어, 디자인 차원의 최적화부터 고려한다.

-실전에서는 연산 집중 부분을 함수로 빼두고 어셈블리 변환 시 성능 향상 정도를 검토.

-먼저 extern "c" 선언으로 네임 맹글링 차단(해독 오버헤드 제거)

-변환하고자 하는 부분의 어셈블리 코드를 별도 모듈로 구현.

-만든 모듈을 asm 키워드로 C++내 구동이 아닌 별도 파일에 작성하고 어셈블러로 구동 가능. // 주로 컴파일러 asm 키워드 미제공 시

-성능 향상이 확연할 때만 어셈블리 사용